<!doctype html>

<!--[if lt IE 7 ]> <html class="ie ie6 no-js" lang="ca"> <![endif]-->
<!--[if IE 7 ]>    <html class="ie ie7 no-js" lang="ca"> <![endif]-->
<!--[if IE 8 ]>    <html class="ie ie8 no-js" lang="ca"> <![endif]-->
<!--[if IE 9 ]>    <html class="ie ie9 no-js" lang="ca"> <![endif]-->
<!--[if gt IE 9]><!--><html class="no-js" lang="ca"><!--<![endif]-->
<!-- the "no-js" class is for Modernizr. -->

<head id="www-sitename-com" data-template-set="html5-reset">

	<meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html">
        
	<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Programació bàsica (ASX) \ Programació (DAM i DAW)</title>
	
<!-- <meta name="title" content=""> --> 
	<meta name="description" content="">
	<!-- Google will often use this as its description of your page/site. Make it good. -->
	
	<meta name="google-site-verification" content="">
	<!-- Speaking of Google, don't forget to set your site up: http://google.com/webmasters -->
	
	<meta name="author" content="Institut Obert de Catalunya">
	<meta name="Copyright" content="Copyright Institut Obert de Catalunya 2011. All Rights Reserved.">

	<!-- Dublin Core Metadata : http://dublincore.org/ -->
	<meta name="DC.title" content="Programació bàsica (ASX) \ Programació (DAM i DAW)">
	<meta name="DC.subject" content="Informàtica i comunicacions">
	<meta name="DC.creator" content="Institut Obert de Catalunya">
	
	<!--  Mobile Viewport Fix
	j.mp/mobileviewport & davidbcalhoun.com/2010/viewport-metatag 
	device-width : Occupy full width of the screen in its current orientation
	initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
	maximum-scale = 1.0 retains dimensions instead of zooming in if page width < device width
	-->
	<!-- Uncomment to use � use thoughtfully!
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	-->

	<link rel="shortcut icon" href="../../../img/favicon.ico">
	<!-- This is the traditional favicon.
		 - size: 16x16 or 32x32
		 - transparency is OK
		 - see wikipedia for info on browser support: http://mky.be/favicon/ -->
		 
	<link rel="apple-touch-icon" href="../../../img/apple-touch-icon.png">
	<!-- The is the icon for iOS's Web Clip.
		 - size: 57x57 for older iPhones, 72x72 for iPads, 114x114 for iPhone4's retina display (IMHO, just go ahead and use the biggest one)
		 - To prevent iOS from applying its styles to the icon name it thusly: apple-touch-icon-precomposed.png
		 - Transparency is not recommended (iOS will put a black BG behind the icon) -->
	
	<!-- CSS: screen, mobile & print are all in the same file -->
	<link rel="stylesheet" href="../../../_/css/style.css">

	<!-- CSS: jQuery UI -->
	<link rel="stylesheet" href="../../../_/css/jquery-ui.css">
	
	<!-- all our JS is at the bottom of the page, except for Modernizr. -->
	<script src="../../../_/js/modernizr-1.7.min.js"></script>
	<script src="../../../_/js/Hyphenator.js" type="text/javascript"></script>
	<script type="text/javascript">
	   Hyphenator.config({
		minwordlength : 4
	   });
	   Hyphenator.run();
	</script>
    <script src="../../../_/js/build.js" type="text/javascript"></script>
</head>

<body class="style-newspaper">

<div class="wrapper"><!-- not needed? up to you: http://camendesign.com/code/developpeurs_sans_frontieres -->

	<header id="header">
		<div class="head"><a href="http://ioc.gencat.cat"><img src="../../../img/logo.png" alt="Institut Obert de Catalunya"/></a><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/es/deed.ca"><img src="../../../img/license.png" alt="Llic&egrave;ncia" class="license"/></a></div>
		<div class="headdocument"><a href="../../../index.html">Programació bàsica (ASX) \ Programació (DAM i DAW)</a></div>
        <div id="search" class="search" name="search">
         <form id="frmsearch" action="../../../search.html" method="get">
          <input type="text" name="q"/>
        </form>
        </div>
	</header>
   <div id="upbutton" class="upbutton" style="display:none;"><img src="../../../img/uparrow.png" alt="Pujar a l'inici de p&agrave;gina"/></div>
   <aside id="aside">
    <div id="menu">
      <ul>
       <li name="toc"><div><img src="../../../img/toc.png" alt="&Iacute;ndex"/></div></li>
       <li name="settings"><div><img src="../../../img/settings.png" alt="Configuraci&oacute;"/></div></li>
       <li name="printer"><div><img src="../../../img/printer.png" alt="Imprimir"/></div></li>
       <li name="favorites"><div><img src="../../../img/favorites.png" alt="Favorits"/></div></li>
       <li name="help_icon" class="help_icon"><div><img src="../../../img/help_icon.png" alt="Ajuda"/></div></li>
      </ul>
     </div>
   </aside>
   <div id="sidebar-hide" name="sidebar-hide"><img src="../../../img/arrows.png"/></div>
   <section>
     <div id="toc" class="hidden">
      <div class="menucontent">
        <ul>
        <li id="u5" class="parentnode"><p><a class="unit" href="../../../WebContent/u5/introduccio.html">5. Biblioteques. Proves. Recursivitat</a></p><ul class="expander"><li id="u5introduccio"><a href="../../../WebContent/u5/introduccio.html">Introducció</a></li><li id="u5resum"><a href="../../../WebContent/u5/resum.html">Resum</a></li><li id="u5resultats_d_aprenentatge"><a href="../../../WebContent/u5/resultats_d_aprenentatge.html">Resultats d'aprenentatge</a></li><li id="u5mapa"><a href="../../../WebContent/u5/mapa.html">Mapa conceptual</a></li><li id="u5referencies"><a href="../../../WebContent/u5/referencies.html">Referències</a></li><li id="u5a1" class="tocsection"><p id='u5a1continguts'><a class="section" href="../../../WebContent/u5/a1/continguts.html">Descomposició en classes i biblioteques</a><span class="buttonexp"></span></p><ul><li id="u5a1activitats"><a href="../../../WebContent/u5/a1/activitats.html">Activitats</a></li><li id="u5a1exercicis"><a href="../../../WebContent/u5/a1/exercicis.html">Exercicis d'autoavaluació</a></li></ul></li><div data-parent-id='u5a1' class='tocssection hidden'><div class="toc"><ul><li><a href="../../../WebContent/u5/a1/continguts.html#programes_amb_multiples_classes">Programes amb múltiples classes</a></li><li><a href="../../../WebContent/u5/a1/continguts.html#biblioteques_de_classespackages">Biblioteques de classes: packages</a></li><li><a href="../../../WebContent/u5/a1/continguts.html#l_api_del_llenguatge_java">L'API del llenguatge Java</a></li><li><a href="../../../WebContent/u5/a1/continguts.html#metodes_estatics">Mètodes estàtics</a></li><li><a href="../../../WebContent/u5/a1/continguts.html#documentacio_de_programes_en_java">Documentació de programes en Java</a></li><li><a href="../../../WebContent/u5/a1/continguts.html#solucio_dels_reptes_proposats">Solució dels reptes proposats</a></li></ul></div></div><li id="u5a2" class="tocsection"><p id='u5a2continguts'><a class="section" href="../../../WebContent/u5/a2/continguts.html">Creació d'una aplicació modular. El joc de combats a l'arena</a><span class="buttonexp"></span></p><ul><li id="u5a2activitats"><a href="../../../WebContent/u5/a2/activitats.html">Activitats</a></li><li id="u5a2exercicis"><a href="../../../WebContent/u5/a2/exercicis.html">Exercicis d'autoavaluació</a></li><li id="u5a2annexos"><a href="../../../WebContent/u5/a2/annexos.html">Annexos</a></li></ul></li><div data-parent-id='u5a2' class='tocssection hidden'><div class="toc"><ul><li><a href="../../../WebContent/u5/a2/continguts.html#el_joc_de_combats_a_l_arena">El joc de combats a l'arena</a></li><li><a href="../../../WebContent/u5/a2/continguts.html#la_biblioteca_jocarenaregles">La biblioteca "joc.arena.regles"</a></li><li><a href="../../../WebContent/u5/a2/continguts.html#la_biblioteca_jocarenainterficie">La biblioteca "joc.arena.interficie"</a></li><li><a href="../../../WebContent/u5/a2/continguts.html#la_classe_principal">La classe principal</a></li><li><a href="../../../WebContent/u5/a2/continguts.html#simplificacio_d_algorismes_complexos_usant_recursivitat">Simplificació d'algorismes complexos usant recursivitat</a></li></ul></div></div></ul></li><li id="" class="indexnode"><p><a href="../../../index.html">Anar a l&#39;&iacute;ndex general</a></p></li>
        </ul>
      </div>
    </div>
   </section>
   <section>
   <div id="settings" class="hidden">
    <div class="menucontent">
     <div class="allsettings">
     <div class="settings">
      <label>Font i Color</label>
		<div class="setting-option">
	        <ul class="fontBackground">
				<li id="style-newspaper" title="Newspaper" class="appearance-style-newspaper"><span>Newspaper</span></li>
                <li id="style-novel" title="Novel" class="appearance-style-novel"><span>Novel</span></li>
                <li id="style-ebook" title="eBook" class="appearance-style-ebook"><span>eBook</span></li>
				<li id="style-inverse" title="Inverse" class="appearance-style-inverse active"><span>Inverse</span></li>
				<li id="style-athelas" title="Athelas" class="appearance-style-athelas"><span>Athelas</span></li>
			</ul>
		</div>
     </div>
	<div class="settings">
      <label>Amplada</label>
		<div class="setting-option">
	        <div id="slider-width"></div>
		</div>
     </div>
     <div class="settings">
      <label>Mida de la font</label>
		<div class="setting-option">
	        <div id="slider-font"></div>
		</div>
     </div>
     <div class="settings">
      <label>Mida de la font</label>
	  <div class="setting-option">
       <form action="" class="sett-options">
		<ul>
		    <li><input type="checkbox" id="secondary-content" /><label for="secondary-content">Mostra recursos complementaris</label></li>
		    <li><input type="checkbox" id="main-images" /><label for="main-images">Mostra imatges</label></li>
		    <li><input type="checkbox" id="text-alignment" /><label for="text-alignment">Text justificat</label></li>
			<li><input type="checkbox" id="text-hyphen" /><label for="text-hyphen">Partici&oacute; sil·l&agrave;bica</label></li>
		</ul>
       </form>
	  </div>
     </div>
     </div>
    </div>
   </div>
   </section>
 <section>
 <div id="favorites" class="hidden"></div>
 </section>   
 <div id="bridge" class="hidden"></div>
 <div id="help" class="hidden">
  <div class="helptitle">Dreceres del teclat<hr></div>
  <div class="helpsection"><span>General</span>
   <ul>
    <li><span class="shortcut">g</span>: Anar al men&uacute; de navegaci&oacute;</li>
    <li><span class="shortcut">o</span>: Anar a opcions</li>
    <li><span class="shortcut">s</span>: Guardar la p&agrave;gina actual a favorits</li>
    <li><span class="shortcut">p</span>: Imprimir la p&agrave;gina actual</li>
    <li><span class="shortcut">?</span>: Mostrar/Ocultar l&#39;ajuda</li>
   </ul>
  </div>
  <div class="helpsection"><span>Navegaci&oacute;</span>
   <ul>
    <li><span class="shortcut">i</span>: Anar a l&#39;&iacute;ndex general</li>
    <li><span class="shortcut">t</span>: Anar a l&#39;inici de p&agrave;gina</li>
    <li><span class="shortcut">b</span>: Anar al final de p&agrave;gina</li>
    <li><span class="shortcut">j</span>: Anar cap endavant dintre la p&agrave;gina</li>
    <li><span class="shortcut">k</span>: Anar cap enrere dintre la p&agrave;gina</li>
    <li><span class="shortcut">h</span>: Anar a la p&agrave;gina anterior:</li>
    <li><span class="shortcut">l</span>: Anar a la p&agrave;gina seg&uuml;ent:</li>
   </ul>
   </div>
 </div>
 <div id="favcounter" name="favcounter" class="hidden"><span></span></div>
 <div id="navmenu" class="navmenu"><ul class="webnav"><li><a href="../../../index.html" title="Anar a l&#39;&iacute;ndex general">Inici</a></li><li><a href="../introduccio.html">Biblioteques. Proves. Recursivitat</a></li><li>Descomposició en classes i biblioteques</li></ul></div>
	<div id="content" lang="ca" class="hyphenate text">
     <article lang="ca" class="sheet">
        <h1><a id="descomposicio_en_classes_i_biblioteques"> Descomposició en classes i biblioteques </a></h1>
    	
<p>
A l’hora de crear una unitat didàctica o un llibre, estructurar-la en apartats o capítols permet que sigui molt més fàcil plantejar els seus continguts, des del punt de vista de l’autor, i seguir o comprendre, des del punt de vista del lector (o el mateix autor, si en el futur vol fer esmenes). Ara bé, per molt ordenada que sigui aquesta estructura, a mesura que creix la mida del document, tard o d’hora arribarà el moment que caldrà plantejar-se si més aviat el que resulta necessari és començar una nova unitat o un nou volum. Un document massa llarg es fa feixuc i difícil de gestionar. Quan això succeeix, normalment la divisió es plantejarà de manera que cada unitat o volum correspongui a una temàtica i resultats d’aprenentatge concrets.
</p>

<p>
En aquest sentit, i com ja heu vist, un programa no és gaire diferent. La seva subdivisió en diferents mètodes a partir de l’aplicació del disseny descendent permet tenir codi endreçat i polit, molt més fàcil tant de crear com d’entendre. Addicionalment, també permet reusar codi útil en diferents parts del programa, en lloc d’haver de reescriure’l diverses vegades. Ara bé, també de la mateixa manera, si el programa és complex i acaba requerint de molts mètodes, la quantitat de mètodes de tota mena i la mida del seu fitxer també pot arribar a ser considerable.
</p>

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10m3u5_01.png" class="imgB" title="Un programa monolític és com un bloc de pedra, fet d&#039;una sola peça. Font: Richard-sr" alt="Un programa monolític és com un bloc de pedra, fet d&#039;una sola peça. Font: Richard-sr" /></li><li><small>Un programa monolític és com un bloc de pedra, fet d&#039;una sola peça. Font: Richard-sr</small></li>
</ul></div>

</p>

<p>
Una solució que permeten molts llenguatges de programació és seguir exactament el camí de l’analogia plantejada: dividir el codi del programa en diferents parts, d’acord a una temàtica concreta.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Un <strong>programa  modular</strong> és aquell que s’ha desenvolupat dividint-lo en components fàcils de modificar i intercanviar, anomenats <strong>mòduls</strong>. Cada mòdul agrupa un conjunt de funcions o mètodes que realitzen tasques relacionades.
</p>
</div></div>
<p>
En contraposició a un programa modular, hi ha els <strong>programes monolítics</strong>, en els quals tot el codi es concentra en un únic mòdul. Normalment, en el cas de programes complexos, se sol considerar un mal hàbit fer programes monolítics. 
</p>

<h2><a id="programes_amb_multiples_classes" >Programes amb múltiples classes</a></h2>
<div class="level2">

<p>

</p>

<p>
La manera més directa de fer un programa modular és establir una correspondència un a un entre mòduls i fitxers on està escrit el codi font d’un programa. Per tant, cada mòdul es representa amb un fitxer de codi font diferent. Aquesta aproximació es pot usar en molts llenguatges de programació. En el cas de Java, un programa modular està compost de l’agregació de múltiples classes, en lloc de només una com heu treballat fins ara.
</p>

</div>

<h3><a id="que_es_realment_una_classe" >Què és realment una classe?</a></h3>
<div class="level3">

<p>
Abans de veure com és possible fer un programa modular, val la pena recapitular sobre el concepte de “classe” i la seva aplicació dins dels programes que es desenvolupen en Java. Si bé una definició estricta i formal d’aquest concepte està molt vinculada a l’orientació a objectes, i per tant més enllà de l’àmbit d’aquest temari, si feu recull de tots els cops que s’ha usat des d’una perspectiva pràctica, us adonareu que ha estat per referir-se a tres coses.
</p>
<ul>
<li class="level1"><div class="li"> <strong>Un programa en Java</strong>. D’una banda, els fitxers dels vostres programes, pròpiament, són classes (al cp i a la fi, s’inicien amb la declaració <code>public class…</code>). En aplicar disseny descendent, el seu codi queda distribuït en un mètode principal (<code>main</code>), que indica la seva primera instrucció i el punt d’inici del seu flux de control, junt amb diferents mètodes addicionals que poden ser invocats directament.</div>
</li>
<li class="level1"><div class="li"> <strong>Un repositori de mètodes</strong>. D’altra banda, també s’ha usat el terme classe per referir-se a biblioteques de mètodes, que actuen com extensions en les instruccions disponibles per defecte en el llenguatge. Abans de poder fer-ho, però, cal inicialitzar-les correctament. L’exemple més clar és la classe <code>Scanner</code>, que ofereix un repertori de mètodes per controlar la lectura de dades des del teclat (<code>nextLine()</code>, <code>nextInt()</code>, <code>hasNextFloat()</code>, etc.).</div>
</li>
<li class="level1"><div class="li"> <strong>Un tipus compost</strong>. Finalment, aquest mateix terme s’ha usat com a sinònim de tipus compost. En aquest cas, l’exemple per antonomàsia és la classe <code>String</code>, utilitzada per referir-se a cadenes de text dins de Java. Els tipus compostos de Java permeten manipular dades complexes mitjançant la invocació de mètodes (<code>charAt(…)</code>, <code>indexof(…)</code>, etc.).</div>
</li>
</ul>

<p>
Si us hi fixeu, en tots tres casos hi ha un factor comú. Tots disposen d’un conjunt de mètodes que és possible invocar. I és que, en realitat, tot i les seves diferències en el context sota el qual s’usen i la manera d’invocar els seus mètodes, els tres casos són exactament el mateix en darrera instància: codi font dins un fitxer anomenat <code>NomClasse.java</code>, amb la declaració <code>public class NomClasse…</code>, i estructurat com un seguit de mètodes declarats dins seu.
</p>
<div class="iocreference"><div class="ioccontent">
<p>
El codi font de <code>Scanner</code> i <code>String</code> està disponible a la pàgina de <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" class="urlextern" title="http://www.oracle.com/technetwork/java/javase/downloads/index.html"  rel="nofollow">descàrregues</a> d’Oracle (<em>Java SE 6 JDK Source Code</em>). Ara bé, no és pas senzill d’entendre!
</p>
</div></div>
<p>
Per tant, tot i que no sabeu exactament quin és el seu codi font al complet, està clar que la classe <code>Scanner</code> ha estat desenvolupada per algú altre, dins d’un fitxer anomenat <code>Scanner.java</code>, i una part del seu codi és:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class Scanner {</div></li><li class="li1"><div class="de1">  //Altres declaracions (constants, vars. globals...) ...</div></li><li class="li1"><div class="de1">  public String nextLine() {</div></li><li class="li1"><div class="de1">    //Codi del mètode ...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public int nextInt() {</div></li><li class="li1"><div class="de1">    //Codi del mètode ...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Altres mètodes ...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
El mateix passa amb la classe <code>String</code> (amb les definicions dels seus propis mètodes):
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class String {</div></li><li class="li1"><div class="de1">  //Altres declaracions (constants, vars. globals...) ...</div></li><li class="li1"><div class="de1">  public int indexOf(String textACercar)() {</div></li><li class="li1"><div class="de1">    //Codi del mètode ...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public int length() {</div></li><li class="li1"><div class="de1">    //Codi del mètode ...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Altres mètodes ...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h3><a id="estructura_d_un_programa_modular_en_java" >Estructura d&#039;un programa modular en Java</a></h3>
<div class="level3">

<p>
Un cop s’ha vist que totes les classes, independentment del seu rol, en realitat es codifiquen de la mateixa manera (com fitxers que contenen un seguit de mètodes que poden ser invocats), és el moment de veure com es relacionen a escala general per generar un programa modular.
</p>

<p>
Primer de tot, es recapitularà també sobre què és un programa, preveient tots els nous elements que heu anat aprenent. Recordeu que un programa no és més que una seqüència ordenada d’instruccions que es van executant d’inici a fi. Aquesta seqüència té certes particularitats, ja que mitjançant les estructures de control (selecció i repetició), és possible crear bifurcacions o bucles a la seqüència. A més a més, per a programes complexos, també es poden trobar invocacions a mètodes, fent possible distribuir les instruccions en blocs diferents, que poden ser executats repetides vegades en diferents moments del procés. Tots aquests mètodes estan escrits dins un mateix fitxer, que conté el codi font de tot el programa. D’entre tots els mètodes, hi ha el principal (<code>main</code>), el qual indica quina és la primera instrucció. 
</p>

<p>
Doncs bé, l’única diferència d’un programa modular en Java és que els mètodes, en lloc d’estar escrits tots en el mateix fitxer, estan distribuïts dins de diferents fitxers (diferents classes), tal com es contrasta a la <span class="figref"><a href="#Figure1"><span>figura</span></a></span>. Fixeu-vos que només canvia on estan escrits físicament els mètodes, però el flux de control, amb l’ordre d’execució de les instruccions i invocació dels mètodes, és exactament el mateix. En aquest exemple, el programa modular es composaria de tres fitxers diferents, anomenats <code>Principal.java</code>, <code>Modul1.java</code> i <code>Modul2.java</code>.
</p>

<p>
Normalment, l’escriptura de mètodes en fitxers separats no és arbitrària, sinó que se sol fer d’acord a algun criteri d’ordre, com agrupar mètodes per funcionalitats semblants (una classe amb els mètodes relacionats amb operar amb <em>arrays</em>, una altra amb els que llegeixen dades des del teclat, etc.). Per tant, el quid de la qüestió per fer un programa modular és ser capaç de decidir amb criteri com distribuir els diferents mètodes en diferents classes (i en quantes) i saber com invocar mètodes declarats a altres classes.
</p>

<p>
D’entre totes les classes que composen un programa modular en Java, hi ha d’haver una d’especial, a la qual se sol referir com a <strong>classe principal</strong> (<em>Main class</em>). Aquesta és l’única, d’entre totes, que disposa d’un mètode principal declarat en el seu codi (la resta no el tenen). A la figura, <strong>Principal.java</strong> seria la classe principal. Per executar un programa modular en Java, només cal executar aquesta classe principal. A partir d’aquí, l’execució de les diferents instruccions segueix el flux de control habitual, partint del mètode principal d’aquesta classe, tal com s’ha mostrat a la figura.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Els IDE solen distingir gràficament el fitxer de la classe principal amb alguna icona especial.
</p>
</div></div><div class="iocfigure"><a name="Figure1"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Flux de control d’un programa monolític i un de modular en Java

</figcaption><img src="../media/ic10m3u5_02.png" alt="" /></figure>
</div><div class="iocexample"><div class="ioccontent"><p class="ioctitle">Els mètodes main i inici</p>
<p>
Donat el tipus de plantilla que s’usa en aquests materials per poder fer classes amb mètodes, a la classe principal hi ha d’haver tant el mètode <code>main</code> com el mètode <strong>inici</strong>. Cap dels dos és necessari a la resta de classes.
</p>
</div></div>
<p>
Les classes addicionals dins un programa modular, que no són la principal, normalment tenen dos orígens. Poden ser classes creades per vosaltres mateixos, o bé creades per altres desenvolupadors. En qualsevol dels dos casos, totes estan declarades i codificades en fitxers <code>.java</code> per separat.
</p>

</div>

<h3><a id="definicio_i_us_de_classes_addicionals" >Definició i ús de classes addicionals</a></h3>
<div class="level3">

<p>

</p>

<p>
Com acabeu de veure, és possible dividir el codi dels vostres programes en diferents classes, en lloc de tenir-lo en una de sola. Atès que és el cas més senzill, aquesta secció se centrarà en la definició de classes addicionals que es comporten simplement com repositoris de mètodes, i no és el cas dels tipus compostos.
</p>

<p>
Primer de tot, cal establir un criteri general sota el qual decidir quan val la pena dividir els mètodes d’un programa entre diferents classes. Normalment, un primer criteri molt bàsic que us ha de fer pensar a aplicar modularitat és trobar-se davant d’un programa amb un fitxer de codi font llarg, on hi ha molts mètodes. Ara bé, el més important de tots és identificar mètodes que realitzen tasques del que es podria considerar una mateixa temàtica i que creieu que el seu codi us pot ser d’utilitat en el futur per a altres programes que genereu.
</p>

<p>
Com a fil argumental per veure tot plegat, vegeu un exemple concret no gaire complex. Suposeu un programa per dur a terme algunes operacions típiques (màxim, mínim i mitjana) sobre el conjunt de notes d’una classe. Per centrar l’exemple en l’aspecte important ara, generar un programa dividit en diferents classes, s’obviaran detalls com la interfície (entrada des del teclat, menús, etc.). 
</p>

<p>
El programa tal com es podria plantejar directament partint d’una descomposició per disseny descendent, podria ser el que es mostra tot seguit:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class RegistreNotes {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    RegistreNotes programa = new RegistreNotes();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    double[] notes = {2.0, 5.5, 7.25, 3.0, 9.5, 8.25, 7.0, 7.5};</div></li><li class="li1"><div class="de1">    double max = calcularMaxim(notes);</div></li><li class="li1"><div class="de1">    double min = calcularMinim(notes);</div></li><li class="li1"><div class="de1">    double mitjana = calcularMitjana(notes);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La nota màxima és &quot; + max + &quot;.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La nota mínima és &quot; + min + &quot;.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La mitjana de les notes és &quot; + mitjana + &quot;.&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public double calcularMaxim(double[] array) {</div></li><li class="li1"><div class="de1">    double max = array[0];</div></li><li class="li1"><div class="de1">    for (int i = 1; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      if (max &lt; array[i]) {</div></li><li class="li1"><div class="de1">        max = array[i];</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return max;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public double calcularMinim(double[] array) {</div></li><li class="li1"><div class="de1">    double min = array[0];</div></li><li class="li1"><div class="de1">    for (int i = 1; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      if (min &gt; array[i]) {</div></li><li class="li1"><div class="de1">        min = array[i];</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return min;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public double calcularMitjana(double[] array) {</div></li><li class="li1"><div class="de1">    double suma = 0;</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      suma = suma + array[i];</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return suma/array.length;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Tot i no ser un programa molt llarg, s’aplicarà modularitat. D’entrada, una característica que sí que es pot identificar és el fet que hi ha tres mètodes de temàtica similar: fer operacions típiques basades en recorreguts sobre <em>arrays</em> de reals (<code>calcularMaxim</code>, <code>calcularMinim</code>, <code>calcularMitjana</code>). Aquesta mena d’operacions són molt generals i de ben segur que se solen usar en diferents programes. Per tant, pot tenir sentit declarar-los en una classe a part que serveixi com un repertori general de mètodes per treballar amb <em>arrays</em> de reals.
</p>

</div>

<h4><a id="definicio_de_classes_addicionals" >Definició de classes addicionals</a></h4>
<div class="level4">

<p>
Per dividir un programa en classes diferents, només cal crear tants fitxers com classes es vol, cadascun amb el seu nom i definició pròpia, tal com heu fet fins ara. D’entre totes elles alguna haurà de ser la classe principal (en aquest cas, que contingui com a mínim els mètodes <code>main</code> i <code>inici</code>). La resta contindrà els mètodes que es vulgui distribuir.
</p>

<p>
Si a l’exemple volem que <code>RegistreNotes</code> sigui la classe principal i declarar els tres mètodes per treballar amb <em>arrays</em> de reals en una nova classe anomenada <code>CalculsArrayReals</code>, caldria crear un nou fitxer amb el contingut següent:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class CalculsArrayReals {</div></li><li class="li1"><div class="de1">  public double calcularMaxim(double[] array) {</div></li><li class="li1"><div class="de1">    double max = array[0];</div></li><li class="li1"><div class="de1">    for (int i = 1; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      if (max &lt; array[i]) {</div></li><li class="li1"><div class="de1">        max = array[i];</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return max;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public double calcularMinim(double[] array) {</div></li><li class="li1"><div class="de1">    double min = array[0];</div></li><li class="li1"><div class="de1">    for (int i = 1; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      if (min &gt; array[i]) {</div></li><li class="li1"><div class="de1">        min = array[i];</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return min;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public double calcularMitjana(double[] array) {</div></li><li class="li1"><div class="de1">    double suma = 0;</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      suma = suma + array[i];</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return suma/array.length;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">} </div></li></ol></pre>

<p>
Fora de la manca d’un mètode principal a les classes addicionals, totes les classes són exactament iguals a nivell de sintaxi. Tot el que heu après es pot aplicar per a qualsevol d’elles (definició i ús de constants, variables globals, àmbit de variables, etc.).
</p>

</div>

<h4><a id="us_de_classes_addicionals" >Ús de classes addicionals</a></h4>
<div class="level4">

<p>
Un cop declarats en una classe a part, els mètodes poden ser eliminats de la classe original (<code>RegistreNotes</code>), ja que en cas contrari tindríeu codi repetit. Precisament, en un programa modular, el que succeeix és que des d’una classe s’invoquen mètodes declarats a una classe diferent. Però cada mètode només està escrit un únic cop entre totes les classes del programa.
</p>

<p>
La invocació de mètodes que no estan escrits en el mateix fitxer és diferent del cas que heu vist fins ara, on totes estan escrites dins el fitxer d’una mateixa classe. Ja no es pot dur a terme simplement escrivint el nom del mètode (junt amb els seus paràmetres, si escau). Primer cal un pas previ d’inicialització, a partir del qual es permet la invocació dels mètodes externs. En dur a terme aquest procés, s’assigna un identificador a partir del qual és possible invocar els mètodes d’aquella classe, usant-lo com a prefix a la invocació. Sense aquest pas previ, és impossible invocar mètodes escrits a altres classes.
</p>

<p>
La sintaxi per fer-ho és la següent:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">NomClasse identificador = new NomClasse();</div></li><li class="li1"><div class="de1">identificador.nomMètode(paràmetres);</div></li></ol></pre>

<p>
El comportament de la invocació del mètode és idèntica a quan es fa sobre un mètode escrit a la mateixa classe (ús de paràmetres, avaluació d’acord al seu valor de retorn). Només canvia la sintaxi, ja que es requereix aquest prefix producte de la inicialització. Cal dir que, donades diverses invocacions a mètodes d’una mateixa classe externa, només és necessari fer la inicialització una única vegada. L’àmbit i la validesa de l’identificador és el mateix que una variable.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
En nomenclatura Java, el procés d’inicialització s’anomena formalment instanciació de la classe.
</p>
</div></div>
<p>
En el cas de l’exemple, el codi de la classe <code>RegistreNotes</code> canviaria ara pel següent:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class RegistreNotes {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    RegistreNotes programa = new RegistreNotes();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    double[] notes = {2.0, 5.5, 7.25, 3.0, 9.5, 8.25, 7.0, 7.5};</div></li><li class="li1"><div class="de1">    //Per cridar els mètodes cal inicialitzar la classe que els conté</div></li><li class="li1"><div class="de1">    CalculsArrayReals calculador = new CalculsArrayReals();</div></li><li class="li1"><div class="de1">    //Un cop fet, cal cridar-los usant com a prefix l'identificador</div></li><li class="li1"><div class="de1">    double max = calculador.calcularMaxim(notes);</div></li><li class="li1"><div class="de1">    double min = calculador.calcularMinim(notes);</div></li><li class="li1"><div class="de1">    double mitjana = calculador.calcularMitjana(notes);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La nota màxima és &quot; + max + &quot;.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La nota mínima és &quot; + min + &quot;.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La mitjana de les notes és &quot; + mitjana + &quot;.&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h4><a id="reutilitzacio_de_moduls" >Reutilització de mòduls</a></h4>
<div class="level4">

<p>
Com ja s’ha dit, el motiu principal per dividir un programa en mòduls és poder reusar-los en altres programes on cal fer tasques iguals. Per exemple, suposeu que se us demana fer un programa per dur a terme un registre de temperatures. En aquest, es vol mostrar la diferència màxima entre les temperatures enregistrades (quant hi ha entre el valor màxim i el mínim). Analitzant aquest problema, ja podeu veure a primera vista que cal treballar amb un <em>array</em> de valors reals amb els quals fer operacions típiques sobre llistes de valors: calcular el màxim i el mínim. Precisament algunes de les tasques que tot just acabeu de resoldre per gestionar notes. 
</p>

<p>
Fins ara, en un cas com aquest, simplement podríeu agafar el programa en el qual ja s’ha resolt aquest problema i fer “copiar i enganxar” del codi al nou programa. Mitjançant la modularitat, no cal fer això. N’hi ha prou a incorporar la classe on hi ha els mètodes que us interessa usar en el nou programa, i invocar-los directament. Per tant, per a aquest nou programa podríeu incorporar una còpia de la classe <code>CalculsArrayReals</code> i fer la classe principal següent:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class RegistreTemperatures {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    RegistreTemperatures programa = new RegistreTemperatures();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    double[] temps = {20.0, 21.5, 19.0, 18.5, 17.5, 19.0, 22.25, 21.75};</div></li><li class="li1"><div class="de1">    //Per cridar els mètodes cal inicialitzar la classe que els conté</div></li><li class="li1"><div class="de1">    CalculsArrayReals calculador = new CalculsArrayReals();</div></li><li class="li1"><div class="de1">    //Un cop fet, cal cridar-los usant com a prefix l'identificador</div></li><li class="li1"><div class="de1">    double max = calculador.calcularMaxim(temps);</div></li><li class="li1"><div class="de1">    double min = calculador.calcularMinim(temps);</div></li><li class="li1"><div class="de1">    double dif = max - min;</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La diferència de temperatura màxima &quot; + dif + &quot;.&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 1</strong>. Feu un programa que, donats dos <em>arrays</em> de valors reals, us digui quin dels dos té el valor mitjà més alt. Aprofiteu el principi de modularitat per fer-lo, de manera que la seva classe principal només tingui definits els mètodes <code>main</code> i <code>inici</code>.
</p>

</div>

<h3><a id="avantatges_de_la_modularitat_usant_classes_addicionals" >Avantatges de la modularitat usant classes addicionals</a></h3>
<div class="level3">

<p>
Un cop vist que hi ha la possibilitat de crear programes modulars distribuint el seu codi en diferents classes, val la pena plantejar-se quins són els avantatges que aporta. Primer de tot, però, cal dir que aquesta aproximació només sol tenir sentit en programes de certa complexitat, o on hi ha un conjunt extens de mètodes amb funcionalitats genèriques, que clarament poden ser de gran utilitat en la creació de programes futurs. En cas contrari, quan hi ha molts pocs mètodes, no és necessari aplicar-la estrictament.
</p>

<p>
El principal avantatge de la modularitat és poder reutilitzar directament codi ja generat anteriorment en nous programes, sense haver de tornar-lo a escriure o copiar-lo per classes diferents cada cop que es vol utilitzar en diferents programes. Aquest codi sempre estarà a la mateixa classe dins de qualsevol programa, cosa que el fa més fàcil de localitzar i gestionar. D’altra banda, si mai en el futur es fan esmenes a algun dels mètodes d’aquesta classe (per exemple, arreglar un error que s’ha detectat al cap d’un temps), només cal reemplaçar la versió antiga de la classe per la nova. Això es fa simplement mirant si hi ha un fitxer i, si és així, sobreescriure’l. Compareu això amb la feinada que seria cercar els bocins de codi esmenats i reemplaçar-los usant un editor (obrir amb un editor el codi font dels vostres programes, cercar si hi ha els mètodes modificats i sobreescriure’ls amb la nova versió si és el cas).
</p>

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10m3u5_03.png" class="imgB" title=" Les classes són com els mòduls de memòria d&#039;un ordinador. Se&#039;n pot treure una per posar-ne una altra de millorada. Font: Appaloosa/3" alt=" Les classes són com els mòduls de memòria d&#039;un ordinador. Se&#039;n pot treure una per posar-ne una altra de millorada. Font: Appaloosa/3" /></li><li><small> Les classes són com els mòduls de memòria d&#039;un ordinador. Se&#039;n pot treure una per posar-ne una altra de millorada. Font: Appaloosa</small></li>
</ul></div>

</p>

<p>
Un altre avantatge interessant de generar un programa de manera modular és facilitar el treball en equip, una opció indispensable dins del món del desenvolupament de programari actual, on les aplicacions són complexes i calen diferents especialistes que s’han de coordinar. Distribuint el codi en diferents classes, n’hi ha prou a establir l’esquelet de totes elles (la declaració dels mètodes), i llavors es pot repartir la feina de manera que cada desenvolupador faci el codi d’unes poques classes d’entre totes. Tots poden treballar en paral·lel sense problemes, cosa que és molt més complicada si tot està dins el mateix fitxer.
</p>

<p>
Evidentment, la modularitat també té algun inconvenient menor del qual val la pena ser-ne conscient. Donada una classe creada amb anterioritat i que es vol reutilitzar, potser dels diversos mètodes continguts en realitat només en voleu fer servir uns pocs. Per tant, el programa sovint conté classes amb bocins de codi que mai s’usen. En el cas de l’exemple del registre de temperatures, el mètode per calcular la mitjana mai s’usa, però estarà definit igualment en una part del codi font. Ara bé, es considera que els avantatges de la modularitat són tan superiors a aquest inconvenient que és un mal menor sobre el qual no cal pensar-hi gaire si voleu dissenyar els vostres programes.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Els <strong>programes modulars</strong> permeten facilitar la tasca de desenvolupar programari complex, de manera que sigui més fàcil generar i mantenir el codi, especialment quan es treballa en equip.
</p>
</div></div>
</div>

<h2><a id="biblioteques_de_classespackages" >Biblioteques de classes: packages</a></h2>
<div class="level2">

<p>
Normalment, per aplicar el principi de modularitat dins d’un programa n’hi ha prou a organitzar els mètodes dins de classes diferenciades, d’acord a algun criteri d’ordenació o de reutilització en el futur. Ara bé, per a casos on es vol crear un programa amb un cert grau de complexitat, pot succeir que el nombre de classes resultants també sigui força gran. En un cas com aquest, també podria ser convenient disposar d’un mecanisme que permeti organitzar conjunts de classes dins d’un programa, de la mateixa manera que una classe organitza un conjunt de mètodes. Això permet aplicar modularitat a conjunts de classes en bloc, en lloc de fer-ho a nivell individual, i també fer-les més fàcils de localitzar i gestionar.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Una biblioteca de classes, o <strong>package</strong> en Java, és un conjunt de classes vinculades entre elles d’acord a algun criteri temàtic o d’organització del seu codi.
</p>
</div></div>
<p>
Sovint, els criteris per decidir com dividir les classes d’un programa en conjunts de <em>packages</em> diferents són força subjectius. En aquest cas, el que heu de tenir en compte és que es tracta d’una eina de la qual disposeu lliurement per organitzar els diferents fitxers d’un programa al vostre gust, de la mateixa manera que es pot organitzar un conjunt de fotografies referents a diversos viatges de moltes maneres usant una estructura de carpetes.
</p>

<p>
En aquest sentit, cal dir que, si bé la majoria dels exemples amb els quals heu treballat fins ara (i amb els quals es continuarà treballant) són programes amb un nombre de mètodes massa limitat com per justificar de manera clara l’ús de <em>packages</em>, es tracta d’un element prou important de Java com per fer necessari conèixer el seu funcionament.
</p>

</div>

<h3><a id="definicio_de_packages" >Definició de packages</a></h3>
<div class="level3">

<p>
Per assignar un conjunt de classes a un <em>package</em>, primer cal triar un identificador, que servirà com el nom d’aquest. Com sempre, aquest identificador hauria de ser autoexplicatiu respecte a la funció de les classes que contindrà. Un cop triat, per fer que una classe hi pertanyi, n’hi ha prou que a la primera línia del seu fitxer amb el codi font s’escrigui la sentència mostrada tot seguit. La seva aparició ha de ser estrictament sempre a la primera línia de text, fins i tot abans de la declaració de classe (<code>public class…</code>).
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package identificadorPackage;</div></li></ol></pre>

<p>
Cal fer notar, doncs, que el concepte <em>package</em> en Java no té una entitat pròpia diferenciada. Al contrari que les classes, no és cap fitxer concret que cal editar. Serà donat implícitament per totes les classes que es declaren com a part d’ell en el seu codi font.
</p>
<div class="ioctext"><div class="ioccontent"><p class="ioctitle">URL</p>
<p>
Inicials de “Localitzador Uniforme de Recursos” (<em>Uniform Resource Locator</em>, en anglès). És la cadena de caràcters que informa al navegador on us voleu connectar.
</p>
</div></div>
<p>
Com a convenció de codi, l’identificador d’un <em>package</em> hauria de seguir un format especial, de la mateixa manera que hi ha convencions per als noms de les classes, mètodes i variables. El programa no deixa de funcionar si no es fa així, però val la pena seguir aquesta convenció, ja que és el format usat a la immensa majoria de programes en Java. En fer-ho, el vostre codi aporta la imatge d’estar fet per programadors seriosos i acurats. En aquest cas, es tracta que els noms dels <em>packages</em> s’escriuen sempre tots en minúscula i separant paraules diferents per un punt, de manera que tenen un aspecte semblant a l’<acronym title="Uniform Resource Locator">URL</acronym> escrit a la barra d’adreça d’un navegador web. Per exemple:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemple1;</div></li></ol></pre>

<p>
Estrictament, totes les classes del Java pertanyen a algun <strong>package</strong>. En cas de no incloure cap sentència <strong>import</strong>, es considera que aquella classe pertany a un <em>package</em> especial anomenat per defecte (<em>default package</em>). No és possible crear una classe que “no pertanyi a cap <em>package</em>”. Per tant, tots els programes que heu creat fins al moment s’han compost de classes que formaven part del <em>package</em> per defecte, tot i no usar la sentència <strong>import</strong>. 
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Els creadors del llenguatge Java desaconsellen usar el <em>package</em> per defecte.
</p>
</div></div>
<p>
La manera com té el Java d’ordenar les classes dins un programa en <em>packages</em> (inclòs el <em>package</em> per defecte) comporta dues restriccions que heu de tenir sempre en compte:
</p>

<p>
<ul>
<li class="level1"><div class="li"> Donada una classe, aquesta únicament pot pertànyer a un <em>package</em>. No és possible usar més d’una vegada la sentència <strong>package</strong> en el codi font d’una classe.</div>
</li>
</ul>

</p>
<ul>
<li class="level1"><div class="li"> Donat un <em>package</em>, a dintre seu mai hi poden haver dues classes amb el mateix nom. Per norma general, podeu considerar que aquesta regla s’aplica ignorant majúscules i minúscules.</div>
</li>
</ul>
<div class="iocexample"><div class="ioccontent"><p class="ioctitle">Packages i IDE</p>
<p>
Per tal de facilitar la feina del desenvolupador, la majoria d’IDE actuals, en realitat, sí que tracten els <em>packages</em> com una entitat especial dins dels seus projectes. Així, doncs, abans de poder crear cap classe continguda dins d’un <em>package</em>, és necessari crear-lo explícitament de manera individual. Un cop fet, és possible afegir-hi classes, de manera semblant a com es gestionarien fitxers dins d’una carpeta. Quan es crea una nova classe dins de cada <em>package</em>, l’IDE ja s’encarrega d’incloure automàticament la sentència <strong>import</strong> a l’inici del codi font. Addicionalment, mentre no es crei cap <em>package</em> amb un nom concret, també solen mostrar explícitament el <em>package</em> per defecte, on hi van incloent les noves classes que creeu.
</p>

<p>
Tingueu en compte, però, que aquesta característica només és un mecanisme de la interfície d’usuari dels IDE per fer la seva gestió més senzilla.
</p>
</div></div>
<p>
<strong>Repte 2</strong>. Genereu un projecte en el vostre IDE amb un <em>package</em> anomenat <code>unitat5.apartat1.repte2</code>. Feu que dins d’aquest <em>package</em> s’incloguin les classes de l’exemple del registre de les notes i executeu-lo, comprovant que funciona correctament.
</p>

</div>

<h3><a id="criteris_per_crear_biblioteques_de_classes" >Criteris per crear biblioteques de classes</a></h3>
<div class="level3">

<p>
Normalment, els criteris usats per dividir conjunts de classes en biblioteques diferents solen ser:
</p>
<ul>
<li class="level1"><div class="li"> Un programa complet, una jerarquia de <em>packages</em>.</div>
</li>
<li class="level1"><div class="li"> Molts programes petits, una jerarquia de <em>packages</em>.</div>
</li>
<li class="level1"><div class="li"> Un conjunt de classes sense un programa principal, un <em>package</em>.</div>
</li>
</ul>

<p>
Com que l’ús de biblioteques no és més que un mecanisme per ordenar les classes d’un programa, inicialment es pot fer una analogia amb l’ordenació d’un conjunt de fotografies de diferents viatges dins de carpetes. Cada viatge equival a un programa diferent en aquesta analogia.
</p>
<ol>
<li class="level1"><div class="li"> Un programa complet, una jerarquia de packages.<br/>
Inicialment, podríeu tenir una carpeta per a cada viatge, en cadascuna de les quals hi ha totes les fotos associades directament. Això seria equivalent a usar cada biblioteca per encapsular un programa complet, compost per la seva classe principal i un seguit de classes addicionals. Així, doncs, s’assignaria el mateix identificador a totes les classes que conformen el programa. Sota aquest criteri, les classes dels exemples, en ser programes diferents, podrien anar dins dels diferents <em>packages</em> <code>unitat5.apartat1.exemple1</code>, <code>unitat5.apartat1.repte1</code>, etc.<br/>
Partint d’aquest criteri, però, podríeu considerar posar algunes de les les fotos d’un viatge, a la seva vegada, en carpetes segons el dia, o el monument visitat, de manera que hi ha una carpeta amb fotos “generals” i algunes subcarpetes que agrupen visites concretes. De fet, aquest és el cas més típic quan s’usen biblioteques en Java per encapsular aplicacions. Hi ha una biblioteca on es desa la classe principal i després d’altres on s’agrupen les classes addicionals per tipus de funció. En aquest cas, el que es fa és estendre l’identificador base amb noms que indiquin el tipus de classes addicionals.<br/>
Tingueu en compte que tots aquests <em>packages</em> són diferents a nivell d’estructura del programa. Però el nom se sol triar estratègicament perquè a partir d’ell es dedueixi ja a simple vista que hi ha una relació jeràrquica entre les classes. Les classes del nivell més alt de la jerarquia fan ús de les de nivells més baixos.\Més endavant, si l’aplicació fa altres accions d’altres temàtiques, es podrien afegir un nou <em>package</em>. Per exemple, per tractar la lectura de dades pel teclat es podria generar el <em>package</em> <strong>unitat5.apartat1.exemple1.entrada</strong>, en el qual anirien les classes vinculades a l’entrada de dades.<br/>
Per exemple, en el cas de l’exemple mostrat, podríem tenir dos <em>packages</em>:</div>
<ul>
<li class="level2"><div class="li"> <code>unitat5.apartat1.exemple1</code>, que engloba la classe principal.</div>
</li>
<li class="level2"><div class="li"> <code>unitat5.apartat1.exemple1.arrays</code>, que engloba totes les classes per tractar les dades. Ara mateix només contindria <code>CalculsArrayReals</code>, però més endavant podria incloure altres classes per extreure informació addicional de les dades del programa (predir temperatures en el futur, fer histogrames o gràfics, etc.)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Molts programes petits, una jerarquia de packages<br/>
Una altra opció possible és englobar més d’un programa en un únic <em>package</em>. Això se sol fer quan es vol gestionar fàcilment un conjunt de programes molt simples, normalment d’una sola classe, que sovint usen les mateixes classes addicionals. Seguint l’analogia, si heu fet diversos viatges molt breus, o de passada, a una mateixa ciutat, de manera que de cada viatge només teniu 3 o 4 fotos, no val la pena diferenciar-los, surt més a compte posar-les totes barrejades a la mateixa carpeta, anomenada d’acord a la ciutat.<br/>
L’objectiu principal és evitar l’explosió en el nombre de <em>packages</em>, que al final acaben tenint una o dues classes. Ara bé, això té una particularitat, i és que dins un mateix <em>package</em> hi ha més d’una classe principal barrejada. De fet, un <em>package</em> no té cap límit en el nombre de classes principals que pot contenir. N’hi ha prou que, dins el vostre entorn de desenvolupament, trieu de manera adient quina és la que voleu que s’executi d’entre totes les existents. Java s’encarrega de la resta.<br/>
Si us pareu a pensar un moment, aquest és el cas precisament de la majora d’exemples o reptes proposats, en ser programes amb molts pocs fitxers i que sovint compartiran algunes classes addicionals, per la qual cosa és el que s’usarà a partir d’ara. Per exemple, organitzant les classes segons els <em>packages</em> anomenats <code>unitat5.apartat1.exemples</code> i <code>unitat5.apartat1.reptes</code>.</div>
</li>
<li class="level1"><div class="li"> Un conjunt de classes sense programa principal, un package<br/>
Finalment, poden haver-hi classes que es consideren de propòsit general, útils en molts programes diferents. Això pot succeir si voleu deixar la porta oberta a reutilitzar classes que esteu implementant en un altre programa nou, més endavant. O sigui, fotografies que apliquen a més d’un viatge. Normalment, el que faríeu es crear una carpeta a part i posar-les-hi, en lloc de tenir-les en la d’un viatge concret. En un cas com aquest, la introducció del concepte de biblioteca de classes planteja una nova possibilitat a l’hora de crear codi. Concretament, el cas invers de l’anterior, el desenvolupament de repertoris de classes que no conformen pròpiament un programa, ja que cap d’elles és la principal.<br/>
En l’exemple vist, aquest és el cas de la classe <code>CalculsArrayReals</code>. En un cas com aquest, les classes de propòsit general se solen crear en una biblioteca a part.  De ben segur que un seguit de classes per fer operacions amb <em>arrays</em> s’usaran més enllà de la unitat 5. Per tant, no té sentit definir-les en un <em>package</em> anomenat <code>unitat5.apartat1.exemples.arrays</code>, sinó usant un nom que no estigui associat a aquesta jerarquia. En aquest cas, per exemple, podria ser el <em>package</em> <code>utilitats.arrays</code>. <br/>
Encara més, es pot plantejar el desenvolupament d’un conjunt de classes en una biblioteca que no siguin producte parcial de la generació d’un programa, que posteriorment han resultat ser reutilitzades, sinó que ja des del punt de partida s’han creat com eines de suport per a programes futurs. Per tant, no és inconvenient tenir <em>packages</em> sense cap classe principal (de fet, és el cas més habitual). Un cop s’identifica que un conjunt de classes s’usa en molts programes diferents, el millor és fer que formin part de la seva pròpia biblioteca independent, fora de la jerarquia del nom de cap aplicació concreta.<br/>
La <span class="figref"><a href="#Figure2"><span>figura</span></a></span> mostra un esquema que contrasta aquest criteri per tal de gestionar classes addicionals amb el de crear una relació jeràrquica entre el <em>package</em> amb la classe principal.<br/>
En darrera instància, però, heu de tenir en compte que no hi ha una resposta totalment correcta a l’hora d’englobar classes dins de biblioteques. Només s’han enumerat uns criteris que se solen usar dins els programes professionals realitzats en Java. Però, en el fons, els <em>packages</em> només són una eina per organitzar les classes de manera coherent perquè us resulti més còmoda a vosaltres.</div>
</li>
</ol>
<div class="iocfigure"><a name="Figure2"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Criteris d’estructuració de programes en biblioteques

</figcaption><img src="../media/ic10m3u5_04.png" alt="" /></figure>
</div>
</div>

<h3><a id="us_de_classes_d_altres_packages" >Ús de classes d&#039;altres packages</a></h3>
<div class="level3">

<p>
Per referir-nos a una classe simplement s’havia de dir el seu nom (o el nom del seu fitxer). Atès que tota classe sempre pertany a una biblioteca, i dins de biblioteques diferents hi poden haver classes amb igual nom, pot ser interessant disposar d’una eina per dir exactament de quina classe s’està parlant en cada cas.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Després d’una certa experiència amb Java al final és evident quina mena d’operacions típiques s’acaben repetint en tots els programes.
</p>
</div></div><div class="iocimportant"><div class="ioccontent">
<p>
El <strong>nom qualificat d’una classe</strong> és la combinació de l’identificador del seu <em>package</em> junt amb el seu nom, separats per un punt.
</p>
</div></div>
<p>
Exemples de noms qualificats, partint dels exemples anteriors, serien <code>unitat5.apartat1.exemples.RegistreNotes</code> o <code>utilitats.arrays.CalculsArrays</code>. Amb un nom qualificat queda totalment clar a quin <em>package</em> pertany la classe a la qual us esteu referint en un moment donat, independentment del context.
</p>

<p>
El nom qualificat de les classes és útil ja que des del codi d’una classe que pertany a un <em>package</em> concret, només es poden usar directament classes amb què comparteixi el mateix nom de <em>package</em>. Si s’usa una classe d’un de diferent, el compilador donarà un error, dient que no la reconeix. Això passaria si, en organitzar les classes <code>RegistreNotes</code> i <code>CalculsArrayReals</code> en biblioteques diferents, des de la primera s’intenta usar directament la segona. Ja no funciona. Cal establir algun mecanisme per indicar exactament quina classe s’està usant. Java ofereix tres maneres, més o menys relacionades.
</p>

<p>
<strong>1. Inicialització usant el nom qualificat</strong>
</p>

<p>
D’una banda, per al cas de classes d’altres <em>packages</em>, es pot usar el seu nom qualificat dins del codi font per referir-se a la seva inicialització. 
</p>

<p>

</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">public class RegistreNotes {</div></li><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">  //Ús del nom qualificat per accedir a una classe d'un altre package</div></li><li class="li1"><div class="de1">  utilitats.arrays.CalculsArrayReals calculador = new utilitats.arrays.CalculsArrayReals();</div></li><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>
<pre class="code java"><ol><li class="li1"><div class="de1">package utilitats.arrays;</div></li><li class="li1"><div class="de1">public class CalculsArrayReals {</div></li><li class="li1"><div class="de1">  //Codi</div></li><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>2. Importació explícita</strong>
</p>

<p>
Una altra manera, molt més còmoda si una classe s’usa diverses vegades dins el codi, és <strong>importar-la</strong> prèviament a la capçalera del fitxer de codi font, entre la declaració del <em>package</em> i la declaració <code>public class…</code>. Per fer aquesta importació, cal especificar el nom qualificat de la classe que es vol usar. La sintaxi general és:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import nomQualificat;</div></li></ol></pre>

<p>
En cas de voler usar més d’una classe, ja sigui de la mateixa biblioteca o de diferents, caldrà posar tantes sentències <strong>import</strong> com correspongui. Per exemple, si useu cinc classes que no pertanyen al mateix <em>package</em> que la classe que esteu creant, caldrà incloure cinc sentències <strong>import</strong> per separat. En aquest procés, les relacions de jerarquia entre els identificadors del <em>package</em> no importen, cal posar cada classe amb el seu <em>package</em> explícitament, una per una.
</p>

<p>
Seguint l’exemple anterior de divisió de les classes <code>CalculsArrayReals</code> i <code>RegistreNotes</code> en <em>packages</em> diferents, per poder usar la primera classe a la segona d’aquesta manera, caldria fer-ho així:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">//Cal importar la classe &quot;CalculsArrayReals&quot;, ja que és d'un altre package</div></li><li class="li1"><div class="de1">import utilitats.arrays.CalculsArrayReals;</div></li><li class="li1"><div class="de1">public class RegistreNotes {</div></li><li class="li1"><div class="de1">  //Codi</div></li><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>
<pre class="code java"><ol><li class="li1"><div class="de1">package utilitats.arrays;</div></li><li class="li1"><div class="de1">//No s'usa cap classe fora d'aquest package, no s'importa res</div></li><li class="li1"><div class="de1">public class CalculsArrayReals {</div></li><li class="li1"><div class="de1">  //Codi</div></li><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>3. Importació general</strong>
</p>

<p>
Finalment, hi ha un tercer mecanisme que permet importar automàticament totes les classes dins una biblioteca. Aquest es fa servir sovint quan es volen usar moltes classes del mateix <em>package</em> i importar-les una a una es fa pesat. Es tracta d’usar un asterisc, “*”, en lloc del nom de la classe en el nom qualificat. Aquest fa de comodí i equival a dir “absolutament totes les classes del <em>package</em>”.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">//S'importarien totes les classes del package utilitats.arrays</div></li><li class="li1"><div class="de1">import utilitats.arrays.*;</div></li><li class="li1"><div class="de1">public class RegistreNotes {</div></li><li class="li1"><div class="de1">  //Codi</div></li><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>
<div class="iocimportant"><div class="ioccontent">
<p>
Per norma general, és aconsellable usar la importació explícita, ja que així a l’inici del vostre codi font sempre disposareu d’una llista detallada de quines classes d’altres biblioteques esteu usant.
</p>
</div></div>
<p>
<strong>Repte 3</strong>. Modifiqueu l’exemple del registre de temperatures de manera que la classe <code>RegistreTemperatures</code> pertanyi al <em>package</em> <code>unitat5.apartat1.repte3</code> i la classe <code>CalculsArrayReals</code> al <em>package</em> <code>utilitats.arrays</code>. Assegureu-vos que el programa s’executa correctament.
</p>

</div>

<h3><a id="estructura_dels_fitxers_dins_dels_packages" >Estructura dels fitxers dins dels packages</a></h3>
<div class="level3">

<p>
L’identificador triat com a nom d’un <em>package</em> a Java indica de quina manera s’organitzen les classes contingudes dins el sistema de fitxers del vostre ordinador. Partint de la carpeta considerada de treball, totes les classes que formen part del <em>package</em> han d’estar ubicades dins d’una jerarquia de carpetes on cada carpeta té el nom de cadascun dels textos separats per punts que conformen el nom complet del <em>package</em>. A la darrera carpeta és on estaran ubicats realment els fitxers <code>.java</code>. 
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Cada IDE desa les classes en una carpeta considerada “de treball” diferent, però sempre estarà dins del projecte creat. Sovint s’anomena “src”.
</p>
</div></div><div class="iocfigure"><a name="Figure3"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Desplegament de classes en carpetes d’acord al nom del package.

</figcaption><img src="../media/ic10m3u5_05.png" alt="" /></figure>
</div>
<p>
Organitzar les classes en aquesta estructura de carpetes segons el seu <em>package</em> serveix per garantir dues coses importants. D’una banda, que les classes de diferents <em>packages</em> estan endreçades en carpetes diferents, fàcilment identificables, de manera que no es barregen totes. D’altra banda, també permet que dins de dos <em>packages</em> diferents hi pugui haver classes amb el mateix nom sense que impliqui cap col·lisió en el sistema de fitxers (que els fitxers <code>.java</code> se sobreescriguin).
</p>

<p>
Si se segueix amb l’exemple de les classes vinculades al registre de notes, partint de criteri de fer que <code>CalculsArrayReals</code> pertanyi a una biblioteca comuna, les classes estarien distribuïdes de la manera que mostra la <span class="figref"><a href="#Figure3"><span>figura</span></a></span>.
</p>

<p>
Si en un moment donat es volen usar les classes del <em>package</em> <code>utilitats.arrays</code> en un altre programa, no n’hi ha prou a copiar simplement els fitxers .java al directori de la nova aplicació. Cal que aquestes es copiïn mantenint la seva estructura de carpetes. Per tant, caldria copiar l’estructura existent partint de la carpeta <strong>utilitats</strong>.
</p>
<div class="iocexample"><div class="ioccontent"><p class="ioctitle">Packages i IDE (II)</p>
<p>
Els IDE actuals també s’encarreguen de gestionar l’organització de l’estructura de directoris d’acord al nom dels <em>packages</em> de manera automàtica, un cop se n’ha creat un explícitament i s’hi van afegint classes. Per tant, si n’useu un, no us heu de preocupar d’aquest fet. De totes maneres, aneu molt en compte si copieu classes entre projectes, ja que cal seguir les regles tot just explicades.
</p>
</div></div>
</div>

<h2><a id="l_api_del_llenguatge_java" >L&#039;API del llenguatge Java</a></h2>
<div class="level2">

<p>
Per realitzar programes modulars no sempre és necessari crear tots i cadascun dels mòduls que formen part del programa. Per sort, sovint els llenguatges de programació incorporen biblioteques de mòduls auxiliars que ja han estat completament desenvolupats pels creadors del llenguatge o altres col·laboradors. Aquests mòduls auxiliars estenen el llenguatge de programació, oferint funcionalitats que van més enllà del que permet la seva sintaxi estrictament o incorporant l’opció d’executar blocs de codi que resolen tasques que es consideren de propòsit general i que poden ser d’utilitat en una àmplia gamma de programes.
</p>

<p>
En el cas del llenguatge Java, el seu <em>kit</em> de desenvolupament (JDK) incorpora un quantiós repositori de classes, organitzades per diferents <em>packages</em> d’acord a la seva temàtica, que poden ser accedides lliurement en realitzar qualsevol programa. Aquest repositori és el que s’anomena l’<strong><acronym title="Application Programming Interface">API</acronym></strong> de Java. Ara bé, l’objectiu d’aquesta secció no és conèixer totes les classes disponibles, sinó simplement que tingueu un marc general sobre com cal usar-ne una que sigui senzilla, un cop ja us és coneguda la seva existència i que pot ser útil per fer un programa.
</p>
<div class="iocreference"><div class="ioccontent">
<p>
Per a la versió 1.6, el llistat de totes les classes del Java, junt amb la seva documentació, la podeu trobar a l’adreça d’Oracle de les Adreces d’interès del web.
</p>
</div></div>
<p>
Si observeu la documentació de l’<acronym title="Application Programming Interface">API</acronym> de Java, de la qual la <span class="figref"><a href="#Figure4"><span>figura</span></a></span> mostra una idea de la seva estructura, veureu que ofereix un enorme repertori de classes que contenen mètodes amb funcionalitats molt diverses, cosa que, de vegades, fa ben complicat trobar d’entre totes la classe que conté els mètodes ideals per a cada cas, si és que existeix. De fet, podeu considerar que intentar esbrinar si hi ha una classe que conté mètodes que us puguin resultar útils als vostres programes a partir d’aquesta documentació és inviable. La documentació es va crear partint del supòsit que ja sabeu el nom de la classe que voleu utilitzar. Per tant, l’aproximació correcta per usar-la és cercar quina classe pot ser la que realitza les tasques que voleu dur a terme, a partir d’una font bibliogràfica externa o d’una cerca a internet, i llavors referir-se a l’<acronym title="Application Programming Interface">API</acronym> només per estudiar amb més detall quins mètodes ofereix.
</p>
<div class="iocfigure"><a name="Figure4"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

L’<acronym title="Application Programming Interface">API</acronym> de Java es compon realment d’una gran quantitat de classes

</figcaption><img src="../media/ic10m3u5_06.png" alt="" /></figure>
</div>
<p>
Com a exemple, entre els <em>packages</em> que contenen les classes més populars, podeu trobar:
</p>
<ul>
<li class="level1"><div class="li"> <code>java.lang</code>: conté totes les classes vinculades a operacions essencials dels tipus de dades del llenguatge.</div>
</li>
<li class="level1"><div class="li"> <code>java.util</code>: una mena de calaix de sastre amb classes de propòsit general.</div>
</li>
<li class="level1"><div class="li"> <code>java.io</code>: conté totes les classes vinculades a entrada / sortida (tractament de fitxers).</div>
</li>
<li class="level1"><div class="li"> <code>javax.swing</code>: conté les classes bàsiques vinculades a la creació d’interfícies gràfiques.</div>
</li>
</ul>

<p>
L’avantatge d’aquesta aproximació és que, com que aquestes classes ja estan creades i incorporades com a part del llenguatge, si en trobeu una que ja faci la feina requerida, us estalviareu haver d’escriure parts de codi font del programa. 
</p>

</div>

<h3><a id="us_de_classes_dins_les_biblioteques_de_java" >Ús de classes dins les biblioteques de Java</a></h3>
<div class="level3">

<p>
Per poder usar qualsevol classe d’entre les definides a l’<acronym title="Application Programming Interface">API</acronym> de Java cal seguir exactament les mateixes passes que per a una classe realitzada per vosaltres, però dins un <em>package</em> diferent: importar-la a l’inici del codi font i inicialitzar-la. Un cop fet, la sintaxi per invocar els seus mètodes és exactament la mateixa. Aquest procés només té una particularitat molt especial, i és que no cal disposar del codi font de la classe en qüestió. En estar incorporada dins el JDK, Java ja sap localitzar el seu codi automàticament sense haver-lo d’incorporar vosaltres explícitament.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
L’única excepció són les classes del <em>package</em> anomenat <code>java.lang</code>, que es poden usar sense haver d’importar-les.
</p>
</div></div>
<p>
Per repassar aquest procés, s’usarà com a exemple senzill partint des de zero. Suposeu que heu de fer un programa que ha de generar dos valors reals a l’atzar, entre 0 i 100, i que els mostri per pantalla. D’entrada, resoldre aquest problema suposaria haver de crear dins del codi font algun mètode que generés aquests valors reals aleatoris. Per sort, investigant una mica fonts de documentació, no és complicat trobar que existeix una classe anomenada <strong>Random</strong>, ja incorporada a l’<acronym title="Application Programming Interface">API</acronym> de Java, la qual permet fer aquest tipus de tasques. Per tant, estudiant com usar els seus mètodes us podeu estalviar feina de codificació. Cercant-la a la documentació de l’<acronym title="Application Programming Interface">API</acronym> de Java, es veu que forma part del <em>package</em> <code>java.util</code>.
</p>

<p>
Sense encara saber els detalls d’aquesta classe, es pot fer l’esquelet de la classe principal del programa, amb la corresponent importació. Aneu amb compte amb el fet que aquest exemple inclou la classe dins un <em>package</em>.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">//Importació de la classe, en estar en un altre package</div></li><li class="li1"><div class="de1">import java.util.Random;</div></li><li class="li1"><div class="de1">public class RealsAleatoris {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    RealsAleatoris programa = new RealsAleatoris();     </div></li><li class="li1"><div class="de1">    programa.inici();  </div></li><li class="li1"><div class="de1">  }    </div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    //Cal generar un valor a l'atzar</div></li><li class="li1"><div class="de1">    //Cal generar-ne l'altre</div></li><li class="li1"><div class="de1">    //Mostrar-los  </div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
El vostre programa només cal que es compongui d’aquesta classe. En formar part de l’<acronym title="Application Programming Interface">API</acronym> de Java, l’ús de la classe <strong>Random</strong> no implica la incorporació de cap altre fitxer de codi font. Un cop ja està tot llest per usar-la, caldrà mirar quins mètodes ofereix per generar reals a l’aztar. Per això cal consultar la documentació, com mostra la <span class="figref"><a href="#Figure5"><span>figura</span></a></span>. Dins l’apartat de resum de mètodes (<em>Method Summary</em>) hi ha una llista dels mètodes amb una descripció general. D’entre tots, se’n pot trobar un que sembla generar valors reals a l’atzar, anomenat <code>nextDouble()</code>. Si es vol veure amb més concreció què fa el mètode, la documentació proporciona una descripció més detallada (<em>Method Detail</em>), en què sempre val la pena fer una ullada. De la informació obtinguda, però, es pot veure que en realitat aquest mètode genera valors a l’atzar entre 0.0 i 1.0. Per tant, si es volen crear valors entre 0 i 100, no fa tota la feina. Caldrà fer una multiplicació del seu resultat per 100. No sempre trobareu mètodes que fan exactament el que voleu, però n’hi ha prou que us estalviïn les feines més complicades.
</p>
<div class="iocfigure"><a name="Figure5"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Estudiant els mètodes oferts per una classe

</figcaption><img src="../media/ic10m3u5_07.png" alt="" /></figure>
</div>
<p>
El codi per generar dos valors reals a l’atzar quedaria com mostra el codi següent. A nivell de sintaxi, tot és igual que si fos una classe addicional generada per vosaltres mateixos. Comproveu que, efectivament, per a diferents execucions els valors mostrats per pantalla varien a l’atzar.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  ...  </div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    //Inicialització</div></li><li class="li1"><div class="de1">    Random rnd = new Random();</div></li><li class="li1"><div class="de1">    //Ús</div></li><li class="li1"><div class="de1">    double valorA = rnd.nextDouble() * 100;</div></li><li class="li1"><div class="de1">    double valorB = rnd.nextDouble() * 100;</div></li><li class="li1"><div class="de1">    System.out.println(&quot;S'han generat els valors &quot; + valorA  + &quot; i &quot; + valorB);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  ...</div></li></ol></pre>

<p>
Si feu una mica de memòria, veureu que el procés tot just descrit ja l’heu usat anteriorment en diverses ocasions: cada cop que us calia llegir dades pel teclat i heu usat <code>Scanner</code>. Si mireu la documentació de l’<acronym title="Application Programming Interface">API</acronym> de Java, trobareu aquesta classe dins el mateix <em>package</em> <code>java.util</code>. De fet, <code>String</code> també és una classe incorporada dins de l’<acronym title="Application Programming Interface">API</acronym> de Java, només que en formar part del <em>package</em> <code>java.lang</code>, és un cas especial i no cal importar-la explícitament.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Una de les característiques essencials de Java és la seva modularitat inherent.
</p>
</div></div>
<p>
Així, doncs, tot i que no n’heu estat conscients, molts dels vostres programes fets fins ara ja eren, en certa manera, modulars!
</p>

</div>

<h3><a id="inicialitzacio_amb_parametres" >Inicialització amb paràmetres</a></h3>
<div class="level3">

<p>
Algunes classes de Java tenen una particularitat, i és que a l’hora d’inicialitzar-les cal especificar un conjunt d’informació addicional en forma de paràmetres. Aquest cas es tractarà aquí només de manera superficial i a nivell d’ús dins del context de les classes ofertes dins l’<acronym title="Application Programming Interface">API</acronym> de Java, ja que és força habitual, però no a nivell de com poder fer que les classes generades per vosaltres siguin capaces d’acceptar-ne, ja que és més complex. L’objectiu només és que disposeu del rerefons bàsic per poder treballar amb algunes de les classes més senzilles de l’<acronym title="Application Programming Interface">API</acronym>.
</p>

<p>
Fins al moment, s’ha dit que per inicialitzar una classe per tal de poder invocar els mètodes que ofereix calia fer:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">NomClasse identificador = new NomClasse();</div></li></ol></pre>

<p>
Però hi ha casos en què, per inicialitzar correctament la classe, cal afegir un conjunt de valors entre els parèntesis, de manera idèntica a com es faria en invocar un mètode. Si no es posen aquests paràmetres quan pertoca, hi haurà un error de compilació. 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">NomClasse identificador = new NomClasse(paràmtres);</div></li></ol></pre>

<p>
De fet, sense dir-ho explícitament ja heu treballat anteriorment amb un cas com aquest, ja que és tot just el que passa amb la classe <strong>Scanner</strong>. Per inicialitzar-la correctament li cal un paràmetre indicant quin sistema d’entrada ha de processar. 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">Scanner lector = new Scanner(System.in);</div></li></ol></pre>

<p>
Per veure si cal o no incloure un paràmetre en inicialitzar una classe, caldrà cercar-lo a la seva documentació. Concretament, a l’apartat anomenat resum de constructors (<em>Constructor Summary</em>) indica la sintaxi de la part dreta de la inicialització. El nom d’aquest apartat es deu al fet que, formalment, quan s’inicialitza una classe es diu que s’invoca un dels seus <strong>constructors</strong>. Es pot triar qualsevol de les opcions ofertes a la llista de constructors, però segons quina s’esculli, la classe es pot comportar d’una manera diferent.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
En Java, el text <code>System.in</code> identifica l’entrada estàndard, la qual per defecte és el teclat.
</p>
</div></div>
<p>
La <span class="figref"><a href="#Figure6"><span>figura</span></a></span> mostra aquest apartat per a la classe <code>Random</code>. En aquest cas, es pot veure que hi ha dues maneres diferents d’inicialitzar la classe abans de cridar els seus mètodes. Es pot fer com sempre, sense paràmetres, <code>Random()</code>, o bé usant un valor de tipus <code>long</code> com a paràmetre, <code>Random(long seed)</code>.
</p>
<div class="iocfigure"><a name="Figure6"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Constructors de la classe Random

</figcaption><img src="../media/ic10m3u5_08.png" alt="" /></figure>
</div>
<p>
<strong>Repte 4</strong>. Modifiqueu el programa anterior per mostrar per pantalla dos valors reals aleatoris de manera que la classe <code>Random</code> s’inicialitzi amb un paràmetre de tipus <code>long</code>. Aquest nou programa hauria de formar part d’un <em>package</em> anomenat <code>unitat5.apartat1.reptes</code>. Executeu-lo diverses vegades. Quina és la diferència entre usar un constructor o un altre en inicialitzar la classe?
</p>

</div>

<h2><a id="metodes_estatics" >Mètodes estàtics</a></h2>
<div class="level2">

<p>
Per norma general, per poder invocar mètodes d’una classe cal inicialitzar-la prèviament. Ara bé, d’entre tots els mètodes proporcionats dins de les classes disponibles a l’<acronym title="Application Programming Interface">API</acronym> de Java, hi ha un petit subconjunt amb una peculiaritat. 
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Els mètodes <strong>estàtics</strong> poden ser invocats sense haver d’inicialitzar la seva classe. S’identifiquen perquè a la documentació apareixen marcats amb la paraula clau <strong>static</strong>.
</p>
</div></div>
<p>
Novament, aquesta secció se centra en l’ús dins del context de l’<acronym title="Application Programming Interface">API</acronym> de Java, i no pas en com generar-ne a les vostres classes o quina és la seva justificació dins de Java. Si bé l’explicació és genèrica, se centrarà en les dues classes més importants basades en aquests tipus de mètode, les quals us poden ser de gran ajut per fer els vostres programes: <code>java.lang.Math</code> i <code>java.util.Arrays</code>. Si mireu la documentació d’aquestes dues classes, veureu que gairebé tots els seus mètodes són estàtics. A la <span class="figref"><a href="#Figure7"><span>figura</span></a></span> podeu veure un detall d’alguns dels mètodes de la classe <strong>Math</strong>. Fixeu-vos com estan identificats amb la paraula <strong>static</strong> a l’inici de la seva declaració.
</p>
<div class="iocfigure"><a name="Figure7"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Mètodes estàtics de la classe Math

</figcaption><img src="../media/ic10m3u5_09.png" alt="" /></figure>
</div>
<p>
Per invocar aquests mètodes, la sintaxi correcta és posar com a prefix el nom de la classe directament, en lloc de l’identificador fruit de la inicialització. A part d’això, el seu comportament és idèntic a qualsevol altre mètode (com una expressió que avalua a un resultat).
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">NomClasse.nomMetode(paràmetres);</div></li></ol></pre>

<p>
Per exemple, donat el mètode estàtic <code>sqrt</code> definit a la classe <code>Math</code>, el qual accepta un únic paràmetre d’entrada de tipus real, per invocar-lo i desar el resultat en una variable només caldria el codi que es mostra tot seguit. En aquest cas, es calcula l’arrel quadrada de 36. 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">double resultat = Math.sqrt(36);</div></li></ol></pre>

<p>
Fixeu-vos com no cal cap inicialització prèvia i, per invocar-los, s’usa abans de l’identificador del mètode el nom de la classe, i no pas d’una variable.
</p>

</div>

<h3><a id="la_classe_math" >La classe Math</a></h3>
<div class="level3">

<p>
Aquesta classe pertany al <em>package</em> <code>java.lang</code>, i per tant pot ser usada sense haver d’importar-la. Ofereix un ventall de mètodes estàtics per realitzar operacions matemàtiques avançades, que no es poden dur a terme amb cap dels operadors aritmètics de què disposa Java (suma, resta, multipliació, divisió i mòdul).
</p>

<p>
Tot seguit es mostren alguns dels mètodes més rellevants, associats a operacions matemàtiques relativament comunes i simples.
</p>

</div>

<h4><a id="arrodoniment" >Arrodoniment</a></h4>
<div class="level4">

<p>
Un mètode interessant és el que permet arrodonir valors reals.
</p>

<p>
<code>round(valor)</code>, només té com a paràmetre d’entrada un valor real (ja sigui de tipus <code>float</code> o <code>double</code>) i avalua sempre un enter (<code>int</code>). L’arrodonimet es fa a l’alça o a la baixa depenent de si la seva part decimal és superior o igual a 0.5, o menor, respectivament. 
</p>

<p>
Per exemple, suposeu que voleu fer un programa que, donat un valor real a l’atzar entre 0 i 1, mostri el seu arrodoniment (a l’alta o a la baixa, segons si el valor decimal és menor o superior a 0.5). El codi d’aquest programa seria el que es mostra tot seguit. En aquest exemple, fixeu-vos en la diferència en el codi pel que fa a la manera com es crida en els mètodes de les classes <code>Random</code> i <code>Math</code>.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">import java.util.Random;</div></li><li class="li1"><div class="de1">public class ArrodonirReal {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    ArrodonirReal programa = new ArrodonirReal();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    //Inicialització de Random</div></li><li class="li1"><div class="de1">    Random rnd = new Random();</div></li><li class="li1"><div class="de1">    //Ús per generar un real entre 0 i 1</div></li><li class="li1"><div class="de1">    double valor = rnd.nextDouble();</div></li><li class="li1"><div class="de1">    System.out.println(&quot;El valor real generat és &quot; + valor);</div></li><li class="li1"><div class="de1">    //Ús del mètode estàtic. No cal inicialitzar res, es pot usar directament.</div></li><li class="li1"><div class="de1">    //No cal importar-la, ja que pertany a java.lang</div></li><li class="li1"><div class="de1">    long arrodonit = Math.round(valor);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;El valor arrodonit és &quot; + arrodonit);</div></li><li class="li1"><div class="de1">  }    </div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h4><a id="elevar_a_exponent_i_arrel_quadrada" >Elevar a exponent i arrel quadrada</a></h4>
<div class="level4">

<p>
Tot i que d’altres llenguatges sí que disposen d’operador aritmètic per elevar a un exponent (<span class="inlinelatex"><img src="../media/imge094d63b4fd5d820a67fefb548e216f5.png" /></span>), a Java no n’hi ha. Per això, la classe <strong>Math</strong> ofereix el mètode estàtic per poder dur a terme aquesta operació.
</p>

<p>
<code>pow(base, exponent)</code> accepta dos paràmetres, que només poden ser de tipus <code>double</code>, de manera que la seva invocació avalua el primer elevat al segon (<span class="inlinelatex"><img src="../media/imgbb3da853cd37d6ffbf233871b0b165c3.png" /></span>).
</p>

<p>
Junt amb aquest mètode, també es disposa del contrari, en aquest cas només per al càlcul de l’arrel quadrada.
</p>

<p>
<code>sqrt(valor)</code> només té un paràmetre, que només pot ser un real de tipus <code>double</code>, el qual avalua el valor real resultant de fer el càlcul de l’arrel quadrada de <code>valor</code>. Cal anar amb molt de compte de no invocar mai aquest mètode amb un paràmetre d’entrada negatiu, ja que el resultat serà sempre incorrecte.
</p>

<p>
Tot just es mostra un exemple del seu ús, on s’aplica el teorema de Pitàgores per calcular la hipotenusa d’un triangle:
</p>
<div class="iocnote"><div class="ioccontent">
<p>
La paraula <code>sqrt</code> abreuja <em>square root</em>, “arrel quadrada” en anglès.
</p>
</div></div><pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">public class Pitagores {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    Pitagores programa = new Pitagores();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    double base = 4.5;</div></li><li class="li1"><div class="de1">    double altura = 10;</div></li><li class="li1"><div class="de1">    //S'eleva al quadrat cada costat del triangle</div></li><li class="li1"><div class="de1">    double sumaQuadrats = Math.pow(base,2) + Math.pow(altura, 2);</div></li><li class="li1"><div class="de1">    double hipotenusa = Math.sqrt(sumaQuadrats);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;El valor de la hipotenusa és &quot; + hipotenusa);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h4><a id="maxim_i_minim" >Màxim i mínim</a></h4>
<div class="level4">

<p>
Per acabar aquest petit mostrari, és possible calcular ràpidament el màxim o el mínim entre dos valors numèrics usant la classe <strong>Math</strong>, ja que també ofereix mètodes per fer-ho.
</p>

<p>
<code>max(a, b)</code> usa dos paràmetres d’entrada de qualsevol tipus primitiu numèric (<code>int</code>, <code>long</code>, <code>float</code> o <code>double</code>) i avalua el valor màxim d’entre tots dos. Cal tenir en compte que els dos paràmetres d’entrada sempre han de ser del mateix tipus, i el tipus del valor resultant és el mateix que el dels dos paràmetres d’entrada. Si es comparen dos <code>long</code>, el resultat també és un <code>long</code>, per exemple.  
</p>

<p>
<code>min(a, b)</code> és el mateix que l’anterior, però per al càlcul del mínim. 
</p>

<p>
Tot seguit es mostra un petit programa que mostra com invocar-los.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">public class MinMax {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    MinMax programa = new MinMax();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    double resReal = Math.max(1.2, 4.5);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;El valor màxim és &quot; + resReal);</div></li><li class="li1"><div class="de1">    int resEnter = Math.min(-8, 20);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;El valor mínim és &quot; + resEnter);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h3><a id="la_classe_arrays" >La classe Arrays</a></h3>
<div class="level3">

<p>
Aquesta classe pertany al <em>package</em> <code>java.util</code> (com <code>Random</code> i <code>Scanner</code>). Ofereix tot de mètodes estàtics per fer operacions típiques amb <em>arrays</em> (ordenacions, còpies, cerques, omplir rangs de posicions amb certs valors, etc.). Això la fa molt interessant, ja que estalvia molta feina i permet generar codi de manera senzilla. Val la pena conèixer a grans trets quins mètodes conté i saber invocar-los correctament. Ara bé, per usar-los cal tenir present que alguns d’aquests manipulen els paràmetres d’entrada de tipus compost, en aquest cas <em>arrays</em>. Per tant, en finalitzar la invocació, l’<em>array</em> original haurà canviat.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
L’existència de la classe <strong>Arrays</strong> no fa menys important dominar els esquemes de manipulació d’<em>arrays</em>.
</p>
</div></div>
<p>
Tot seguit es llisten algunes de les tasques que es poden assolir usant mètodes estàtics d’aquesta classe. Certament, un cop els domineu, veureu que això fa el codi dels programes molt més senzill que no pas quan heu de codificar aquestes tasques vosaltres mateixos!
</p>

<p>
<strong>1. Ordenació</strong>
</p>

<p>
Poder ordenar les dades dins un <em>array</em> pot ser molt còmode per tal de mostrar-les per pantalla i perquè les interpreteu. Per tant, és una operació comuna. <strong>Arrays</strong> ofereix un mètode per dur a terme aquesta operació fàcilment.
</p>

<p>
<code>sort(array)</code> només té un paràmetre d’entrada, que pot ser un <em>array</em> de qualsevol tipus de dades primitiu o de cadenes de text. En finalitzar la invocació, els seus elements estaran ordenats (per valor numèric o alfabèticament, segons el tipus de dades). Aquest mètode no avalua res (retorna <code>void</code>), ja que treballa directament sobre el paràmetre d’entrada, modificant-ne el contingut.
</p>

<p>
L’exemple següent mostra com ordenar molt fàcilment un <em>array</em> de cadenes de text. Fixeu-vos que aquest mètode no avalua cap resultat, la seva crida simplement transforma el contingut del paràmetre d’entrada.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">import java.util.Arrays;</div></li><li class="li1"><div class="de1">public class OrdenaArrayText {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    OrdenaArrayText programa = new OrdenaArrayText();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    String[] array = {&quot;Un&quot;, &quot;Dos&quot;, &quot;Tres&quot;, &quot;Quatre&quot;, &quot;Cinc&quot;};</div></li><li class="li1"><div class="de1">    Arrays.sort(array);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Els elements ordenats són:&quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      System.out.println(array[i]);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>2. Cerca</strong>
</p>

<p>
Un dels esquemes més típics d’operació amb <em>arrays</em> és, de fet, cercar on hi ha una posició amb un valor concret, per la qual cosa també és util disposar d’un mètode que ho permeti. 
</p>

<p>
<code>binarySearch(array, clau)</code> treballa a partir de dos paràmetres d’entrada: un <em>array</em> de qualsevol tipus primitiu o <code>String</code>, que ha d’haver estat prèviament ordenat, i el valor a cercar, que és la clau de la cerca. Si hi ha un element amb el valor cercat, el mètode avalua el número de la posició on se situa la primera aparició de la clau (un enter), o un valor negatiu si no se n’ha trobat cap. El valor negatiu permet esbrinar la posició d’inserció, dins l’<em>array</em>, del valor no trobat, per tal que l’<em>array</em> continui ordenat. Per esbrinar la posició d’inserció cal calcular <code>(-(valor negatiu) - 1)</code>.
</p>

<p>
Per poder invocar-lo correctament, les posicions de l’<em>array</em> i el valor a cercar han de ser del mateix tipus exactament. També és indispensable que l’<em>array</em> tingui els seus elements ordenats, ja que en cas contrari no es pot garantir la correctesa de la cerca. Finalment, sempre heu d’anar amb compte de comprovar si realment s’ha trobat la clau i, per tant, si el mètode ha avaluat un valor positiu o negatiu, ja que en el segon cas es tracta d’una posició invàlida dins l’<em>array</em>. En l’exemple següent es pot veure això:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">import java.util.Arrays;</div></li><li class="li1"><div class="de1">public class CercaArray {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    CercaArray programa = new CercaArray();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">     int[] array = {2, 5, 8, 1, 4, 2, 5, 3, 10};</div></li><li class="li1"><div class="de1">    //Primer cal ordenar</div></li><li class="li1"><div class="de1">    Arrays.sort(array);</div></li><li class="li1"><div class="de1">    int pos = Arrays.binarySearch(array, 5);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Hi ha un 5 a la posició &quot; + pos);</div></li><li class="li1"><div class="de1">    pos = Arrays.binarySearch(array, 6);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Hi ha un 6 a la posició &quot; + pos);</div></li><li class="li1"><div class="de1">  }    </div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>3. Còpia</strong>
</p>

<p>
Si feu memòria, recordareu que una de les propietats dels tipus compostos en Java és que no es poden fer còpies simplement amb una assignació. El que s’obté són dues variables amb noms diferents que permeten accedir a les mateixes dades. Si es vol una còpia d’un <em>array</em>, cal declarar-ne un de nou i copiar-hi tots els valors de l’original, posició per posició. Una altra opció és usar el mètode que ofereix la classe <strong>Arrays</strong>.
</p>

<p>
<code>copyOfRange(array, posInici, posFi)</code> permet crear còpies d’un conjunt de posicions d’un <em>array</em> (totes, o només una part). Aquest <em>array</em> pot contenir qualsevol tipus primitiu o cadenes de text. Requereix tres paràmetres, l’<em>array</em> amb les posicions a copiar, la posició origen i la posició destinació. En invocar-lo, aquest avalua un nou <em>array</em> amb (<code>posFi - posInici</code>) posicions, en cadascuna de les quals hi ha copiats els valors entre aquestes posicions (des de <code>posInici</code> fins a <code>posFi - 1</code>).
</p>

<p>
Cal anar amb molt de compte que les posicions origen i destinació siguin vàlides (positives i dins del rang de posicions). També s’ha de complir que la posició destinació sigui més gran que l’origen. En cas contrari, es produirà un error en l’execució del programa. Finalment, recordeu que per emmagatzemar el resultat caldrà assignar-lo a una variable de tipus <em>array</em>.
</p>

<p>
La millor manera de veure-ho és amb un exemple, en el qual el resultat de fer l’operació de còpia queda emmagatzemat a la variable <code>copia</code>.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">import java.util.Arrays;</div></li><li class="li1"><div class="de1">public class CopiaArray {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    CopiaArray programa = new CopiaArray();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    int[] origen = {2, 5, 8, 1, 4, 2, 5, 3, 10, 8};</div></li><li class="li1"><div class="de1">    //Si es vol copiar de la posició 1 a la 5</div></li><li class="li1"><div class="de1">    int[] copia = Arrays.copyOfRange(origen, 1, 6);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Els elements de la còpia són: &quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; copia.length; i++) {</div></li><li class="li1"><div class="de1">      System.out.println(copia[i]);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>4. Igualtat</strong>
</p>

<p>
Comparar dos <em>arrays</em> implica recorre’ls i anar comprovant posició per posició si totes són iguals. També hi ha un mètode que ja permet fer aquesta comprovació fàcilment.
</p>

<p>
<code>equals(array1, array2)</code> té dos paràmetres d’entrada, que són dos <em>arrays</em> de qualsevol tipus de dades primitiu o cadena de text. La seva invocació avalua un booleà que és <code>true</code> si els dos són iguals i <code>false</code> si no és el cas. 
</p>

<p>
Els valors emmagatzemats als dos <em>arrays</em> han de ser del mateix tipus de dades (no es pot comparar un <em>array</em> d’enters i un de reals, per exemple). L’exemple següent mostra el funcionament d’aquest mètode.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">import java.util.Arrays;</div></li><li class="li1"><div class="de1">public class ComparaArray {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    ComparaArray programa = new ComparaArray();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    double[] origen = {4.5, 1.2, 3.0, 1.4, 3.5};</div></li><li class="li1"><div class="de1">    //Es fa una còpia exacta</div></li><li class="li1"><div class="de1">    double[] copia = Arrays.copyOfRange(origen, 0, origen.length);</div></li><li class="li1"><div class="de1">    boolean iguals = Arrays.equals(origen, copia);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Són iguals? &quot; + iguals);</div></li><li class="li1"><div class="de1">    //Es modifica la còpia</div></li><li class="li1"><div class="de1">    copia[3] = 4.6;</div></li><li class="li1"><div class="de1">    iguals = Arrays.equals(origen, copia);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;I ara, són iguals? &quot; + iguals);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>5. Transformació a text</strong>
</p>

<p>
Finalment, una tasca molt típica és mostrar el contingut d’un <em>array</em> per pantalla (com es veu ja en els exemples recents). Per això, és útil transformar-lo a una cadena de text. 
</p>

<p>
<code>toString(array)</code>, donat un <em>array</em> qualsevol com a paràmetre d’entrada, avalua una cadena de text en la qual s’enumeren tots els seus valors. El format de la cadena resultant és una llista de valors separats per comes, entre claus: “[valor1, valor2, …, valorN]”.
</p>

<p>
Vegeu un exemple tot seguit.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.exemples;</div></li><li class="li1"><div class="de1">import java.util.Arrays;</div></li><li class="li1"><div class="de1">public class MostraArray {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    MostraArray programa = new MostraArray();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    int[] array = {2, 5, 8, 1, 4, 2, 5, 3, 10, 8};</div></li><li class="li1"><div class="de1">    String text = Arrays.toString(array);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;L'array conté els valors: &quot; + text);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 5</strong>. Creeu una classe que pertanyi al <em>package</em> <code>unitat5.apartat1.reptes</code>, el qual faci el següent. Es genera un <em>array</em> de 10 posicions i cadascuna d’elles s’inicialitza amb un valor a l’atzar entre 1 i 10, i es mostren per pantalla. Llavors, per cada valor escrit entre les posicions 0 a 4, se cerca si aquest és en alguna de les posicions entre la 5 i la 9. Cada cop que troba un dels valors, ho anuncia per pantalla. Useu tots els mètodes de la classe <strong>Arrays</strong> que sigui possible.
</p>

</div>

<h2><a id="documentacio_de_programes_en_java" >Documentació de programes en Java</a></h2>
<div class="level2">

<p>
Quan la mida dels programes creix i aquests es fan complicats, compostos per conjunts de classes dins de diversos <em>packages</em>, i cadascuna amb els seus mètodes, és important disposar d’alguna manera de poder saber fàcilment per a què serveix cada cosa. Algun mecanisme que faci fàcil avaluar si es poden reutilitzar en altres programes, o reprendre el fil d’un programa ja fet amb anterioritat si més endavant voleu fer esmenes al seu codi font.
</p>

<p>
Precisament, un aspecte força important, però sovint desatès, durant el desenvolupament d’un programa és documentar correctament el seu funcionament. Cal mantenir un document en el qual s’expliqui com funcionen tots els mòduls i de què es componen (en el cas de Java: <em>packages</em>, classes i mètodes), que ha d’estar actualitzat sempre a la darrera versió del programa. Sempre heu de tenir present que, si bé mentre l’esteu desenvolupant us semblaran evidents tots els aspectes relatius al seu funcionament, passat un temps us n’oblidareu. Llavors, si més endavant hi heu de tornar per fer alguna esmena o alguna modificació, pot resultar més feina tornar a entendre què feia cada bloc de codi que no pas la tasca pròpiament encomanada.
</p>

<p>
Sempre heu de tenir ben present, com a bon hàbit de programació, que es pot donar el cas que, de fet, no sigueu vosaltres mateixos els qui heu d’entendre els vostres programes, sinó terceres persones. El ventall de possibilitats sota les quals es pot donar aquesta circumstància pot anar des d’un company de treball que ha d’esmenar un bocí de codi que vàreu fer vosaltres fins a un professor que està avaluant el vostre exercici i necessita que sigui fàcil d’entendre i saber què fa cada part. Simplement, poseu-vos en el lloc d’haver d’entendre centenars de línies de codi font que no heu fet vosaltres per fer-vos una idea de per a què serveixen. En programes complexos, no és una tasca gens senzilla.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Encara que no és tan evident com generar codi font, facilitar la tasca de comprensió del codi també és una part integral del procés de desenvolupament d’un programa.
</p>
</div></div>
<p>
Un exemple molt clar de la utilitat de disposar d’una bona documentació és la de l’<acronym title="Application Programming Interface">API</acronym> de Java, on s’enumeren totes les classes, biblioteques i mètodes disponibles, explicant amb detall, per a cada cas, per a què serveixen els seus paràmetres d’entrada i el valor de retorn.
</p>

</div>

<h3><a id="javadoc" >Javadoc</a></h3>
<div class="level3">

<p>
Hi ha moltes aproximacions per dur a terme un procés de documentació acurada d’un programa. De fet, en moltes ocasions pot arribar a ser més complicat mantenir la documentació actualitzada que generar el codi font. Això es deu al fet que es tracta de generar un document addicional que cal modificar cada cop que hi ha canvis al codi. Això fa que el procés sigui farragós.
</p>

<p>
Java intenta pal·liar aquest fet mitjançant un mecanisme que permet generar documentació automàticament a partir del text escrit al codi font, de manera que només cal gestionar un únic fitxer per tenir la informació actualitzada. 
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
El <strong>javadoc</strong> és una eina auxiliar proporcionada pel <em>kit</em> de desenvolupament de Java (JDK), que permet generar automàticament documentació relativa a classes Java a partir de comentaris dins del seu codi font.
</p>
</div></div>
<p>
L’eina <em>javadoc</em> processa els fitxers de codi font de les classes d’un programa, de manera que cerca certes paraules clau distintives inserides als comentaris i a partir d’aquestes generar automàticament documentació en format <acronym title="HyperText Markup Language">HTML</acronym>. Això pot estalviar-vos molta feina si mentre aneu fent el codi font del programa sou acurats i ja aneu creant aquests comentaris, usant les paraules clau corresponents. Codificació i documentació es converteixen en tasques paral·leles.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Els IDE solen disposar d’una opció per integrar dins el seu entorn l’execució de l’eina javadoc.
</p>
</div></div>
<p>
De fet, la documentació de l’<acronym title="Application Programming Interface">API</acronym> de Java va estar generada en el seu moment usant aquesta eina. Totes les classes que venen amb les biblioteques de Java es van programar comentant el seu codi font d’acord al format adient. En acabar, només va caldre executar <em>javadoc</em> per crear l’<acronym title="HyperText Markup Language">HTML</acronym> amb tota la documentació.
</p>

</div>

<h3><a id="sintaxi_general" >Sintaxi general</a></h3>
<div class="level3">

<p>
Tot el text amb la informació requerida per generar documentació usant <em>javadoc</em> s’escriu dins de comentaris al codi font d’acord al format emprat per escriure múltiples línies, que és el que es mostra tot seguit. No es poden usar dobles contrabarres (que serveixen per comentar una línia individual).
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">/** Línia 1 de comentari.</div></li><li class="li1"><div class="de1">  * Línia 2 de comentari.</div></li><li class="li1"><div class="de1">  * ...</div></li><li class="li1"><div class="de1">  * Línia N del comentari.</div></li><li class="li1"><div class="de1">**/</div></li></ol></pre>

<p>
Aquests comentaris es poden inserir en les línies immediatament abans tant de la declaració de la classe (<strong>public class …</strong>) com dels mètodes. El que s’escrigui en les diferents línies del comentari serà l’explicació detallada d’aquella classe o mètode a la documentació final. 
</p>

<p>
Per exemple, l’esquelet de classe següent aportaria la documentació de la classe pròpia i dels seus dos mètodes.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat2.exemples;</div></li><li class="li1"><div class="de1">/** Tot just aquest text serà la documentació de la classe.</div></li><li class="li1"><div class="de1">  * El que estigui escrit s'inclourà directament a l'HTML resultant.</div></li><li class="li1"><div class="de1">  * Aquesta és una classe ben documentada.</div></li><li class="li1"><div class="de1">**/</div></li><li class="li1"><div class="de1">public class ClasseComentada {</div></li><li class="li1"><div class="de1">  /** Aquest és el seu primer mètode.</div></li><li class="li1"><div class="de1">    * Només es mostra l'esquelet, no cal codi de moment.</div></li><li class="li1"><div class="de1">    * És important veure com funcionen els comentaris per poder usar el javadoc.</div></li><li class="li1"><div class="de1">  **/</div></li><li class="li1"><div class="de1">  public void unMetode() {</div></li><li class="li1"><div class="de1">    ...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Un altre mètode, més escàs en documentació.</div></li><li class="li1"><div class="de1">  **/</div></li><li class="li1"><div class="de1">  public void unAltreMetode() {</div></li><li class="li1"><div class="de1">    ...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Tot el text escrit als comentaris es transforma en text normal en <acronym title="HyperText Markup Language">HTML</acronym>, en un mateix paràgraf. Si es volen afegir efectes especials (negretes, cursiva. etc.) o estructures de text una mica més complexes (com llistes ordenades o enumerades), en el text d’aquests comentaris és possible usar comandes en <acronym title="HyperText Markup Language">HTML</acronym>.
</p>

<p>
Per exemple, si se sap que l’ordre <acronym title="HyperText Markup Language">HTML</acronym> <code>&lt;b&gt;…&lt;/b&gt;</code> serveix per fer que un text aparegui en negreta, i que l’ordre <code>&lt;ol&gt;…&lt;/ol&gt;</code> permet crear una llista enumerada, es podria fer:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  /** Aquest és un mètode extra.</div></li><li class="li1"><div class="de1">    * Ara conté una &lt;b&gt;llista d'ítems&lt;/b&gt;.</div></li><li class="li1"><div class="de1">    * &lt;ol&gt;</div></li><li class="li1"><div class="de1">    *  &lt;li&gt; Ítem 1.</div></li><li class="li1"><div class="de1">    *  &lt;li&gt; Ítem 2.</div></li><li class="li1"><div class="de1">    *  &lt;li&gt; Ítem 3.</div></li><li class="li1"><div class="de1">    *  &lt;li&gt; Ítem 4.</div></li><li class="li1"><div class="de1">    * &lt;/ol&gt;</div></li><li class="li1"><div class="de1">  **/</div></li><li class="li1"><div class="de1">  public void unTercerMetode() {</div></li><li class="li1"><div class="de1">    ...</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>

<p>
En usar ordres cal anar amb compte, ja que heu de tenir present que el text que heu escrit s’acabarà incorporant a un document <acronym title="HyperText Markup Language">HTML</acronym> general. Per tant, és millor limitar-se a les ordres més simples, i sobretot, mai usar ordres vinculades a encapçalaments (<code>&lt;h1&gt;…&lt;/h1&gt;</code>, etc.).
</p>

<p>
<strong>Repte 6</strong>. Proveu d’executar el <em>javadoc</em> des del vostre entorn de desenvolupament per generar la documentació de l’exemple. Tingueu en compte que perquè funcioni no cal que hi hagi instruccions dins dels mètodes, els podeu deixar buits. Només cal que hi hagi comentaris seguint aquest format.
</p>

</div>

<h3><a id="paraules_clau" >Paraules clau</a></h3>
<div class="level3">

<p>
Hi ha alguns aspectes d’una classe o un mètode que són especialment rellevants, com el seu autor, paràmetres d’entrada o valor de retorn. A part d’una descripció general, val la pena disposar d’una llista clara de quins són i el valor esperat, de manera que destaquin més en el document <acronym title="HyperText Markup Language">HTML</acronym> resultant. Per això, hi ha un seguit de paraules clau que es poden usar un cop finalitzat el text, de manera que s’indica en el <em>javadoc</em> aquesta informació addicional. 
</p>

<p>
Totes les paraules clau queden identificades perquè es precedeixen d’un símbol “@”, de manera que no puguin ser confoses per text normal, part de la descripció. Després de la paraula clau, es pot escriure una línia de text qualsevol que es considera la seva informació associada.
</p>

<p>
Tot seguit veureu algunes de les paraules clau més usades.
</p>
<ul>
<li class="level1"><div class="li">  <strong>@author</strong>. Aquesta paraula clau només s’usa després del text associat a la descripció de la classe. Indica qui n’ha estat l’autor. Per exemple:</div>
</li>
</ul>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat2.exemples;</div></li><li class="li1"><div class="de1">/** Tot just aquest text serà la documentació de la classe.</div></li><li class="li1"><div class="de1">  * El que estigui escrit s'inclourà directament a l'HTML resultant.</div></li><li class="li1"><div class="de1">  * Aquesta és una classe ben documentada</div></li><li class="li1"><div class="de1">  * @author IOC</div></li><li class="li1"><div class="de1">**/</div></li><li class="li1"><div class="de1">public class ClasseComentada {</div></li><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>
<ul>
<li class="level1"><div class="li"> <strong>@param</strong>. Aquesta paraula clau només s’usa després del text associat a la descripció d’un mètode i descriu un dels seus paràmetres. Caldrà afegir-ne tantes paraules clau d’aquest tipus, en diferents línies consecutives, com paràmetres té el mètode. El text ha de començar per l’identificador del paràmetre d’entrada que es vol descriure, i tot seguit s’escriu la seva descripció, on caldria explicar per a què serveix.</div>
</li>
</ul>
<pre class="code java"><ol><li class="li1"><div class="de1">  /** Un mètode amb paràmetres.</div></li><li class="li1"><div class="de1">   * @param unParametre Aquest paràmetre serveix per fer una cosa.</div></li><li class="li1"><div class="de1">   * @param unaltre Parametre Aquest paràmetre diferent serveix per fer una altra cosa.</div></li><li class="li1"><div class="de1">  **/</div></li><li class="li1"><div class="de1">  public void unMetodeParametritzat(int unParametre, int altreParametre) {</div></li><li class="li1"><div class="de1">    ...</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>
<ul>
<li class="level1"><div class="li"> <strong>@returns</strong>. Aquesta paraula clau només s’usa després del text associat a la descripció d’un mètode i descriu què avalua el mètode (el valor retornat). Normalment s’escriu després de les paraules clau <code>@params</code>, si n’hi ha. Si un mètode no retorna res (<code>void</code>), no cal incloure’l. El text associat és directament la descripció.</div>
</li>
</ul>
<pre class="code java"><ol><li class="li1"><div class="de1">  /** Un mètode amb paràmetres.</div></li><li class="li1"><div class="de1">   * @param unParametre Aquest paràmetre serveix per fer una cosa.</div></li><li class="li1"><div class="de1">   * @param unaltre Parametre Aquest paràmetre diferent serveix per fer una altra cosa.</div></li><li class="li1"><div class="de1">   * @returns Un valor que depèn dels dos paràmetres.</div></li><li class="li1"><div class="de1">  **/</div></li><li class="li1"><div class="de1">  public int unMetodeParametritzat(int unParametre, int altreParametre) {</div></li><li class="li1"><div class="de1">    ...</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>
<ul>
<li class="level1"><div class="li"> <strong>@see</strong>. Aquesta paraula clau es pot usar tant després de la descripció d’un mètode com d’una classe. Serveix per referir-se a la pàgina de documentació d’altres classes dins el mateix programa, en els casos de programes modulars compostos per diferents classes. Bàsicament diu: “Per a més informació, veure també la documentació de…”. No serveix per referir-se a qualsevol classe, només funciona amb classes de les quals es disposa el codi font comentat en aquest format. Dins d’un IDE, normalment seran classes dins del mateix projecte. </div>
</li>
</ul>

<p>
Com a text associat, cal posar el nom qualificat de la classe a què es refereix.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">/** Tot just aquest text serà la documentació de la classe.</div></li><li class="li1"><div class="de1">  * El que estigui escrit s'inclourà directament a l'HTML resultant.</div></li><li class="li1"><div class="de1">  * Aquesta és una classe ben documentada.</div></li><li class="li1"><div class="de1">  * @author IOC</div></li><li class="li1"><div class="de1">  * @see utilitats.arrays.CalculsArrays</div></li><li class="li1"><div class="de1">**/</div></li><li class="li1"><div class="de1">public class ClasseComentada {</div></li><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>

</p>

</div>

<h2><a id="solucio_dels_reptes_proposats" >Solució dels reptes proposats</a></h2>
<div class="level2">

<p>
<strong>Repte 1</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class MitjanaMaxima {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    MitjanaMaxima programa = new MitjanaMaxima();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    double[] arrayA = {2, 10.5, 6.3, 4.9, 0, 7.1, 8.3};</div></li><li class="li1"><div class="de1">    double[] arrayB = {9.4, 6.0, 2.2, 1.0, 8.1};</div></li><li class="li1"><div class="de1">    //Per cridar els mètodes cal inicialitzar la classe que els conté</div></li><li class="li1"><div class="de1">    CalculsArrayReals calculador = new CalculsArrayReals();</div></li><li class="li1"><div class="de1">    //Un cop fet, cal cridar-los usant com a prefix l'identificador</div></li><li class="li1"><div class="de1">    double mitjanaA = calculador.calcularMitjana(arrayA);</div></li><li class="li1"><div class="de1">    double mitjanaB = calculador.calcularMitjana(arrayB);</div></li><li class="li1"><div class="de1">    if (mitjanaA &gt; mitjanaB) {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;arrayA té una mitjana més alta.&quot;);</div></li><li class="li1"><div class="de1">    } else if (mitjanaA &lt; mitjanaB) {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;arrayB té una mitjana més alta.&quot;);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Les dues mitjanes són iguals!&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 2</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">//------ Fitxer RegistreNotes.java ------ </div></li><li class="li1"><div class="de1">package unitat5.apartat1.reptes;</div></li><li class="li1"><div class="de1">public class RegistreNotes {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    RegistreNotes programa = new RegistreNotes();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    double[] notes = {2.0, 5.5, 7.25, 3.0, 9.5, 8.25, 7.0, 7.5};</div></li><li class="li1"><div class="de1">    //Per cridar els mètodes cal inicialitzar la classe que els conté</div></li><li class="li1"><div class="de1">    CalculsArrayReals calculador = new CalculsArrayReals();</div></li><li class="li1"><div class="de1">    //Un cop fet, cal cridar-los usant com a prefix l'identificador</div></li><li class="li1"><div class="de1">    double max = calculador.calcularMaxim(notes);</div></li><li class="li1"><div class="de1">    double min = calculador.calcularMinim(notes);</div></li><li class="li1"><div class="de1">    double mitjana = calculador.calcularMitjana(notes);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La nota màxima és &quot; + max + &quot;.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La nota mínima és &quot; + min + &quot;.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La mitjana de les notes és &quot; + mitjana + &quot;.&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>
<pre class="code java"><ol><li class="li1"><div class="de1">//------ Fitxer CalculsArrayReals.java ------ </div></li><li class="li1"><div class="de1">package unitat5.apartat1.reptes;</div></li><li class="li1"><div class="de1">public class CalculsArrayReals {</div></li><li class="li1"><div class="de1">  public double calcularMaxim(double[] array) {</div></li><li class="li1"><div class="de1">    double max = array[0];</div></li><li class="li1"><div class="de1">    for (int i = 1; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      if (max &lt; array[i]) {</div></li><li class="li1"><div class="de1">        max = array[i];</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return max;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public double calcularMinim(double[] array) {</div></li><li class="li1"><div class="de1">    double min = array[0];</div></li><li class="li1"><div class="de1">    for (int i = 1; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      if (min &gt; array[i]) {</div></li><li class="li1"><div class="de1">        min = array[i];</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return min;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public double calcularMitjana(double[] array) {</div></li><li class="li1"><div class="de1">    double suma = 0;</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      suma = suma + array[i];</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return suma/array.length;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 3</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">//------ Fitxer RegistreNotes.java ------ </div></li><li class="li1"><div class="de1">package unitat5.apartat1.reptes;</div></li><li class="li1"><div class="de1">import utilitats.arrays.CalculsArraysReals;</div></li><li class="li1"><div class="de1">public class RegistreNotes {</div></li><li class="li1"><div class="de1">  //El codi no canvia</div></li><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>
<pre class="code java"><ol><li class="li1"><div class="de1">//------ Fitxer CalculsArrayReals.java ------ </div></li><li class="li1"><div class="de1">package utilitats.arrays;</div></li><li class="li1"><div class="de1">public class CalculsArrayReals {</div></li><li class="li1"><div class="de1">  //El codi no canvia</div></li><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 4</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.reptes;</div></li><li class="li1"><div class="de1">import java.util.Random;</div></li><li class="li1"><div class="de1">public class RealsAleatoris {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    RealsAleatoris programa = new RealsAleatoris();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    //Inicialització. Per exemple, s'usa el valor 100 com &quot;arrel&quot; (seed).</div></li><li class="li1"><div class="de1">    Random rnd = new Random(100L);</div></li><li class="li1"><div class="de1">    //Ús</div></li><li class="li1"><div class="de1">    double valorA = rnd.nextDouble() * 100;</div></li><li class="li1"><div class="de1">    double valorB = rnd.nextDouble() * 100;</div></li><li class="li1"><div class="de1">    System.out.println(&quot;S'han generat els valors &quot; + valorA  + &quot; i &quot; + valorB);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 5</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat5.apartat1.reptes;</div></li><li class="li1"><div class="de1">import java.util.Arrays;</div></li><li class="li1"><div class="de1">import java.util.Random;</div></li><li class="li1"><div class="de1">public class CercaValors {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    CercaValors programa = new CercaValors();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    int[] array = new int[10];</div></li><li class="li1"><div class="de1">    Random rnd = new Random();</div></li><li class="li1"><div class="de1">    //Omplim l'array</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; array.length; i++) {</div></li><li class="li1"><div class="de1">      array[i] = rnd.nextInt(11);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Es divideix l'array en dos</div></li><li class="li1"><div class="de1">    int[] arrayValors = Arrays.copyOfRange(array, 0, 5);</div></li><li class="li1"><div class="de1">    int[] arrayCercar = Arrays.copyOfRange(array, 5, array.length);</div></li><li class="li1"><div class="de1">    Arrays.sort(arrayCercar);</div></li><li class="li1"><div class="de1">    System.out.print(&quot;Valors a cercar: &quot;);</div></li><li class="li1"><div class="de1">    System.out.println(Arrays.toString(arrayValors));</div></li><li class="li1"><div class="de1">    System.out.print(&quot;Array on se cerca: &quot;);</div></li><li class="li1"><div class="de1">    System.out.println(Arrays.toString(arrayCercar));</div></li><li class="li1"><div class="de1">    //Es fan les cerques</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; arrayCercar.length; i++) {</div></li><li class="li1"><div class="de1">      int valor = arrayValors[i];</div></li><li class="li1"><div class="de1">      int pos = Arrays.binarySearch(arrayCercar, valor);</div></li><li class="li1"><div class="de1">      if (pos &gt;= 0) {</div></li><li class="li1"><div class="de1">        System.out.println(&quot;A la posició &quot; + pos + &quot; hi ha el valor &quot; + valor);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 6</strong>
</p>

<p>
Les passes per dur a terme la tasca depenen de l’entorn de desenvolupament usat.
</p>

</div>

	 </article>
     <div class="pnpage">
      <div class="left-corner"></div>
      <div id="prevpage">Anar a la p&agrave;gina anterior:<br /><a href="../../../WebContent/u5/referencies.html">Referències</a></div>
      <div id="nextpage">Anar a la p&agrave;gina seg&uuml;ent:<br /><a href="../../../WebContent/u5/a1/activitats.html">Activitats</a></div>
      <div class="right-corner"></div>
     </div>
    </div>
    <footer class="footer">
      <div><small>Aquest document està subjecte a una llicència oberta de Creative Commons, es reserva el dret de reconeixement de l'autoria, d'exigir que no se'n faci cap mena d'ús comercial. Si altereu o transformeu aquesta obra, o en genereu obres derivades, només podeu distribuir l'obra generada amb una llicència idèntica a aquesta.</small></div>
    </footer>
 </div>
 <div id="back_preview" class="hidden"></div>
 <div id="preview" class="hidden">
  <div class="prevcontent"></div>
 </div>
 <div id="help-tooltips">
  <div id="help-toc" class="hidden tooltip"><span>Taula de continguts:</span> Ofereix una vista general de l&#39;estructura del m&ograve;dul, que us facilitar&agrave; la navegaci&oacute; a trav&eacute;s dels seus continguts.<span class="arrow-left"></span></div> 
  <div id="help-settings" class="hidden tooltip"><span>Opcions de format:</span> Permet configurar el format de lectura a partir de les vostres prefer&egrave;ncies, modificant la mida de la lletra, el color del fons, l&#39;amplada de la p&agrave;gina o l&#39;ocultaci&oacute; dels continguts complementaris, entre d&#39;altres.<span class="arrow-left"></span></div>
  <div id="help-printer" class="hidden tooltip"><span>Imprimir:</span>  Envia el contingut seleccionat a la impressora.<span class="arrow-left"></span></div>
  <div id="help-favorites" class="hidden tooltip"><span>Prefereits:</span> Permet desar aquelles parts del contingut a les que us interessi accedir en un moment posterior; us permetr&agrave; anar creant un repositori personalitzat de les seccions que considereu m&eacute;s rellevants. Un cop l&#39;hageu començat a fer servir se us mostrar&agrave; a sota un comptador que us informar&agrave; del nombre de preferits que s&#39;hagin emmagatzemat fins al moment.<span class="arrow-left"></span></div>
  <div id="help-favcounter" class="hidden tooltip"><span>Comptador i llistat de preferits:</span> Indica el nombre de preferits que s&#39;han desat fins el moment; clicant damunt seu accedireu al llistat de preferits, i a trav&eacute;s d&#39;aquest podreu accedir directament als continguts que hageu emmagatzemat.<span class="arrow-left"></span></div>
  <div id="help-help_icon" class="hidden tooltip"><span>Ajuda:</span> Aquesta opci&oacute; activa la informaci&oacute; de les funcionalitats del web tot situant el punter del ratol&iacute; al damunt dels diferents &iacute;tems.<span class="arrow-left"></span></div>
  <div id="help-sidebar-hide" class="hidden tooltip"><span>Mostrar/Ocultar barra lateral:</span>  Deshabilita la barra d&#39;opcions, permetent la seva recuperaci&oacute; quan es desitgi.<span class="arrow-left"></span></div>
  <div id="help-search" class="hidden tooltip"><span>Cerca:</span>  Introdu&iuml;u les paraules clau sobre aquells conceptes que desitgeu localitzar en els continguts del m&ograve;dul. Tamb&eacute; podeu excloure un terme de la cerca tot afegint-hi el signe &#8220;-&#8221; al davant.<span class="arrow-top"></span></div>
  <div id="help-header" class="hidden tooltip"><span>Cap&ccedil;alera:</span>  Indica l&#39;apartat o secci&oacute; que es mostra en pantalla. Tingueu present que les capçaleres de segon, tercer i quart nivell tamb&eacute; es poden desar com a marcadors.<span class="arrow-left"></span></div>
</div> 
</body>
</html>
