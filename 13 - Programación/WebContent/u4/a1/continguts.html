<!doctype html>

<!--[if lt IE 7 ]> <html class="ie ie6 no-js" lang="ca"> <![endif]-->
<!--[if IE 7 ]>    <html class="ie ie7 no-js" lang="ca"> <![endif]-->
<!--[if IE 8 ]>    <html class="ie ie8 no-js" lang="ca"> <![endif]-->
<!--[if IE 9 ]>    <html class="ie ie9 no-js" lang="ca"> <![endif]-->
<!--[if gt IE 9]><!--><html class="no-js" lang="ca"><!--<![endif]-->
<!-- the "no-js" class is for Modernizr. -->

<head id="www-sitename-com" data-template-set="html5-reset">

	<meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html">
        
	<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Programació bàsica (ASX) \ Programació (DAM i DAW)</title>
	
<!-- <meta name="title" content=""> --> 
	<meta name="description" content="">
	<!-- Google will often use this as its description of your page/site. Make it good. -->
	
	<meta name="google-site-verification" content="">
	<!-- Speaking of Google, don't forget to set your site up: http://google.com/webmasters -->
	
	<meta name="author" content="Institut Obert de Catalunya">
	<meta name="Copyright" content="Copyright Institut Obert de Catalunya 2011. All Rights Reserved.">

	<!-- Dublin Core Metadata : http://dublincore.org/ -->
	<meta name="DC.title" content="Programació bàsica (ASX) \ Programació (DAM i DAW)">
	<meta name="DC.subject" content="Informàtica i comunicacions">
	<meta name="DC.creator" content="Institut Obert de Catalunya">
	
	<!--  Mobile Viewport Fix
	j.mp/mobileviewport & davidbcalhoun.com/2010/viewport-metatag 
	device-width : Occupy full width of the screen in its current orientation
	initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
	maximum-scale = 1.0 retains dimensions instead of zooming in if page width < device width
	-->
	<!-- Uncomment to use � use thoughtfully!
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	-->

	<link rel="shortcut icon" href="../../../img/favicon.ico">
	<!-- This is the traditional favicon.
		 - size: 16x16 or 32x32
		 - transparency is OK
		 - see wikipedia for info on browser support: http://mky.be/favicon/ -->
		 
	<link rel="apple-touch-icon" href="../../../img/apple-touch-icon.png">
	<!-- The is the icon for iOS's Web Clip.
		 - size: 57x57 for older iPhones, 72x72 for iPads, 114x114 for iPhone4's retina display (IMHO, just go ahead and use the biggest one)
		 - To prevent iOS from applying its styles to the icon name it thusly: apple-touch-icon-precomposed.png
		 - Transparency is not recommended (iOS will put a black BG behind the icon) -->
	
	<!-- CSS: screen, mobile & print are all in the same file -->
	<link rel="stylesheet" href="../../../_/css/style.css">

	<!-- CSS: jQuery UI -->
	<link rel="stylesheet" href="../../../_/css/jquery-ui.css">
	
	<!-- all our JS is at the bottom of the page, except for Modernizr. -->
	<script src="../../../_/js/modernizr-1.7.min.js"></script>
	<script src="../../../_/js/Hyphenator.js" type="text/javascript"></script>
	<script type="text/javascript">
	   Hyphenator.config({
		minwordlength : 4
	   });
	   Hyphenator.run();
	</script>
    <script src="../../../_/js/build.js" type="text/javascript"></script>
</head>

<body class="style-newspaper">

<div class="wrapper"><!-- not needed? up to you: http://camendesign.com/code/developpeurs_sans_frontieres -->

	<header id="header">
		<div class="head"><a href="http://ioc.gencat.cat"><img src="../../../img/logo.png" alt="Institut Obert de Catalunya"/></a><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/es/deed.ca"><img src="../../../img/license.png" alt="Llic&egrave;ncia" class="license"/></a></div>
		<div class="headdocument"><a href="../../../index.html">Programació bàsica (ASX) \ Programació (DAM i DAW)</a></div>
        <div id="search" class="search" name="search">
         <form id="frmsearch" action="../../../search.html" method="get">
          <input type="text" name="q"/>
        </form>
        </div>
	</header>
   <div id="upbutton" class="upbutton" style="display:none;"><img src="../../../img/uparrow.png" alt="Pujar a l'inici de p&agrave;gina"/></div>
   <aside id="aside">
    <div id="menu">
      <ul>
       <li name="toc"><div><img src="../../../img/toc.png" alt="&Iacute;ndex"/></div></li>
       <li name="settings"><div><img src="../../../img/settings.png" alt="Configuraci&oacute;"/></div></li>
       <li name="printer"><div><img src="../../../img/printer.png" alt="Imprimir"/></div></li>
       <li name="favorites"><div><img src="../../../img/favorites.png" alt="Favorits"/></div></li>
       <li name="help_icon" class="help_icon"><div><img src="../../../img/help_icon.png" alt="Ajuda"/></div></li>
      </ul>
     </div>
   </aside>
   <div id="sidebar-hide" name="sidebar-hide"><img src="../../../img/arrows.png"/></div>
   <section>
     <div id="toc" class="hidden">
      <div class="menucontent">
        <ul>
        <li id="u4" class="parentnode"><p><a class="unit" href="../../../WebContent/u4/introduccio.html">4. Programació modular</a></p><ul class="expander"><li id="u4introduccio"><a href="../../../WebContent/u4/introduccio.html">Introducció</a></li><li id="u4resum"><a href="../../../WebContent/u4/resum.html">Resum</a></li><li id="u4resultats_d_aprenentatge"><a href="../../../WebContent/u4/resultats_d_aprenentatge.html">Resultats d'aprenentatge</a></li><li id="u4mapa"><a href="../../../WebContent/u4/mapa.html">Mapa conceptual</a></li><li id="u4referencies"><a href="../../../WebContent/u4/referencies.html">Referències</a></li><li id="u4a1" class="tocsection"><p id='u4a1continguts'><a class="section" href="../../../WebContent/u4/a1/continguts.html">Descomposició de problemes</a><span class="buttonexp"></span></p><ul><li id="u4a1activitats"><a href="../../../WebContent/u4/a1/activitats.html">Activitats</a></li><li id="u4a1exercicis"><a href="../../../WebContent/u4/a1/exercicis.html">Exercicis d'autoavaluació</a></li><li id="u4a1annexos"><a href="../../../WebContent/u4/a1/annexos.html">Annexos</a></li></ul></li><div data-parent-id='u4a1' class='tocssection hidden'><div class="toc"><ul><li><a href="../../../WebContent/u4/a1/continguts.html#disseny_descendent">Disseny descendent</a></li><li><a href="../../../WebContent/u4/a1/continguts.html#disseny_descendent_aplicat_a_la_creacio_de_programes">Disseny descendent aplicat a la creació de programes</a></li><li><a href="../../../WebContent/u4/a1/continguts.html#un_exemple_mes_complex">Un exemple més complex</a></li><li><a href="../../../WebContent/u4/a1/continguts.html#solucio_dels_reptes_proposats">Solució dels reptes proposats</a></li></ul></div></div><li id="u4a2" class="tocsection"><p id='u4a2continguts'><a class="section" href="../../../WebContent/u4/a2/continguts.html">Parametrització de mètodes</a><span class="buttonexp"></span></p><ul><li id="u4a2activitats"><a href="../../../WebContent/u4/a2/activitats.html">Activitats</a></li><li id="u4a2exercicis"><a href="../../../WebContent/u4/a2/exercicis.html">Exercicis d'autoavaluació</a></li></ul></li><div data-parent-id='u4a2' class='tocssection hidden'><div class="toc"><ul><li><a href="../../../WebContent/u4/a2/continguts.html#parametres_d_entrada">Paràmetres d'entrada</a></li><li><a href="../../../WebContent/u4/a2/continguts.html#parametres_de_sortida">Paràmetres de sortida</a></li><li><a href="../../../WebContent/u4/a2/continguts.html#quan_declarar_parametres_d_entrada_o_sortida">Quan declarar paràmetres d'entrada o sortida</a></li><li><a href="../../../WebContent/u4/a2/continguts.html#un_exemple_de_disseny_descendent_amb_metodes_parametritzats">Un exemple de disseny descendent amb mètodes parametritzats</a></li><li><a href="../../../WebContent/u4/a2/continguts.html#solucions_als_reptes_proposats">Solucions als reptes proposats</a></li></ul></div></div></ul></li><li id="" class="indexnode"><p><a href="../../../index.html">Anar a l&#39;&iacute;ndex general</a></p></li>
        </ul>
      </div>
    </div>
   </section>
   <section>
   <div id="settings" class="hidden">
    <div class="menucontent">
     <div class="allsettings">
     <div class="settings">
      <label>Font i Color</label>
		<div class="setting-option">
	        <ul class="fontBackground">
				<li id="style-newspaper" title="Newspaper" class="appearance-style-newspaper"><span>Newspaper</span></li>
                <li id="style-novel" title="Novel" class="appearance-style-novel"><span>Novel</span></li>
                <li id="style-ebook" title="eBook" class="appearance-style-ebook"><span>eBook</span></li>
				<li id="style-inverse" title="Inverse" class="appearance-style-inverse active"><span>Inverse</span></li>
				<li id="style-athelas" title="Athelas" class="appearance-style-athelas"><span>Athelas</span></li>
			</ul>
		</div>
     </div>
	<div class="settings">
      <label>Amplada</label>
		<div class="setting-option">
	        <div id="slider-width"></div>
		</div>
     </div>
     <div class="settings">
      <label>Mida de la font</label>
		<div class="setting-option">
	        <div id="slider-font"></div>
		</div>
     </div>
     <div class="settings">
      <label>Mida de la font</label>
	  <div class="setting-option">
       <form action="" class="sett-options">
		<ul>
		    <li><input type="checkbox" id="secondary-content" /><label for="secondary-content">Mostra recursos complementaris</label></li>
		    <li><input type="checkbox" id="main-images" /><label for="main-images">Mostra imatges</label></li>
		    <li><input type="checkbox" id="text-alignment" /><label for="text-alignment">Text justificat</label></li>
			<li><input type="checkbox" id="text-hyphen" /><label for="text-hyphen">Partici&oacute; sil·l&agrave;bica</label></li>
		</ul>
       </form>
	  </div>
     </div>
     </div>
    </div>
   </div>
   </section>
 <section>
 <div id="favorites" class="hidden"></div>
 </section>   
 <div id="bridge" class="hidden"></div>
 <div id="help" class="hidden">
  <div class="helptitle">Dreceres del teclat<hr></div>
  <div class="helpsection"><span>General</span>
   <ul>
    <li><span class="shortcut">g</span>: Anar al men&uacute; de navegaci&oacute;</li>
    <li><span class="shortcut">o</span>: Anar a opcions</li>
    <li><span class="shortcut">s</span>: Guardar la p&agrave;gina actual a favorits</li>
    <li><span class="shortcut">p</span>: Imprimir la p&agrave;gina actual</li>
    <li><span class="shortcut">?</span>: Mostrar/Ocultar l&#39;ajuda</li>
   </ul>
  </div>
  <div class="helpsection"><span>Navegaci&oacute;</span>
   <ul>
    <li><span class="shortcut">i</span>: Anar a l&#39;&iacute;ndex general</li>
    <li><span class="shortcut">t</span>: Anar a l&#39;inici de p&agrave;gina</li>
    <li><span class="shortcut">b</span>: Anar al final de p&agrave;gina</li>
    <li><span class="shortcut">j</span>: Anar cap endavant dintre la p&agrave;gina</li>
    <li><span class="shortcut">k</span>: Anar cap enrere dintre la p&agrave;gina</li>
    <li><span class="shortcut">h</span>: Anar a la p&agrave;gina anterior:</li>
    <li><span class="shortcut">l</span>: Anar a la p&agrave;gina seg&uuml;ent:</li>
   </ul>
   </div>
 </div>
 <div id="favcounter" name="favcounter" class="hidden"><span></span></div>
 <div id="navmenu" class="navmenu"><ul class="webnav"><li><a href="../../../index.html" title="Anar a l&#39;&iacute;ndex general">Inici</a></li><li><a href="../introduccio.html">Programació modular</a></li><li>Descomposició de problemes</li></ul></div>
	<div id="content" lang="ca" class="hyphenate text">
     <article lang="ca" class="sheet">
        <h1><a id="descomposicio_de_problemes"> Descomposició de problemes </a></h1>
    	
<p>
Igual que amb la immensa majoria de tasques amb cert grau de complexitat dins el món real, la creació d’un programa requereix un pas previ on cal reflexionar sobre què és exactament el que voleu fer i com assolireu la vostra fita. És molt poc recomanable afrontar aquesta tasca ja seient directament davant de l’ordinador, obrint l’entorn de treball i començant a escriure línies de codi. Aquesta opció només és realment factible quan disposeu d’una certa experiència programant i trobeu que el problema que heu de resoldre, o bé ja l’heu tractat amb anterioritat, o s’assembla molt a un altre que ja heu resolt. Però quan us enfronteu amb un problema nou és imprescindible una etapa en la qual estudiar el problema, les dades que voleu tractar exactament i les tasques que ha de dur a terme l’ordinador per fer-ho (o sigui, l’algorisme del programa).
</p>

<p>
Malauradament, la capacitat dels humans per copsar problemes complexos és limitada, ja que, en general, només som capaços de mantenir una visió simultània d’uns pocs elements. A aquest fet cal afegir que la presa d’una decisió sobre quina passa cal dur a terme dins la descripció d’un procés sempre té implicacions sobre futures passes. Per tant, quan el procés que cal realitzar és llarg o es basa en la manipulació de molts elements diferents, és molt fàcil, no ja simplement equivocar-se, sinó tan sols saber per on començar. 
</p>

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10m3u4_01.png" class="imgB" title="Com diu la frase que s&#039;atribueix a Filip II de Macedònia: &quot;Divide et impera&quot; (divideix i venceràs). Font: Tilemahos Efthimiadis/2" alt="Com diu la frase que s&#039;atribueix a Filip II de Macedònia: &quot;Divide et impera&quot; (divideix i venceràs). Font: Tilemahos Efthimiadis/2" /></li><li><small>Com diu la frase que s&#039;atribueix a Filip II de Macedònia: &quot;Divide et impera&quot; (divideix i venceràs). Font: Tilemahos Efthimiadis</small></li>
</ul></div>

</p>

<p>
Un cop arribats a aquest punt, es fa evident que resultaria útil disposar d’alguna estratègia que permeti fer front a la resolució de problemes amb diferents graus de complexitat. Una de les més populars en tots els camps, i que de ben segur useu sovint en el vostre dia a dia, potser sense adonar-vos, és considerar que un problema complex en realitat no és més que l’agregació d’un conjunt de problemes més simples, cadascun d’ells més fàcils de resoldre. Per tant, si sou capaços d’entendre i resoldre tot aquest conjunt de problemes simples, també podreu ser capaços de resoldre el problema complex. 
</p>

<p>
En conseqüència, i partint d’aquesta premissa, el primer pas per poder dur a terme una tasca complexa serà trobar com descompondre-la en d’altres més simples, que llavors s’aniran resolent un per un.
</p>

<h2><a id="disseny_descendent" >Disseny descendent</a></h2>
<div class="level2">

<p>
Hi ha dues estratègies bàsiques per resoldre la descomposició d’un problema: el disseny descendent i l’ascendent. Aquest apartat se centra en la primera, en ser la més utilitzada per norma general, i la més fàcil d’aplicar a l’hora de crear programes del nivell que abasten aquests materials.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
En el context de la programació, el disseny ascendent normalment s’aplica dins el camp de l’orientació a objectes.
</p>
</div></div><div class="iocimportant"><div class="ioccontent">
<p>
El <strong>disseny descendent</strong>  (<em>top-down</em>, en anglès) és la tècnica que es basa en partir d’un problema general i dividir-lo en problemes més simples, denominats subproblemes. D’entre tots aquests, els considerats encara massa complexos es tornen a dividir en nous subproblemes. S’anomena descendent perquè partint del problema gran es passa a problemes més petits als quals donarà solució individualment.
</p>
</div></div>
<p>
L’esquema d’aplicació d’aquesta estratègia es mostra a la <span class="figref"><a href="#Figure1"><span>figura</span></a></span>, en la qual es veu la raó del nom <em>descendent</em>, i s’aprecia com, partint de la definició del problema general, extreta de tasca final que voleu assolir, es crea una estructura jeràrquica de subproblemes en diferents nivells. El nombre de nivells a què cal arribar dependrà de la complexitat del problema general. Per a problemes no massa complexos, hi haurà prou amb un o dos nivells, però per resoldre problemes molt complexos pot caldre un gran nombre de successives descomposicions. També val la pena remarcar que, tot i que és recomanable que la complexitat dels subproblemes d’un mateix nivell sigui aproximadament equivalent, n’hi pot haver que quedin resolts completament en menys nivells que en d’altres. 
</p>
<div class="iocfigure"><a name="Figure1"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Esquema d’aplicació de disseny descendent, d’acord als nivells de descomposició del problema

</figcaption><img src="../media/ic10m3u4_02.png" alt="" /></figure>
</div>
<p>
Un punt important a tenir en compte en aplicar aquesta descomposició és que cadascun dels subproblemes no es genera arbitràriament, sinó que es planteja com un objectiu parcial, amb entitat pròpia, per resoldre el seu problema de nivell superior. Un cop assolits tots aquests objectius parcials, es considera resolt el total.
</p>

<p>

</p>

<p>
Els objectius finals d’aplicar aquesta estratègia són:
</p>
<ul>
<li class="level1"><div class="li"> Establir una relació senzilla entre problemes plantejats i el conjunt de tasques a fer per resoldre’ls. </div>
</li>
<li class="level1"><div class="li"> Establir més fàcilment les passes per resoldre un problema.</div>
</li>
<li class="level1"><div class="li"> Fer més fàcil d’entendre aquestes passes.</div>
</li>
<li class="level1"><div class="li"> Limitar els efectes de la interdependència que un conjunt de passes té sobre un altre conjunt.</div>
</li>
</ul>

</div>

<h3><a id="exemples_d_aplicacio_de_disseny_descendent" >Exemples d&#039;aplicació de disseny descendent</a></h3>
<div class="level3">

<p>
Com sempre, la millor manera de veure l’aplicació de disseny descendent és mitjançant exemples. Per començar, aquests se centraran en la resolució de problemes d’àmbit general, que permetin veure amb claredat el procés sigui quin sigui el context, abans d’entrar en el cas concret de la generació d’un programa.
</p>

</div>

<h4><a id="una_unitat_formativa" >Una unitat formativa</a></h4>
<div class="level4">

<p>
Un cas força directe d’aplicació de disseny descendent és l’escriptura d’un document de certa complexitat, com per exemple, un llibre o una unitat formativa de l’IOC. Es tracta d’un cas directe ja que l’estructura d’un document d’aquest tipus és evidentment jeràrquica, basada en capítols, seccions, subseccions, etc. Així, doncs, tot just davant vostre ara mateix teniu el resultat directe d’aplicar disseny descendent sobre un problema.
</p>
<div class="iocfigure"><a name="Figure2"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Descomposició d’una Unitat Formativa seguint el disseny descendent

</figcaption><img src="../media/ic10m3u4_03.png" alt="" /></figure>
</div>
<p>
En un cas com aquest, quan es planteja que cal fer una unitat formativa, tot i que es parteix ja d’unes directrius o idea general d’allò que es vol explicar (per exemple, uns objectius d’aprenentatge), estareu d’acord que no seria gaire assenyat seure ja immediatament davant d’un processador de text i posar-se a escriure, atacant frontalment el problema. Aquesta aproximació normalment porta a no saber ben bé per on començar, o simplement posar fi a un text incomprensible, amb fins i tot explicacions repetides. És més eficient començar amb una etapa de disseny en la qual s’estableixi un primer nivell d’objectius parcials en la redacció: una divisió inicial en apartats. Aquest primer nivell de descomposició de ben segur que encara serà massa genèric, però ja ha dividit el problema inicial en d’altres més petits.
</p>

<p>
Un cop arribats a aquest punt, per cada apartat, es van fent successives divisions en seccions, subseccions, etc. partint de conceptes més generals que es volen explicar cap a conceptes més específics. Un cop es considera que s’ha arribat a un concepte prou específic com per poder ser explicat de manera autocontinguda i de manera relativament fàcil d’entendre pel lector, ja no cal descompondre més. Evidentment, un cop tractats tots els apartats, és possible trobar-se que alguns apartats o seccions estan dividits en més subapartats que d’altres. Això no és problema. Ara bé, el que sí que ha de ser cert sempre és que cada subapartat es correspongui a una temàtica concreta, amb una entitat i sentit propi (d’acord al seu títol), i mai es tracta d’un “calaix de sastre” on s’expliquen moltes coses diferents poc relacionades entre elles. Per exemple, la <span class="figref"><a href="#Figure2"><span>figura</span></a></span> mostra la descomposició d’una unitat d’acord a aquests criteris.
</p>

<p>
Com es pot veure, en aquest cas, el resultat d’aplicar la descomposició us dóna com a resultat l’índex de la unitat. Estareu d’acord que és molt més senzill editar un document partint d’un índex preestablert, amb noms de seccions autoexplicatius sobre allò que han de tractar, que no pas actuant de manera improvisada. Addicionalment, aquest procés de descomposició assoleix una altra fita molt important que va més enllà de facilitar l’etapa de redacció del text. El document resultant també resulta molt més fàcil de seguir i entendre per part dels futurs lectors. 
</p>

</div>

<h4><a id="una_recepta_de_cuina" >Una recepta de cuina</a></h4>
<div class="level4">

<p>
Si bé l’exemple del document de text és pràcticament dels més directes que hi ha per il·lustrar com la divisió d’un problema en d’altres més petits és de gran ajut, hi ha un petit detall a tenir en compte. La majoria de documents de text, i és el cas de les unitats formatives, no descriuen pas algorismes, que és al cap i a la fi el que haureu de fer en un programa. Ara bé, hi ha prou que el text descrigui una seqüència de passes per dur a terme una fita perquè ja es converteixi en algorisme. Per exemple, un manual d’instruccions per muntar un moble o una recepta de cuina. En aquests casos, per fer la redacció, el procés general es divideix igualment en apartats i seccions que es corresponen a tasques individuals i concretes dins del procés general.
</p>

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10m3u4_04.png" class="imgB" title="Una recepta de cuina és un algorisme, i es pot descompondre usant disseny descendent (Font: jetalone)/-35" alt="Una recepta de cuina és un algorisme, i es pot descompondre usant disseny descendent (Font: jetalone)/-35" /></li><li><small>Una recepta de cuina és un algorisme, i es pot descompondre usant disseny descendent (Font: jetalone)</small></li>
</ul></div>

</p>

<p>
Per tant, el que es proposa fer, a mode d’exemple, és dur a terme un procés de descomposició en subproblemes d’una recepta de cuina de fideus japonesos <em>yakisoba</em> (<span class="inlinelatex"><img src="../media/imga47a9d0eaee2209cc663c77cfa596f3d.png" /></span>) sense carn. En un cas com aquest, el concepte de problema complex és relatiu, ja que tot depèn de les habilitats i coneixements culinaris del lector. Per no simplificar massa l’exemple, se suposarà que alguns aspectes com fregir o saltar no es consideren tasques simples, i cal tenir ben present el procés de preparació. La <span class="figref"><a href="#Figure3"><span>figura</span></a></span> mostra una proposta d’esquema de descomposició usant disseny descendent. El format emprat per establir el nivell de descomposició és el mateix que en l’exemple anterior. Estudieu-la atentament i dediqueu uns moments a reflexionar si vosaltres ho hauríeu fet d’una altra manera.
</p>
<div class="iocfigure"><a name="Figure3"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Descomposició de la preparació d’una recepta de cuina

</figcaption><img src="../media/ic10m3u4_05.png" alt="" /></figure>
</div>
<p>
Atès que aquest exemple sí que està expressant la descomposició d’un procés, hi ha alguns aspectes a tenir en compte. D’una banda, noteu com la nomenclatura usada per identificar cada subproblema indica clarament què es vol assolir, de manera que tant vosaltres com un tercer observador pot tenir una idea clara d’allò que cal resoldre per dur a terme la tasca final. Això és molt important. Ara bé, d’altra banda, si bé amb aquest identificador se sap “què” cal resoldre, no se sap “com” es resol cada subproblema. En aquest sentit, es considera que un subproblema és una abstracció sobre part del procés complet. Definir l’algorisme que resol cada subproblema individual serà ja l’etapa següent. 
</p>

<p>
Per exemple, un cop es té clara la descomposició, ja es podria decidir cercar l’algorisme per resoldre el subproblema “Preparar oli per fregir”, que podria ser:
</p>
<ol>
<li class="level1"><div class="li"> Agafar ampolla d’oli de gira-sol.</div>
</li>
<li class="level1"><div class="li"> Omplir paella fins a un terç.</div>
</li>
<li class="level1"><div class="li"> Posar foc al màxim.</div>
</li>
<li class="level1"><div class="li"> Mentre l’oli no s’escalfi.</div>
</li>
<li class="level1"><div class="li"> Esperar.</div>
</li>
</ol>

<p>
Noteu com, per resoldre aquest punt, no és necessari saber absolutament res de la resta del procés general. Això indica que cada subproblema del nivell més baix planteja un seguit de tasques totalment autocontigudes.  Aquest procés llavors s’aniria repetint per cada subproblema, normalment començant resolent els problemes més senzills (nivells inferiors), i anant a poc a poc resolent els més complexos (nivells superiors), fins a arribar al problema general, que és el de nivell més alt. 
</p>

<p>
Aquest ordre recomanat es deu al fet que, durant aquest procés, per resoldre subproblemes de nivells superiors, és possible referir-se a subproblemes de nivells inferiors. La millor manera de veure això és veient com es resoldria, per exemple, el subproblema “Fregir pastanagues”:
</p>
<ol>
<li class="level1"><div class="li"> <strong>Preparar oli per fregir</strong>.</div>
</li>
<li class="level1"><div class="li"> Agafar els bocins de pastanaga.</div>
</li>
<li class="level1"><div class="li"> <strong>Rossejar pastanagues</strong>.</div>
</li>
<li class="level1"><div class="li"> Treure-les de la paella.</div>
</li>
<li class="level1"><div class="li"> Desar en un plat.</div>
</li>
<li class="level1"><div class="li"> <strong>Netejar la paella</strong>. </div>
</li>
</ol>

<p>
Noteu com, per resoldre aquest subproblema, en els punts 1, 3 i 6 precisament s’està referint a subproblemes de nivell inferior, que es consideren resolts si seguim l’ordre de resolució descrit. També noteu com, per resoldre un subproblema, tant es poden usar subproblemes ja resolts de nivell inferior com passes addicionals que es considerin prou simples. Per tant, des del punt de vista d’ordre de les passes que s’estan seguint, el procés seguiria a grans trets el flux de control de la <span class="figref"><a href="#Figure4"><span>figura</span></a></span>.
</p>
<div class="iocfigure"><a name="Figure4"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Flux de control de l’algorisme basat en disseny descendent per fregir unes pastanagues

</figcaption><img src="../media/ic10m3u4_06.png" alt="" /></figure>
</div>
<p>
En aquesta figura, el punt més important és veure com cada subproblema es considera una entitat estrictament independent i autocontinguda dins de tot el procés, a la qual s’hi accedeix des d’un altre de nivell superior. Quan es fa, les seves passes són seguides d’inici a fi, i en acabar es continua exactament per on us havíeu quedat en el nivell superior.
</p>

</div>

<h3><a id="reutilitzacio_de_subproblemes_resolts" >Reutilització de subproblemes resolts</a></h3>
<div class="level3">

<p>
Els exemples de la unitat formativa o la recepta de cuina, a simple vista, aparenten seguir un esquema molt similar. Els diferents nivells segueixen una ordenació seqüencial (1, 1.1, 1.1.1 … 2, 2.1, etc.), de manera que, fet i fet, els subproblemes es van resolent de manera ordenada i un cop resolt el darrer subproblema, la tasca general està pràcticament finalitzada. Això encaixa amb el model estrictament jeràrquic del problema general descompost tal com s’ha exposat inicialment.
</p>

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10m3u4_07.png" class="imgB" title="Reaprofitant subproblemes resolts us estalvieu reinventar la roda. Font: Derek Ramsey/-7" alt="Reaprofitant subproblemes resolts us estalvieu reinventar la roda. Font: Derek Ramsey/-7" /></li><li><small>Reaprofitant subproblemes resolts us estalvieu reinventar la roda. Font: Derek Ramsey</small></li>
</ul></div>

</p>

<p>
Ara bé, la descomposició mitjançant disseny descendent permet fer ús d’una característica molt útil quan s’usa per dissenyar algorismes. Es tracta de la possibilitat de cercar subproblemes idèntics, o si més no força semblants, i reaprofitar la seva solució en més d’un lloc dins del problema general. Un cop s’han resolt una vegada, no tindria sentit tornar-los a resoldre de nou repetides vegades. Sobre aquesta circumstància, de moment s’estudiarà només el cas de subproblemes exactament iguals.
</p>

<p>
Per exemple, si us fixeu en la descomposició de la recepta de cuina, podeu observar que hi ha subproblemes repetits. Es tracta de “Preparar paella per fregir” i “Netejar paella”. No només s’han descrit ja d’entrada amb noms idèntics, sinó que, si us pareu a pensar, les passes que engloben també ho seran. Els elements que es manipulen per a la seva resolució (paella i oli) i la manera com es fa aquesta manipulació són exactament els mateixos. Per tant, un cop s’han definit les passes per resoldre’l la primera vegada, ja no cal tornar-ho a fer.
</p>

<p>
Aneu amb compte, ja que per considerar que dues solucions són idèntiques, els elements que intervenen han de ser exactament els mateixos. Així, doncs, “Tallar cebes” i “Tallar pastanagues” són certament subproblemes molt semblants, però no realment idèntics, ja que es manipulen elements diferents.
</p>

<p>
Un cop detectada aquesta característica del disseny descendent, és el moment de matisar la descripció de descomposició en nivells de la <span class="figref"><a href="#Figure1"><span>figura</span></a></span>. En realitat, el procés és més aviat semblant al que descriu la <span class="figref"><a href="#Figure5"><span>figura</span></a></span>, la qual indica un canvi de plantejament, ja que qualsevol subproblema d’un nivell donat pot ser part de qualsevol subproblema d’un nivell superior. Per remarcar aquest fet, a la figura cada subproblema no s’enumera usant un índex associat al subproblema de nivell superior on pertany, sinó directament d’acord al nivell on pertany. No hi ha exclusivitat dins la jerarquia.
</p>
<div class="iocfigure"><a name="Figure5"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Esquema d’aplicació de disseny descendent amb subproblemes repetits

</figcaption><img src="../media/ic10m3u4_08.png" alt="" /></figure>
</div>
<p>
Aquesta circumstància també fa que, a l’hora de considerar el flux de control de l’algorisme, aquest adopti una forma especial. Per resoldre dues tasques diferents es comparteix un mateix conjunt de passes, tal com mostra la <span class="figref"><a href="#Figure6"><span>figura</span></a></span>, per al cas tot just esmentat. Aquest fet és important que el tingueu ben present, ja que té conseqüències molt directes a l’hora d’implementar un algorisme quan es tracta d’un programa d’ordinador.
</p>
<div class="iocfigure"><a name="Figure6"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Flux de control de l’algorisme basat en disseny descendent per fregir pastanagues o cebes

</figcaption><img src="../media/ic10m3u4_09.png" alt="" /></figure>
</div><div class="iocimportant"><div class="ioccontent">
<p>
En conclusió, en descompondre un problema, és especialment encertat intentar fer-ho de manera que es forci l’aparició de subproblemes repetits, i així la seva resolució es pot reaprofitar en diversos llocs.
</p>
</div></div>
</div>

<h3><a id="aplicacio_correcta_del_disseny_descendent" >Aplicació correcta del disseny descendent</a></h3>
<div class="level3">

<p>
Un aspecte que heu de tenir en compte en aplicar disseny descendent és que es tracta d’una estratègia basada en unes directrius generals per atacar problemes complexos, però no és cap esquema determinista que us garanteixi que sempre obtindreu la millor solució. Això vol dir que, partint d’un mateix problema, diferents persones poden arribar a conclusions diferents sobre com dur a terme la descomposició. D’entre totes les solucions diferents possibles, algunes es poden considerar millors que d’altres. De fet, res impedeix, a partir ja una solució concreta, aplicar refinaments que la millorin. Per tant, és interessant poder avaluar si la descomposició que heu fet va per bon camí o no.
</p>

<p>
Alguns dels criteris en que us podeu basar per fer aquesta avaluació són els següents:
</p>
<ul>
<li class="level1"><div class="li"> Si un problema que sembla <em>a priori</em> força complex es descompon en molts pocs nivells, potser val la pena fer una segona ullada. Inversament, si un problema no massa complex té massa nivells, potser s’ha anat massa lluny en la descomposició.</div>
</li>
<li class="level1"><div class="li"> Veure si el nombre de passes incloses a cadascun dels subproblemes no és excessivament gran i és fàcil de seguir i entendre. En cas contrari, potser encara faria falta aplicar nous nivells de descomposició.</div>
</li>
<li class="level1"><div class="li"> Repassar que els noms assignats als subproblemes siguin autoexplicatius i expressin clarament la tasca que estan resolent. Sense ni tan sols llegir les seves passes, caldria entendre perfectament què s’assoleix en resoldre’ls. En cas contrari, potser la descomposició no està agrupant conjunts de passes realment relacionades entre elles.</div>
</li>
<li class="level1"><div class="li"> Si absolutament cap dels subproblemes és reutilitzat enlloc, especialment en descomposicions en molts nivells, és molt possible que no s’hagi triat correctament la manera de descompondre alguns subproblemes.</div>
</li>
<li class="level1"><div class="li"> Vinculat al punt anterior, l’aparició de subproblemes molt semblants o idèntics, però tractats per separat en diferents llocs, també sol ser indici que no s’està aplicant la capacitat de reutilitzar subproblemes correctament.</div>
</li>
</ul>

</div>

<h2><a id="disseny_descendent_aplicat_a_la_creacio_de_programes" >Disseny descendent aplicat a la creació de programes</a></h2>
<div class="level2">

<p>
Un cop disposeu d’un marc de referència general sobre com aplicar disseny descendent, és el moment d’aplicar la mateixa tècnica per a la creació d’un programa. Per començar, es mostra l’aplicació de disseny descendent sobre un programa de complexitat baixa i que ja coneixeu, de manera que el resultat de la descomposició sigui molt simple. Aquest serveix com a fil argumental per poder analitzar alguns dels aspectes importants del disseny descendent i veure com és possible implementar la descomposició en subproblemes resultants, d’acord a la sintaxi del llenguatge Java.
</p>

<p>
El problema del que es parteix és, o hauria de ser, un conegut vostre: un programa que, a partir d’una llista de 10 valors enters, els mostri per pantalla ordenats. 
</p>

<p>
Abans de començar, és una bona idea pensar quina mena de dades cal manipular i com s’emmagatzemaran, ja que això us permetrà avaluar en cada pas de la descomposició si un problema és massa complex encara o no. En aquest cas cal manipular una llista d’enters, per la qual cosa el més assenyat seria emmagatzemar-la en forma d’un <em>array</em>.
</p>

<p>
Com s’ha vist per al cas general d’aplicació de disseny descendent, una bona manera de descompondre el problema en subproblems és establir quines són les parts diferenciades, o etapes, que el composen. Cada etapa es correspondrà a un subproblema que cal resoldre. El més important en aquest pas és que cada subproblema correspongui sempre a una tasca concreta amb un objectiu a resoldre clarament diferenciat. Ha de ser fàcil assignar-li un nom. En cas contrari, segurament no s’està fent bé la descomposició.
</p>

<p>
Per a aquest programa, es pot considerar que el divideix en tres parts, o subproblemes, a resoldre:
</p>
<ul>
<li class="level1"><div class="li"> llegir la llista d’enters,</div>
</li>
<li class="level1"><div class="li"> ordenar-la, i</div>
</li>
<li class="level1"><div class="li"> mostrar-la per pantalla.</div>
</li>
</ul>

<p>
Un cop arribats a aquest primer nivell de descomposició, és el moment de plantejar-se si cada subproblema és massa complex o no. En aquest cas, se suposa que ja domineu el conjunt d’instruccions que calen, com llegir una llista d’enters de longitud coneguda (desant-los en un <em>array</em>), com ordenar un <em>array</em> (usant l’algorisme de la bombolla) i com mostrar-lo per pantalla (mitjançant un recorregut). Per tant, es pot considerar que tots els subproblemes plantejats no són excessivament complexos i el procés de descomposició acaba.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
No totes les descomposicions han de tenir sempre molts nivells. Si el programa és simple, n’hi haurà pocs.
</p>
</div></div>
</div>

<h3><a id="declaracio_de_metodes" >Declaració de mètodes</a></h3>
<div class="level3">

<p>
Un cop descompost el problema general, és el moment de crear el programa que el resol mitjançant codi font. Per això, caldrà decidir, per a cadascun dels subproblemes que s’han detectat, quines instruccions cal executar per resoldre’l individualment. Els llenguatges de programació permeten una implementació directa d’aquest procés, en oferir mecanismes per agrupar o catalogar blocs d’instruccions i etiquetar-los amb un identificador, d’acord al seu subproblema associat.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
En general dins dels llenguatges de programació, s’anomena una <strong>funció</strong> a un conjunt d’instruccions amb un objectiu comú que es declaren de manera explícitament diferenciada dins del codi font mitjançant una etiqueta o identificador.
</p>
</div></div>
<p>
Per tant, per cada subproblema a resoldre, dins del vostre codi font s’haurà de definir una funció diferent. En el llenguatge Java, aquests conjunts d’instruccions se’ls anomena <strong>mètodes</strong>, en lloc de funcions, però a efectes pràctics, els podeu considerar el mateix. Aquest terme no és nou, ja que ha estat usat amb anterioritat sota dos contextos diferents, si bé mai s’havia entrat en molt de detall en la seva descripció ni s’havia justificat el seu format.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
En algunes parts de la literatura, a les funcions que compleixen certes propietats se les anomena <em>accions</em>.
</p>
</div></div><ul>
<li class="level1"><div class="li"> Quan es parla de <strong>mètode principal</strong>, es tracta d’un conjunt d’instruccions que, etiquetades sota un identificador anomenat <em>main</em>, resolen el problema general (o sigui, tot el programa). Atès que fins al moment no s’havia aplicat disseny descendent, no hi havia subproblemes, i per tant en el vostre codi font només hi havia definit aquest únic mètode. No en calia cap altre.</div>
</li>
<li class="level1"><div class="li"> Quan es parla de la <strong>invocació d’un mètode</strong> sobre valors de certs tipus de dades complexos, com les cadenes de text (<code>String</code>), es tracta d’executar un conjunt d’instruccions amb un objectiu comú: transformar la cadena de text o obtenir dades contingudes.</div>
</li>
</ul>

<p>
Com podeu veure, tot i no haver entrat en detall, la manera com s’han usat fins al moment els mètodes és coherent amb la definició que tot just s’ha presentat. A partir d’ara començareu a estudiar-los amb més profunditat.
</p>

<p>
La declaració bàsica d’un mètode es fa usant la sintaxi que es mostra tot seguit. Com podeu veure, el seu format és molt semblant a com es declara el mètode principal (però no exactament igual, alerta!):
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  public void nomMetode() {</div></li><li class="li1"><div class="de1">    //Aquí dins aniran les seves instruccions  </div></li><li class="li1"><div class="de1">    //...</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>

<p>
Aquesta declaració es pot dur a terme en qualsevol lloc del fitxer de codi font, sempre que sigui entre les claus que identifiquen l’inici i fi de fitxer (<code>public class NomClasse { … }</code>)  i fora del bloc d’instruccions mètode principal, o qualsevol altre mètode. Normalment, se sol fer immediatament a continuació del mètode principal. La declaració ha de seguir exactament aquest format. L’única part que podeu modificar és <code>nomMetode</code>, que no és més que un identificador, com el d’una variable, i per tant podeu triar el que vulgueu. Tot i així, sempre hauríeu de procurar usar algun text que sigui autoexplicatiu.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Els identificadors dels mètodes segueixen les mateixes convencions de codi que les variables (lowerCamelCase).
</p>
</div></div>
<p>
D’acord a la descomposició proposada, dins el codi font del programa d’ordenació hi haurà declarats tres mètodes, un associat a cada subproblema. Aquests podrien ser:
</p>

<p>

</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class OrdenarDescendent {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    //Instruccions del mètode principal (problema general)</div></li><li class="li1"><div class="de1">    //...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode que resol el subproblema de llegir la llista.</div></li><li class="li1"><div class="de1">  public void llegirLlista() {</div></li><li class="li1"><div class="de1">    //Instruccions del mètode</div></li><li class="li1"><div class="de1">    //...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode que resol el subproblema d'ordenar la llista.</div></li><li class="li1"><div class="de1">  public void ordenarLlista() {</div></li><li class="li1"><div class="de1">    //Instruccions del mètode</div></li><li class="li1"><div class="de1">    //...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode que resol el subproblema de mostrar la llista per pantalla.</div></li><li class="li1"><div class="de1">  public void mostrarLlista() {</div></li><li class="li1"><div class="de1">    //Instruccions del mètode</div></li><li class="li1"><div class="de1">    //...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h3><a id="canvis_en_el_metode_principal_en_declarar_altres_metodes" >Canvis en el mètode principal en declarar altres mètodes</a></h3>
<div class="level3">

<p>
Abans de continuar, cal presentar un canvi necessari en el format dels vostres programes quan es vol declarar altres mètodes, associats a subproblemes, a part del mètode principal. 
</p>

<p>
Concretament, per les característiques del llenguatge Java, cal que el mètode principal tingui un format molt concret. En cas contrari, hi haurà un error de compilació en futures passes del procés. Tot el codi que aniria normalment dins el bloc d’instruccions del mètode principal s’ubica en un nou mètode auxiliar, i dins el mètode principal simplement s’invoca aquest nou mètode. De fet, no és imprescindible que conegueu els detalls dels motius pels quals és necessari fer aquest canvi. Simplement podeu usar el codi següent d’exemple com a plantilla per generar els vostres programes, tenint en compte que tot el codi que posaríeu normalment al mètode principal, ara anirà al mètode <code>inici</code>.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Per diferenciar els mètodes que resolen subproblemes del mètode principal, i evitar confusions, podeu referir-vos-hi com a <em>mètodes auxiliars</em>.
</p>
</div></div><pre class="code java"><ol><li class="li1"><div class="de1">public class OrdenarDescendent {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    //Aquí cal usar el nom de la classe que esteu creant.</div></li><li class="li1"><div class="de1">    OrdenarDescendent programa = new OrdenarDescendent();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    //Instruccions del mètode principal (problema general)</div></li><li class="li1"><div class="de1">    //...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Resta de mètodes</div></li><li class="li1"><div class="de1">  //...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
En usar aquest codi com a plantilla, noteu que a la línia següent caldria posar el nom de la classe que esteu editant, en lloc de <code>OrdenarDescendent</code>:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">OrdenarDescendent programa = new OrdenarDescendent();</div></li></ol></pre>

</div>

<h3><a id="accessibilitat_de_variables_dins_una_classe" >Accessibilitat de variables dins una classe</a></h3>
<div class="level3">

<p>
En el moment que s’aplica disseny descendent i les parts del codi d’un programa es descomponen amb mètodes, apareix un problema. Els diferents mètodes que definiu serveixen per processar una informació comuna a tots tres, en aquest cas, la llista d’enters, en forma d’<em>array</em>. Això vol dir que us caldrà manipular aquesta variable en els diferents mètodes, de manera que els seus valors siguin compartits i accessibles per tots ells. Ara bé, abans de començar, caldrà decidir exactament a on es declararà. 
</p>

<p>
Per prendre correctament aquesta decisió cal fer memòria i recordar el concepte d’àmbit d’una variable: donada una variable, només es considerarà declarada des de la línia on s’ha fet fins a trobar la clau tancada següent (<strong>}</strong>). Si us hi fixeu, la conseqüència directa d’això és que, atès que cada mètode pren la forma d’un bloc d’instruccions tancat entre claus (<strong>{ … }</strong>), si una variable es declara dins d’algun mètode, sigui quin sigui, aquesta no es considerà declarada en cap dels altres.
</p>

<p>
Hi ha diferents maneres de solucionar aquest problema. De moment en veureu la més simple. Qualsevol dada que hagi de ser accedida en més d’un subproblema per tal de resoldre’l, caldrà declarar-la com una variable global.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Una <strong>variable global</strong> és una variable que pot ser accedida des de qualsevol instrucció dins un mateix fitxer de codi font. El seu àmbit és tot el fitxer.
</p>
</div></div>
<p>
En contraposició a les variables globals, hi ha les variables <em>locals</em>, que són les que heu usat fins ara: variables amb un àmbit local en un bloc concret de codi.
</p>

<p>
En Java, la sintaxi per declarar una variable global és molt semblant a la que s’ha vist fins ara, només varia el fet que cal afegir la paraula clau <code>private</code> abans de la declaració i el lloc on declarar-la. Aquest darrer punt és, de fet, el més important si voleu que una variable es consideri global.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">private tipus nomVariable = valorInicial;</div></li></ol></pre>

<p>
En aquest cas, la declaració s’ha de fer fora de tots els mètodes, però dins del bloc de claus que delimita la classe, exactament igual que quan declareu constants. Per exemple, si es vol declarar un <em>array</em> d’enters anomenat <strong>llistaEnters</strong>, es podria fer:
</p>

<p>

</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class OrdenarDescendent {</div></li><li class="li1"><div class="de1">  //Variable global</div></li><li class="li1"><div class="de1">  private int[] llistaEnters = new int[10];</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    OrdenarDescendent programa = new OrdenarDescendent();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    //Instruccions del mètode principal (problema general)</div></li><li class="li1"><div class="de1">    //...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per llegir la llista.</div></li><li class="li1"><div class="de1">  public void llegirLlista() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per ordenar la llista.</div></li><li class="li1"><div class="de1">  public void ordenarLlista() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per mostrar la llista per pantalla.</div></li><li class="li1"><div class="de1">  public void mostrarLlista() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
En ser global, la variable <code>llistaEnters</code> serà accessible des de qualsevol instrucció dins del codi. Val la pena remarcar que en Java no és imprescindible declarar-la a l’inici del codi font per poder ser usada lliurement. Per exemple, si es declarés a la darrera línia, tot just després de la declaració del mètode <code>mostrarLlista</code>, es continuaria considerant declarada per a tot el fitxer. Això és una lleugera diferència respecte a les variables locals, que només tenen vigència a partir de la línia de codi on s’han declarat. De totes maneres, per convenció, se solen declarar al principi de tot, de manera que el codi queda ordenat: primer variables globals i constants, i després mètodes.
</p>

<p>
Abans de continuar, és important remarcar que l’ús de variables globals només es considera polit en casos com aquest, on hi ha una dada que ha de ser manipulada en diferents subproblemes. Per a altres dades d’ús limitat a un únic mètode (comptadors o semàfors de bucles, resultats temporals d’operacions, etc.), caldrà declarar-les en el bloc de codi corresponent i mai com una variable global.
</p>

</div>

<h3><a id="codificacio_de_metodes" >Codificació de mètodes</a></h3>
<div class="level3">

<p>
Un cop ja es disposa del mètode principal adaptat, les dades generals del programa declarades com variables globals i la declaració d’un mètode associat a cada suproblema resultant la descomposició del problema general, ja podeu procedir a escriure les instruccions de cada mètode. En aquest aspecte, les claus que delimiten un mètode (<code>public void nomMetode() { … }</code>) conformen el bloc d’instruccions que resol aquell problema concret. 
</p>

<p>
L’ordre en el qual caldrà resoldre’l és per nivells de descomposició, normalment començant pel nivell més baix, ja que és el més intuïtiu. Per les característiques de la descomposició mitjançant disseny descendent, si l’heu aplicat correctament, la resolució de cada mètode hauria de ser una tasca totalment autocontinguda i independent. Per tant, hauríeu de poder resoldre en qualsevol ordre els mètodes associats a problemes d’un mateix nivell de descomposició. Si apareix alguna dependència, és que la descomposició no és correcta.
</p>

<p>

</p>

<p>
En el cas de l’exemple, només hi ha dos nivells, el problema general i el primer nivell de descomposició. En el nivell més baix, el mètode <code>llegirLlista</code> tindrà les instruccions que llegeixen 10 enters des del teclat i els desen a l’<em>array</em>, el mètode <strong>ordenarLlista</strong>, les que ordenen l’<em>array</em> i el mètode <code>mostrarLlista</code>, les que el mostren per pantalla. Per tant, el codi podria ser:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class OrdenarDescendent {</div></li><li class="li1"><div class="de1">  int[] llistaEnters = new int[10];</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    OrdenarDescendent programa = new OrdenarDescendent();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    //Instruccions del mètode principal (problema general)</div></li><li class="li1"><div class="de1">    //...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per llegir la llista.</div></li><li class="li1"><div class="de1">  public void llegirLlista() {</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Escriu 10 valors enters i prem retorn.&quot;);</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    int index = 0;</div></li><li class="li1"><div class="de1">    while (index &lt; llistaEnters.length) {</div></li><li class="li1"><div class="de1">      if (lector.hasNextInt()) {</div></li><li class="li1"><div class="de1">        llistaEnters[index] = lector.nextInt();</div></li><li class="li1"><div class="de1">        index++;</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per ordenar la llista.</div></li><li class="li1"><div class="de1">  public void ordenarLlista() {</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaEnters.length - 1; i++) {</div></li><li class="li1"><div class="de1">      for(int j = i + 1; j &lt; llistaEnters.length; j++) {</div></li><li class="li1"><div class="de1">        //La posició tractada té un valor més alt que el de la cerca... Els intercanviem.</div></li><li class="li1"><div class="de1">        if (llistaEnters[i] &gt; llistaEnters[j]) {</div></li><li class="li1"><div class="de1">          //Per intercanviar valors cal una variable auxiliar</div></li><li class="li1"><div class="de1">          int canvi = llistaEnters[i];</div></li><li class="li1"><div class="de1">          llistaEnters[i] = llistaEnters[j];</div></li><li class="li1"><div class="de1">          llistaEnters[j] = canvi;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per mostrar la llista per pantalla.</div></li><li class="li1"><div class="de1">  public void mostrarLlista() {</div></li><li class="li1"><div class="de1">    System.out.print(&quot;L'array ordenat és: [ &quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaEnters.length;i++) {</div></li><li class="li1"><div class="de1">      System.out.print(llistaEnters[i] + &quot; &quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println(&quot;]&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h3><a id="invocacio_de_metodes" >Invocació de mètodes</a></h3>
<div class="level3">

<p>
Un cop resolts tots el mètodes d’un nivell donat, es pot procedir a resoldre els del nivell superior. Ara bé, en fer-ho, recordeu que teniu la possibilitat d’usar la solució de qualsevol subproblema de nivell inferior. Per exemple, aquest era el cas d’aprofitar saber preparar l’oli a la paella per solucionar com fregir les pastanagues a la recepta de cuina. 
</p>

<p>

</p>

<p>
Dins del codi font, això es fa <em>invocant</em> algun dels mètodes que heu codificat. Per fer-ho, només cal posar una instrucció que conté el nom del mètode a invocar, dos parèntesis i el punt i coma de final de sentència. O sigui:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">nomMetode();</div></li></ol></pre>

<p>
A efectes pràctics, cada cop que s’invoca un mètode, el programa executa les instruccions que hi ha codificades dins aquell mètode, des de la primera fins a la darrera. Quan acaba d’executar la darrera instrucció del mètode, llavors el programa procedeix a executar la línia immediatament posterior a la invocació al mètode.
</p>

<p>

</p>

<p>
Si torneu a l’exemple, ara ja només us quedaria completar el codi associat al problema general (mètode <strong>inici</strong>). Per fer-ho, és possible invocar a <strong>llegirLLista</strong>, <strong>ordenarLlista</strong> i <strong>mostrarLlista</strong>. Donat aquest fet, el programa final ja seria el següent. Compileu-lo i executeu-lo per veure que és així.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class OrdenarDescendent {</div></li><li class="li1"><div class="de1">  int[] llistaEnters = new int[10];</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    OrdenarDescendent programa = new OrdenarDescendent();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    llegirLlista();</div></li><li class="li1"><div class="de1">    ordenarLlista();</div></li><li class="li1"><div class="de1">    mostrarLlista();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per llegir la llista.</div></li><li class="li1"><div class="de1">  public void llegirLlista() {</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Escriu 10 valors enters i prem retorn.&quot;);</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    int index = 0;</div></li><li class="li1"><div class="de1">    while (index &lt; llistaEnters.length) {</div></li><li class="li1"><div class="de1">      if (lector.hasNextInt()) {</div></li><li class="li1"><div class="de1">        llistaEnters[index] = lector.nextInt();</div></li><li class="li1"><div class="de1">        index++;</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per ordenar la llista.</div></li><li class="li1"><div class="de1">  public void ordenarLlista() {</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaEnters.length - 1; i++) {</div></li><li class="li1"><div class="de1">      for(int j = i + 1; j &lt; llistaEnters.length; j++) {</div></li><li class="li1"><div class="de1">        //La posició tractada té un valor més alt que el de la cerca... Els intercanviem.</div></li><li class="li1"><div class="de1">        if (llistaEnters[i] &gt; llistaEnters[j]) {</div></li><li class="li1"><div class="de1">          //Per intercanviar valors cal una variable auxiliar</div></li><li class="li1"><div class="de1">          int canvi = llistaEnters[i];</div></li><li class="li1"><div class="de1">          llistaEnters[i] = llistaEnters[j];</div></li><li class="li1"><div class="de1">          llistaEnters[j] = canvi;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per mostrar la llista per pantalla.</div></li><li class="li1"><div class="de1">  public void mostrarLlista() {</div></li><li class="li1"><div class="de1">    System.out.print(&quot;L'array ordenat és: [ &quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaEnters.length;i++) {</div></li><li class="li1"><div class="de1">      System.out.print(llistaEnters[i] + &quot; &quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println(&quot;]&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Un cop ja disposeu de tot el marc de referència sobre com queda distribuït un programa generat per la descomposició del problema usant disseny descendent, és interessant veure també quin és el flux de control de les instruccions quan aquest executa la invocació a un mètode. Això es mostra a la <span class="figref"><a href="#Figure7"><span>figura</span></a></span> per al cas de la invocació al mètode <code>llegirLlista</code>.
</p>

<p>
<strong>Repte 1:</strong> Modifiqueu el programa d’exemple de manera que faci el següent. Després de mostrar la llista ordenada, en una nova línia, ha de dir quants dels valors són inferiors a la meitat del valor més gran emmagatzemat. Apliqueu disseny descendent per afegir aquesta nova tasca, declarant i invocant els nous mètodes que faci falta.
</p>
<div class="iocfigure"><a name="Figure7"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Flux de control de les instruccions quan s’invoca el mètode llegirLlista.

</figcaption><img src="../media/ic10m3u4_10.png" alt="" /></figure>
</div>
</div>

<h3><a id="inicialitzacio_diferida_de_variables" >Inicialització diferida de variables</a></h3>
<div class="level3">

<p>
La necessitat de declarar variables globals comporta una problemàtica en uns casos molt específics. Fins ara, en el moment de declarar una variable, immediatament li heu assignat un valor inicial. Aquest valor podia ser tant el resultat d’assignar directament un literal, com una expressió o una entrada de dades per part de l’usuari. Ara bé, en declarar una variable com a global, només pot ser inicialitzada directament mitjançant un literal o expressions on s’usen altres variables globals. No hi ha la possibilitat de fer-ho mitjançant un valor que depengui d’una entrada, per teclat o dels arguments del mètode principal. Això significa que la declaració de la variable i l’assignació del valor que es vol tractar realment no es pot fer a la mateixa instrucció. Tot i així, sempre que es declara una variable cal assignar-li un valor inicial.
</p>

<p>
Per al cas de variables de tipus primitius, resoldre aquest problema és simple. Per convenció, se li assigna inicialment el valor 0 i més endavant ja se sobreescriurà el seu valor amb un altre vàlid. Ara bé, per al cas de variables complexes (com les de tipus <em>array</em> o <strong>String</strong>), cal assignar un valor especial que en Java s’anomena <strong>null</strong>. Aquesta cadena de text és una paraula reservada del llenguatge que serveix per dir que, de moment, la variable està declarada però més endavant ja se li assignarà un valor correcte, tan aviat com sigui possible.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Operar amb qualsevol variable de tipus complex amb un valor <code>null</code> assignat <strong>sempre</strong> resultarà en un programa erroni.
</p>
</div></div>
<p>

</p>

<p>
Per exemple, suposeu que voleu modificar el programa anterior de manera que, en lloc d’entrar deu valors pel teclat, en podeu entrar un nombre arbitrari. A partir de la seqüència escrita, el primer valor indicarà quants enters cal llegir tot seguit pel teclat. En un cas com aquest, és impossible inicialitzar l’<em>array</em> amb una mida concreta, ja que aquesta depèn d’una entrada pel teclat. Però el programa requereix que aquest sigui declarat com una variable global. Per tant, cal diferir la inicialització.
</p>

<p>
El codi que resol aquesta situació seria el següent. Atès que llegir la seqüència d’enters del teclat ara és un problema més complex, cal llegir la mida i els valors. S’ha aplicat disseny descendent per dividir-lo en dos subproblemes: llegir la mida de la seqüència i la seqüencia pròpiament. Comproveu que funciona en el vostre entorn de treball.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  //Variable global. Array no inicialitzat.</div></li><li class="li1"><div class="de1">  private int[] llistaEnters = null;</div></li><li class="li1"><div class="de1">  //En aplicar disseny descendent, ara cal declarar &quot;lector&quot; com a global</div></li><li class="li1"><div class="de1">  Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    OrdenarDescendentVariable programa = new OrdenarDescendentVariable();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    llegirLlista();</div></li><li class="li1"><div class="de1">    ordenarLlista();</div></li><li class="li1"><div class="de1">    mostrarLlista();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per llegir la llista.</div></li><li class="li1"><div class="de1">  //El primer valor sera la llargària</div></li><li class="li1"><div class="de1">  public void llegirLlista() {</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Escriu una llista de valors enters i prem retorn.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;El primer valor indica la mida de la seqüència.&quot;);</div></li><li class="li1"><div class="de1">    llegirMida();</div></li><li class="li1"><div class="de1">    llegirValors();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void llegirMida() {        //Metode que llegeix el primer valor</div></li><li class="li1"><div class="de1">    //Lectura</div></li><li class="li1"><div class="de1">    int mida = 0;</div></li><li class="li1"><div class="de1">    if (lector.hasNextInt()) {</div></li><li class="li1"><div class="de1">      mida = lector.nextInt();</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      lector.next();</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    llistaEnters = new int[mida];   //Inicialitizació diferida de l'array</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void llegirValors() {</div></li><li class="li1"><div class="de1">    int index = 0;</div></li><li class="li1"><div class="de1">    while (index &lt; llistaEnters.length) {</div></li><li class="li1"><div class="de1">      if (lector.hasNextInt()) {</div></li><li class="li1"><div class="de1">        llistaEnters[index] = lector.nextInt();</div></li><li class="li1"><div class="de1">        index++;</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">  }                                 //La resta de mètodes no canvien ...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h2><a id="un_exemple_mes_complex" >Un exemple més complex</a></h2>
<div class="level2">

<p>
Un cop ja s’ha vist un exemple senzill d’aplicació de disseny descendent, bàsicament amb l’objectiu d’introduir la sintaxi per a la declaració de mètodes i variables globals en Java, és el moment de proposar-ne un altre de més complex, que requereixi diversos graus de descomposició. 
</p>

<p>
El que es vol fer és un gestor de registre de temperatures preses setmanalment per un observatori. Es pressuposa que el programa es posa en marxa a l’inici de l’any (1 de gener) i al principi de cada setmana. Al llarg de 52 setmanes que té un any, es van enregistrant les temperatures mesurades cada dia de la setmana anterior (o sigui, set en total cada vegada). Cada cop que es fa un registre, sabent que ha passat una setmana, el programa calcula automàticament quin dia i mes és l’actual. A partir d’aquestes dades, és possible consultar en qualsevol moment quina ha estat la temperatura mitjana i la diferència entre el valor màxim i mínim enregistrats. En fer-ho, la data actual també es mostra en pantalla. 
</p>

<p>
Totes aquestes accions es porten a terme usant un menú. Evidentment, l’aplicació ha de ser prou robusta com per tractar casos erronis (per exemple, consultar valors quan encara no hi ha cap data enregistrada, o intentar registrar com a temperatura valors de tipus incorrecte). 
</p>

<p>
Per deixar més clar el comportament esperat, tot seguit es mostra un prototip del que s’esperaria mostrar amb la seva execució:
</p>
<pre class="code">
Benvingut al registre de temperatures
-------------------------------------
[RT] Registrar temperatures setmanals.
[MJ] Consultar temperatura mitjana.
[DF] Consultar diferència màxima.
[FI] Sortir.
Opció: MJ
No hi ha temperatures registrades.

Benvingut al registre de temperatures
-------------------------------------
[RT] Registrar temperatures setmanals.
[MJ] Consultar temperatura mitjana.
[DF] Consultar diferència màxima.
[FI] Sortir.
Opció: RT
Escriu les temperatures d&#039;aquesta setmana:
20,5 21,1 21 21,7 20,9 20,6 19,9

Benvingut al registre de temperatures
-------------------------------------
[RT] Registrar temperatures setmanals.
[MJ] Consultar temperatura mitjana.
[DF] Consultar diferència màxima.
[FI] Sortir.
Opció: MJ
Fins avui 8 de gener la mitjana ha estat de 20.814285 graus.

Benvingut al registre de temperatures
-------------------------------------
[RT] Registrar temperatures setmanals.
[MJ] Consultar temperatura mitjana.
[DF] Consultar diferència màxima.
[FI] Sortir.
Opció: DF
Fins avui 8 de gener la diferència màxima ha estat de 1.8000011 graus.

Benvingut al registre de temperatures
-------------------------------------
[RT] Registrar temperatures setmanals.
[MJ] Consultar temperatura mitjana.
[DF] Consultar diferència màxima.
[FI] Sortir.
Opció: FI</pre>

</div>

<h3><a id="descomposicio_de_problema" >Descomposició de problema</a></h3>
<div class="level3">

<p>
Un cop s’ha plantejat amb cert detall el problema a resoldre (què ha de fer el programa), és possible iniciar la descomposició mitjançant disseny descendent. Per veure amb més detall el procés, aquesta vegada s’anirà fent a poc a poc i nivell per nivell.
</p>

<p>
<strong>1. Identificació de les dades a tractar</strong>
</p>

<p>
Abans de començar la descomposició, com a pas previ, és interessant establir quina mena de dades cal manipular i com emmagatzemar-les dins el programa. D’aquesta manera, resulta més fàcil avaluar per cada subproblema què ha de dur a terme i si es tracta d’una tasca complexa o no. En aquest cas, cal gestionar d’una llista de temperatures, que es pot emmagatzemar usant un <em>array</em> de reals, i una data dins un mateix any, que es pot emmagatzemar usant dos enters, dia i mes. L’<em>array</em> haurà de tenir espai per emmagatzemar els valors dels dies a 52 setmanes (52*7 = 364) i caldrà controlar el fet que hi ha posicions “buides” i d’altres amb valors correctes assignats. Per exemple, després de la primera setmana només els 7 primers valors, les posicions 0 a 6, són vàlids. La resta de posicions no tenen valors vàlids assignats.
</p>

<p>
Quan arribi el moment caldrà considerar si declarar-les com a variables globals, depenent de si aquestes dades s’usen dins de més d’un subproblema o no.
</p>

<p>
<strong>2. Primer nivell de descomposició</strong>
</p>

<p>
El resultat d’aplicar el primer nivell de descomposició pot resultar en molts o pocs subproblemes depenent del grau de granularitat amb què decidiu tractar les tasques que realitza el programa. Inicialment, és recomanable no usar una granularitat alta i mantenir un nivell d’abstracció alt. Normalment, és important no baixar ràpidament de nivell i començar a resoldre problemes molt concrets en una sola passada. Una estratègia per evitar això es plantejar-se quines accions cal emprendre abans de poder-ne dur a terme unes altres.
</p>

<p>
Partint de la descripció del problema, una possible descomposició en nivells seria la següent, encara força general. El programa bàsicament és una estructura de repetició que va iterant sobre aquestes dues tasques:
</p>
<ul>
<li class="level1"><div class="li"> Mostrar menú.</div>
</li>
<li class="level1"><div class="li"> Tractar ordre.</div>
</li>
</ul>

<p>
Aquestes iteracions s’aniran repetint fins a complir la condició que vol finalitzar el programa. D’entrada, es pot decidir que això es durà a terme amb una variable de control de tipus semàfor.
</p>

<p>
Fins a cert punt, per a un dissenyador novell, seria comprensible proposar ja en el primer nivell resoldre subproblemes tals com el càlcul de les temperatures mínimes i màximes, ja que són aspectes que ressalten clarament a l’enunciat. Però si reflexioneu, us adonareu que per poder dur a terme aquestes tasques hi ha condicions prèvies que abans cal complir: que l’usuari hagi seleccionat una opció. Per tant, això vol dir que gestionar el menú i executar les opcions té relació de jerarquia dins el disseny: primer llegiu l’opció i després l’executeu. Per tant, no es troben en el mateix nivell.
</p>

<p>
<strong>3. Segon nivell de descomposició</strong>
</p>

<p>
Per veure si cal un segon nivell cal avaluar si els subproblemes proposats en el primer nivell són massa complexos encara. Evidentment, depenent de la destresa del programador, el que es considera complex pot ser molt relatiu. En qualsevol cas, i això és independent de l’habilitat del programador, el que cal identificar són tasques clarament diferenciades que cal resoldre per solucionar cada subproblema.
</p>
<ul>
<li class="level1"><div class="li"> <strong>Mostrar menú</strong>. Per fer això, bàsicament només cal imprimir un conjunt de text en pantalla i ja està. És una tasca molt simple que es pot dur a terme mitjançant successives invocacions a <code>System.out.println</code>. Per tant, no cal descompondre-la més. </div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong>Tractar ordre</strong>. Cal llegir l’ordre pel teclat i cal analitzar si el que es llegeix es correspon a alguna de les quatre ordres possibles. Això es pot fer amb una estructura de selecció. Llavors, segons el que s’ha llegit, cal fer tasques totalment diferents. Clarament, es tracta d’una tasca complexa que cal descompondre. La manera més lògica de fer-ho, inicialment, podria ser per cada tasca que cal dur a terme.</div>
</li>
</ul>

<p>
A partir d’aquesta anàlisi, la descomposició fins al segon nivell quedaria com:
</p>
<ol>
<li class="level1"><div class="li"> Mostrar menú.</div>
</li>
<li class="level1"><div class="li"> Tractar ordre.</div>
<ol>
<li class="level2"><div class="li"> Entrar registre de temperatures setmanals.</div>
</li>
<li class="level2"><div class="li"> Mostrar temperatura mitjana.</div>
</li>
<li class="level2"><div class="li"> Mostrar diferència màxima.</div>
</li>
<li class="level2"><div class="li"> Finalitzar execució.</div>
</li>
</ol>
</li>
</ol>

<p>
<strong>4. Tercer nivell de descomposició</strong>
</p>

<p>
Novament, es fa una iteració sobre els subproblemes de segon nivell per veure si presenten tasques complexes o no. En funció d’això, caldrà decidir si cal seguir descomposant-los.
</p>
<ul>
<li class="level1"><div class="li"> <strong>Entrar registre de temperatures setmanals</strong>. Per fer això cal resoldre dues tasques. D’una banda, llegir les temperatures i posar-les a l’<em>array</em> de temperatures. A més, també cal anar actualitzant la data actual cada cop que es llegeixen dades (avançar-la 7 dies). Això no és simple, ja que cal controlar el cas de quin dia acaba cada mes (28, 30 o 31 dies).</div>
</li>
<li class="level1"><div class="li"> <strong>Mostrar temperatura mitjana</strong>. Aquest problema es pot descompondre en dos. D’una banda, es demana mostrar la data de manera que el mes es mostri en format text, partint d’un número. D’altra banda, cal mostrar el càlcul que es demana (sumar tots els valors a l’<em>array</em> de temperatures i dividir-los pel seu nombre).</div>
</li>
<li class="level1"><div class="li"> <strong>Mostrar diferencia màxima</strong>. Aquest cas és exactament igual que l’anterior, només que el càlcul és diferent (cercar amb un únic recorregut els valors màxim i mínim i calcular-ne la diferència).</div>
</li>
<li class="level1"><div class="li"> <strong>Finalitzar execució</strong>. Bàsicament, seria canviar el valor de la variable de control de tipus semàfor que controla l’estructura de repetició on s’englobaran “Mostrar menú” i “Tractar ordre”. És molt simple.</div>
</li>
</ul>

<p>
Segons aquesta anàlisi, la descomposició fins al tercer nivell quedaria així:
</p>
<ol>
<li class="level1"><div class="li"> Mostrar menú.</div>
</li>
<li class="level1"><div class="li"> Tractar ordre.</div>
<ol>
<li class="level2"><div class="li"> Entrar registre de temperatures setmanals.</div>
<ol>
<li class="level3"><div class="li"> Llegir temperatures del teclat.</div>
</li>
<li class="level3"><div class="li"> Actualitzar data actual.</div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> Mostrar temperatura mitjana.</div>
<ol>
<li class="level3"><div class="li"> Mostrar data actual.</div>
</li>
<li class="level3"><div class="li"> Calcular temperatura mitjana.</div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> Mostrar diferència màxima.</div>
<ol>
<li class="level3"><div class="li"> Mostrar data actual.</div>
</li>
<li class="level3"><div class="li"> Calcular diferència màxima.</div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> Finalitzar execució.</div>
</li>
</ol>
</li>
</ol>

<p>
<strong>5. Quart nivell de descomposició</strong>
</p>

<p>
Novament, correspon estudiar si cal fer un nou nivell de descomposició segons el grau de complexitat dels subproblemes de tercer nivell. Un punt interessant que ara us trobeu és el fet que es poden localitzar subproblemes repetits. Mostrar la data actual és una tasca que cal fer en llocs diferents. Per tant, només caldrà resoldre aquest subproblema una única vegada.
</p>
<ul>
<li class="level1"><div class="li"> <strong>Llegir temperatures del teclat</strong>. Tot i que no es fa en poques línies de codi, sabeu llegir 7 valors de tipus real i assignar-los a un <em>array</em>. Per tant, no és una tasca especialment complexa que valgui la pena descompondre més.</div>
</li>
<li class="level1"><div class="li"> <strong>Actualitzar data actual</strong>. Es tracta d’incrementar el dia i, depenent del mes, amb una estructura de selecció, veure si s’ha avançat a un nou mes. No es compon de passes gaire complexes.</div>
</li>
<li class="level1"><div class="li"> <strong>Mostrar data actual</strong>. Es tracta de mostrar el dia directament i mostrar cert text segons el valor numèric del més. Això es podria fer amb una estructura de selecció. Per tant, tampoc es compon de passes gaire complexes..</div>
</li>
<li class="level1"><div class="li"> <strong>Calcular temperatura mitjana</strong>. És un càlcul sobre els valors registrats, fent un recorregut sobre l’<em>array</em>. És simple.</div>
</li>
<li class="level1"><div class="li"> <strong>Calcular diferència màxima</strong>. Exactament un cas molt semblant a l’anterior.</div>
</li>
</ul>

<p>
Atès que tots els subproblemes del tercer nivell ja són simples i resolen una tasca molt concreta i autocontinguda, no cal un quart nivell de descomposició. Heu acabat.
</p>

</div>

<h3><a id="esquelet_de_la_classe" >Esquelet de la classe</a></h3>
<div class="level3">

<p>
Un cop identificades les dades que es volen tractar i finalitzat el procés de descomposició inicial, és possible crear un esquelet de la classe, només amb la declaració de variables globals i mètodes necessaris. Cada subproblema equival a un mètode que cal declarar. Si l’esquelet està correctament declarat, hauria de ser possible compilar el codi font, tot i que en executar-se no faria absolutament res encara. Només es tracta d’una organització general del codi font.
</p>

<p>
En aquest exemple l’esquelet quedaria així:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class RegistreTemperatures {</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">  //Constants</div></li><li class="li1"><div class="de1">  private static final int MAX_SETMANES = 52;</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">  //Variables globals</div></li><li class="li1"><div class="de1">  private int numTemperatures = 0;</div></li><li class="li1"><div class="de1">  private float[] temperatures = new float[MAX_SETMANES * 7];</div></li><li class="li1"><div class="de1">  private int dia = 1;</div></li><li class="li1"><div class="de1">  private int mes = 1;</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">  //Mètodes associats al problema general</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    RegistreTemperatures programa = new RegistreTemperatures();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">  //Mètodes associats al primer nivell de descomposició</div></li><li class="li1"><div class="de1">  public void mostrarMenu() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void tractarOpcio() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">  //Mètodes associats al segon nivell de descomposició</div></li><li class="li1"><div class="de1">  public void registreTemperaturesSetmanals() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void mostrarMitjana() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void mostrarDiferencia() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void finalitzarExecució() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">&nbsp;</div></li><li class="li1"><div class="de1">  //Mètodes associats al tercer nivell de descomposició</div></li><li class="li1"><div class="de1">  //etc.</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 2:</strong> Completeu el codi font de l’esquelet de l’exemple amb la declaració dels mètodes al tercer nivell de descomposició. Els seus noms seran: <code>llegirTemperaturesTeclat</code>, <code>incrementarData</code>, <code>mostrarData</code>, <code>calculaMitjana</code> i <code>calculaDiferencia</code>.
</p>

</div>

<h3><a id="implementacio_del_tercer_nivell_de_descomposicio" >Implementació del tercer nivell de descomposició</a></h3>
<div class="level3">

<p>
Per codificar la descomposició d’aquest problema, també es començarà des dels mètodes associats als subproblemes del nivell més baix de descomposició i s’anirà pujant a poc a poc fins a arribar a la resolució del problema general, que correspon al mètode principal. Per tant, cal codificar els mètodes:
</p>
<ul>
<li class="level1"><div class="li"> <code>llegirTemperaturesTeclat</code>: registra 7 temperatures, o sigui, llegeix 7 valors reals i els desa a l’<em>array</em> de temperatures.</div>
</li>
<li class="level1"><div class="li"> <code>incrementarData</code>: donada una data, suma 7 al seu valor. </div>
</li>
<li class="level1"><div class="li"> <code>mostrarData</code>: mostra la data actual, en format: <em>Número del dia</em> de <em>Nom del mes</em>.</div>
</li>
<li class="level1"><div class="li"> <code>calculaMitjana</code>: mostra per pantalla la mitjana aritmètica de temperatures del registre.</div>
</li>
<li class="level1"><div class="li"> <code>calculaDiferencia</code>: mostra per pantalla la diferència de temperatures entre els valors màxim i mínim del registre.</div>
</li>
</ul>

<p>

</p>

<p>
Una proposta de com fer el seu codi seria la següent: atès que els mètodes són blocs autocontiguts de codi, un cop incorporats al codi font del programa, és possible compilar-lo perfectament sense problemes, tot i que, evidentment, el programa encara no farà res si s’executa. Afegiu-los i comproveu que és així.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  //Mètodes associats al tercer nivell de descomposició</div></li><li class="li1"><div class="de1">  public void llegirTemperaturesTeclat() {</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Escriu les temperatures d'aquesta setmana:&quot;);</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    int numLlegides = 0;</div></li><li class="li1"><div class="de1">    while (numLlegides &lt; 7) {</div></li><li class="li1"><div class="de1">      if (lector.hasNextFloat()) {</div></li><li class="li1"><div class="de1">        temperatures[numTemperatures] = lector.nextFloat();</div></li><li class="li1"><div class="de1">        numLlegides++;</div></li><li class="li1"><div class="de1">        numTemperatures++;</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void incrementarData() {</div></li><li class="li1"><div class="de1">    //Quants dies té aquest mes?</div></li><li class="li1"><div class="de1">    int diesAquestMes = 0;</div></li><li class="li1"><div class="de1">    if (mes == 2) {</div></li><li class="li1"><div class="de1">      diesAquestMes = 28;</div></li><li class="li1"><div class="de1">    } else if ((mes == 4)||(mes == 6)||(mes == 9 )||(mes == 11)) {</div></li><li class="li1"><div class="de1">      diesAquestMes = 30;</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      diesAquestMes = 31;</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    dia = dia + 7;</div></li><li class="li1"><div class="de1">    //Hem passat de mes?</div></li><li class="li1"><div class="de1">    if (dia &gt; diesAquestMes) {</div></li><li class="li1"><div class="de1">      dia = dia - diesAquestMes;</div></li><li class="li1"><div class="de1">      mes++;</div></li><li class="li1"><div class="de1">      //Hem passat d'any?</div></li><li class="li1"><div class="de1">      if (mes &gt; 12) {</div></li><li class="li1"><div class="de1">        mes = 1;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void mostrarData() {</div></li><li class="li1"><div class="de1">    System.out.print(dia + &quot; de &quot;);</div></li><li class="li1"><div class="de1">    switch(mes) {</div></li><li class="li1"><div class="de1">      case 1:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Gener&quot;); break;</div></li><li class="li1"><div class="de1">      case 2:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Febrer&quot;); break;</div></li><li class="li1"><div class="de1">      case 3:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Març&quot;); break;</div></li><li class="li1"><div class="de1">      case 4:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Abril&quot;); break;</div></li><li class="li1"><div class="de1">      case 5:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Maig&quot;); break;</div></li><li class="li1"><div class="de1">      case 6:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Juny&quot;); break;</div></li><li class="li1"><div class="de1">      case 7:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Juliol&quot;); break;</div></li><li class="li1"><div class="de1">      case 8:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Agost&quot;); break;</div></li><li class="li1"><div class="de1">      case 9:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Setembre&quot;); break;</div></li><li class="li1"><div class="de1">      case 10:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Octubre&quot;); break;</div></li><li class="li1"><div class="de1">      case 11:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Novembre&quot;); break;</div></li><li class="li1"><div class="de1">      case 12:</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Desembre&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void calculaMitjana() {</div></li><li class="li1"><div class="de1">    float acumulador = 0;</div></li><li class="li1"><div class="de1">    for(int i = 0; i &lt; numTemperatures; i++) {</div></li><li class="li1"><div class="de1">      acumulador = acumulador + temperatures[i];</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.print((acumulador / numTemperatures));</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void calculaDiferencia() {</div></li><li class="li1"><div class="de1">    //Veure Repte 3, més endavant</div></li><li class="li1"><div class="de1">    //...</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>

<p>
<strong>Repte 3:</strong> Codifiqueu el mètode <code>calculaDiferencia</code>. Explicat amb més detall, aquest mètode cerca els valors més alt i més baix d’entre els enregistrats i calcula la diferència entre ells. Un cop calculat, mostra el valor resultant per pantalla, tal com fa <code>calculaMitjana</code>.
</p>

</div>

<h3><a id="implementacio_del_segon_nivell_de_descomposicio" >Implementació del segon nivell de descomposició</a></h3>
<div class="level3">

<p>
Un cop acabada la codificació dels mètodes de nivell més baix de descomposició, cal resoldre el nivell immediatament superior, pas a pas, sense saltar-se cap nivell. Un aspecte interessant en anar resolent nivells superiors és que, si la descomposició ha estat apropiada, la dificultat de codificar tots els subproblemes, independentment del nivell, hauria de ser similar. En el cas dels nivells més baixos, això era degut al fet que es tracta dels problemes que heu considerat més simples, com ja heu vist. En nivell superiors, però, la seva complexitat també serà més baixa ja que es disposa d’una part del problema resolta. Per tant, la codificació d’aquest segon nivell no hauria de resultar haver de fer mètodes molt més complicats o necessàriament amb més codi que el pas anterior. De fet, fins i tot poden ser més senzills.
</p>

<p>
Els mètodes que estan inclosos en aquest nivell són els associats a les quatre opcions possibles dins el programa:
</p>
<ul>
<li class="level1"><div class="li"> <code>registreTemperaturesSetmanals</code>: gestiona el porcés de registrar temperatures setmanals: llegir dades, emmagatzemar-les i incrementar la data actual.</div>
</li>
<li class="level1"><div class="li"> <code>mostrarMitjana</code>: mostra per pantalla el missatge de la mitjana de les temperatures: data actual i valor.</div>
</li>
<li class="level1"><div class="li"> <code>mostrarDiferencia</code>: mostra per pantalla el missatge de la diferència màxima de les temperatures: data actual i valor.</div>
</li>
<li class="level1"><div class="li"> <code>finalitzarExecució</code>: gestiona la finalització del programa.</div>
</li>
</ul>

<p>
&lt;iocstl textB&gt;La codificació estrictament de nivells inferiors a superiors de manera totalment compartimentalitzada no sempre és possible.
:::
A mesura que aneu pujant de nivells podeu trobar alguns casos especials, els quals no són infreqüents durant un procés de disseny descendent, i sobre ell us caldrà reflexionar. 
</p>

<p>
D’una banda, es pot donar el cas en què caldrà aprofitar un mateix mètode de nivells inferiors per codificar més d’un mètode del nivell present. Aquest és el cas de <code>mostrarMitjana</code> i <code>mostrarDiferencia</code>, ja que ambdós han de mostrar la data actual, i per tant faran ús de <code>mostrarData</code>. 
</p>

<p>
D’altra banda, la codificació d’un mètode pot no ser clara <em>a priori</em>, i no ho serà fins a solucionar nivells de descomposició superiors. Aquest és el cas de la codificació del mètode <code>finalitzarExecució</code>, ja que controla la finalització de l’execució del programa principal, un mètode de nivell superior que encara no toca implementar. Aquest és un cas en què la resolució ordenada de nivell inferior a superior individualment no és perfecta, ja que cal una visió més general del problema. Quan això passa, cal deixar el codi buit fins que la solució quedi més clara més endavant.
</p>

<p>
El codi dels quatre mètodes, que preveu les circumstàncies tot just descrites, seria el següent. Afegiu-lo al programa i comproveu que compila correctament.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  //Mètodes associats al segon nivell de descomposició</div></li><li class="li1"><div class="de1">  public void registreTemperaturesSetmanals() {</div></li><li class="li1"><div class="de1">    //Cal controlar si hi haurà espai per a aquests 7 registres</div></li><li class="li1"><div class="de1">    if ((numTemperatures + 7) &gt;=  temperatures.length) {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;No queda espai per a més temperatures.&quot;);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      llegirTemperaturesTeclat();</div></li><li class="li1"><div class="de1">      incrementarData();</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void mostrarMitjana() {</div></li><li class="li1"><div class="de1">    if (numTemperatures &gt; 0) {</div></li><li class="li1"><div class="de1">      System.out.print(&quot;\nFins avui &quot;);</div></li><li class="li1"><div class="de1">      mostrarData();</div></li><li class="li1"><div class="de1">      System.out.print(&quot; la mitjana ha estat de &quot;);</div></li><li class="li1"><div class="de1">      calculaMitjana();</div></li><li class="li1"><div class="de1">      System.out.println(&quot; graus.&quot;);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;\nNo hi ha temperatures registrades.&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void mostrarDiferencia() {</div></li><li class="li1"><div class="de1">    //Veure Repte 4, tot seguit.</div></li><li class="li1"><div class="de1">    //...</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void finalitzarExecució() {</div></li><li class="li1"><div class="de1">    //Ja es pensarà a resoldre el nivell superior...</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>

<p>
<strong>Repte 4:</strong> Codifiqueu el mètode <code>mostrarDiferencia</code>.
</p>

</div>

<h3><a id="implementacio_del_primer_nivell_de_descomposicio" >Implementació del primer nivell de descomposició</a></h3>
<div class="level3">

<p>
En aquest problema, el primer nivell de descomposició es correspon als subproblemes més generals, que engloben totes les funcions del programa. Només cal implementar dos mètodes:
</p>
<ul>
<li class="level1"><div class="li"> <code>mostrarMenu</code>: mostra el menú principal per pantalla (només imprimeix coses per pantalla).</div>
</li>
<li class="level1"><div class="li"> <code>tractarOpcio</code>: llegeix l’ordre i executa el mètode de segon nivell corresponent.</div>
</li>
</ul>

<p>
El codi que porta a terme aquestes tasques és el següent. Fixeu-vos que encara no heu resolt el mètode <code>finalitzarExecució</code>, però atès que se n’ha declarat l’esquelet, es pot invocar correctament sense que hi hagi cap error de compilació. Simplement, ara per ara la seva invocació és equivalent a no fer res (no s’executa cap instrucció).
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  //Mètodes associats al primer nivell de descomposició</div></li><li class="li1"><div class="de1">  public void mostrarMenu() {</div></li><li class="li1"><div class="de1">    System.out.println(&quot;\nBenvingut al registre de temperatures&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;-------------------------------------&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;[RT] Registrar temperatures setmanals.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;[MJ] Consultar temperatura mitjana.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;[DF] Consultar diferència màxima.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;[FI] Sortir.&quot;);</div></li><li class="li1"><div class="de1">    System.out.print(&quot;Opció: &quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void tractarOpcio() {</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    String opcio = lector.nextLine();</div></li><li class="li1"><div class="de1">    if (opcio.equalsIgnoreCase(&quot;RT&quot;)) {</div></li><li class="li1"><div class="de1">      registreTemperaturesSetmanals();</div></li><li class="li1"><div class="de1">    } else if (opcio.equalsIgnoreCase(&quot;MJ&quot;)) {</div></li><li class="li1"><div class="de1">      mostrarMitjana();</div></li><li class="li1"><div class="de1">    } else if (opcio.equalsIgnoreCase(&quot;DF&quot;)) {</div></li><li class="li1"><div class="de1">      mostrarDiferencia();</div></li><li class="li1"><div class="de1">    } else if (opcio.equalsIgnoreCase(&quot;FI&quot;)) {</div></li><li class="li1"><div class="de1">      finalitzarExecució();</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Opció incorrecta!\n&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>

</div>

<h3><a id="implementacio_del_problema_general" >Implementació del problema general</a></h3>
<div class="level3">

<p>
Finalment, ha arribat el moment d’implementar el problema general, el mètode <code>inici</code>. Atès que tots els subproblemes inferiors ja han estat resolts, normalment aquesta tasca serà ja relativament simple. Pel funcionament que s’ha definit per a aquest programa, el que ha de fer bàsicament és mostrar el menú i llegir una ordre de manera indefinida, fins a demanar que finalitzi el programa, o sigui una estructura de repetició controlada per una variable de control amb funcions de semàfor, que canviarà d’estat quan calgui finalitzar les iteracions.
</p>
<div class="ioctext"><div class="ioccontent"><p class="ioctitle">equalsIgnoreCase</p>
<p>
Aquest mètode de la classe <code>String</code> compara dues cadenes de text ignorant diferències entre majúscules i minúscules.
</p>
</div></div>
<p>
El seu codi seria el següent, on <code>fi</code> seria la variable de control. Com podeu veure, aquest és el mètode més senzill de tots!
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    while (!fi) {</div></li><li class="li1"><div class="de1">      mostrarMenu();</div></li><li class="li1"><div class="de1">      tractarOpcio();</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>

<p>
Un cop arribats a aquest punt, toca fer marxa enrere i recordar que hi havia una tasca pendent: codificar <code>finalitzarExecució</code>. Les seves instruccions no es podien deduir en el seu moment, ja que depenien de com es resoldria el codi del problema general. Ara que ja sabeu que la finalització del programa depèn d’una variable de control, ja es pot saber que cal canviar el seu valor de manera adient.
</p>

<p>
Per tant, el seu codi serà:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  public void finalitzarExecució() {</div></li><li class="li1"><div class="de1">    fi = true;</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>

<p>
Un cop codificat, només resta una cosa, i és declarar aquesta variable. Atès que es tracta d’un valor que cal accedir des de dos mètodes diferents, caldrà fer-ho com una variable global.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  //Variables globals</div></li><li class="li1"><div class="de1">  private boolean fi = false;</div></li><li class="li1"><div class="de1">  private int numTemperatures = 0;</div></li><li class="li1"><div class="de1">  private float[] temperatures = new float[MAX_SETMANES * 7];</div></li><li class="li1"><div class="de1">  private int dia = 1;</div></li><li class="li1"><div class="de1">  private int mes = 1;</div></li><li class="li1"><div class="de1">  ...</div></li></ol></pre>

</div>

<h3><a id="millores_sobre_la_solucio_final" >Millores sobre la solució final</a></h3>
<div class="level3">

<p>
Un cop finalitzat el programa, és el moment de veure si funciona. Evidentment, pot ser que el codi d’algun mètode no hagi estat codificat correctament i sigui necessari corregir-lo. Per al cas dels programes complexos, el depurador és una eina de gran ajut en aquest tasca, complementada amb el fet que, usant mètodes, és molt fàcil identificar la utilitat de cada bloc de codi.
</p>

<p>
Tot i que el programa funcioni, un cop ja disposeu de tot el codi del programa (ja s’han deduït tots els mètodes, el seu codi, i les variables globals que cal usar), val la pena donar una ullada general per refinar el resultat. Aquest procés de refinament es basa en dos principis: eliminar mètodes massa curts o simplificar els que són encara massa llargs o complexos.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Abans de procedir a millorar el codi, però, cal que tingueu sempre present la màxima següent: primer cal que el programa funcioni. Després ja pensareu com simplificar el codi.
</p>
</div></div>
</div>

<h4><a id="eliminacio_de_metodes" >Eliminació de mètodes</a></h4>
<div class="level4">

<p>
Un cop codificats tots els mètodes, potser hi haurà algun que té molt poques línies -estem parlant d’una o dues. Mai es reaprofita, i només s’usa en un únic lloc. Normalment, quan això passa es deu al fet que s’ha filat massa prim en el procés de descomposició i s’ha considerat com a subproblema una tasca que és molt senzilla i no té prou entitat en si mateixa. Que això succeeixi no vol dir que el procés hagi estat totalment incorrecte, ja que moltes vegades, <em>a priori</em>, és impossible saber que això passarà. Molts cops, només un cop codificats tots els mètodes us podeu adonar d’aquest fet i obrar en conseqüència.
</p>

<p>
Un cas clar d’aquesta circumstància pot ser el mètode <code>finalitzarExecució</code>, que només té una línia i només s’invoca en un únic lloc dins el programa. Normalment, no té sentit crear mètodes tan curts. Per tant, no seria incorrecte eliminar-lo i incorporar el seu codi directament allà on s’invoca (en el tractament de l’ordre “FI”).
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  public void tractarOpcio() {</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    String opcio = lector.nextLine();</div></li><li class="li1"><div class="de1">    if (opcio.equalsIgnoreCase(&quot;RT&quot;)) {</div></li><li class="li1"><div class="de1">      registreTemperaturesSetmanals();</div></li><li class="li1"><div class="de1">    } else if (opcio.equalsIgnoreCase(&quot;MJ&quot;)) {</div></li><li class="li1"><div class="de1">      mostrarMitjana();</div></li><li class="li1"><div class="de1">    } else if (opcio.equalsIgnoreCase(&quot;DF&quot;)) {</div></li><li class="li1"><div class="de1">      mostrarDiferencia();</div></li><li class="li1"><div class="de1">    } else if (opcio.equalsIgnoreCase(&quot;FI&quot;)) {</div></li><li class="li1"><div class="de1">      //S'ha esborrat el mètode finalitzarExecució i s'ha posat el seu codi directament.</div></li><li class="li1"><div class="de1">      fi = true;</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Opció Incorrecta!\n&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>

</div>

<h4><a id="millora_de_metodes" >Millora de mètodes</a></h4>
<div class="level4">

<p>
Si al final del procés apareix algun mètode molt llarg o complex, això pot significar el contrari del cas anterior: que no s’ha descomposat prou el problema. Pot valer la pena tornar a aplicar el procés de descomposició <em>a posteriori</em>, dividint aquest mètode en d’altres. Tot i que pot semblar que, un cop el programa ja funciona, no val la pena refinar el procés de descomposició (al cap i a la fi, el seu propòsit era simplificar el procés de creació, que ja ha finalitzat), penseu que un altre avantatge del disseny descendent és facilitar la legibilitat del vostre codi. En el món de la programació tampoc us ha de fer mandra de ser polits i endreçats (amb el vostre codi). 
</p>
<div class="iocreference"><div class="ioccontent">
<p>
A la secció “Recursos del contingut” del web disposeu d’un annex on s’explica una tècnica per simplificar el codi d’alguns mètodes amb estructures de selecció llargues.
</p>
</div></div>
<p>
Ara bé, de vegades el procés ha estat correcte i simplement la quantitat de línies de codi necessàries per dur a terme la tasca establerta és realment gran. En casos com aquests, igualment, és interessant repassar si el codi es pot millorar simplificant-lo, cercant algun conjunt de codi alternatiu que el faci més curt. Evidentment, això no sempre és possible, però val la pena fer-hi una pensada ara que ja teniu un programa que funciona.
</p>

<p>

</p>

</div>

<h2><a id="solucio_dels_reptes_proposats" >Solució dels reptes proposats</a></h2>
<div class="level2">

<p>
<strong>Repte 1</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class OrdenarDescendent {</div></li><li class="li1"><div class="de1">  int[] llistaEnters = new int[10];</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    OrdenarDescendent programa = new OrdenarDescendent();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    llegirLlista();</div></li><li class="li1"><div class="de1">    ordenarLlista();</div></li><li class="li1"><div class="de1">    mostrarLlista();</div></li><li class="li1"><div class="de1">    comptarMeitatMaxim();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per llegir la llista.</div></li><li class="li1"><div class="de1">  public void llegirLlista() {</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Escriu 10 valors enters i pitja retorn.&quot;);</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    int index = 0;</div></li><li class="li1"><div class="de1">    while (index &lt; llistaEnters.length) {</div></li><li class="li1"><div class="de1">      if (lector.hasNextInt()) {</div></li><li class="li1"><div class="de1">        llistaEnters[index] = lector.nextInt();</div></li><li class="li1"><div class="de1">        index++;</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per ordenar la llista.</div></li><li class="li1"><div class="de1">  public void ordenarLlista() {</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaEnters.length - 1; i++) {</div></li><li class="li1"><div class="de1">      for(int j = i + 1; j &lt; llistaEnters.length; j++) {</div></li><li class="li1"><div class="de1">        //La posició tractada té un valor més alt que el de la cerca... Els intercanviem.</div></li><li class="li1"><div class="de1">        if (llistaEnters[i] &gt; llistaEnters[j]) {</div></li><li class="li1"><div class="de1">          //Per intercanviar valors cal una variable auxiliar</div></li><li class="li1"><div class="de1">          int canvi = llistaEnters[i];</div></li><li class="li1"><div class="de1">          llistaEnters[i] = llistaEnters[j];</div></li><li class="li1"><div class="de1">          llistaEnters[j] = canvi;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Mètode amb les instruccions per mostrar la llista per pantalla.</div></li><li class="li1"><div class="de1">  public void mostrarLlista() {</div></li><li class="li1"><div class="de1">    System.out.print(&quot;L'array ordenat es: [ &quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaEnters.length;i++) {</div></li><li class="li1"><div class="de1">      System.out.print(llistaEnters[i] + &quot; &quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println(&quot;]&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  //Nou mètode per resoldre el nou subproblema</div></li><li class="li1"><div class="de1">  public void comptarMeitatMaxim() {</div></li><li class="li1"><div class="de1">    int valorMaxim = llistaEnters[llistaEnters.length - 1] / 2;</div></li><li class="li1"><div class="de1">    int i = 0;</div></li><li class="li1"><div class="de1">    while ((llistaEnters[i] &lt; valorMaxim)&amp;&amp;(i &lt; llistaEnters.length)) {</div></li><li class="li1"><div class="de1">      i++;</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println(&quot;El nombre de valors inferiors a la meitat del maxim és &quot; + i);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 2</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">  //Mètodes associats al tercer nivell de descomposició</div></li><li class="li1"><div class="de1">  public void llegirTemperaturesTeclat() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void incrementarData() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void mostrarData() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void calculaMitjana() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void calculaDiferencia() {</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  ...</div></li></ol></pre>

<p>
<strong>Repte 3</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  public void calculaDiferencia() {</div></li><li class="li1"><div class="de1">    float maxima = temperatures[0];</div></li><li class="li1"><div class="de1">    float minima = temperatures[0];</div></li><li class="li1"><div class="de1">    for(int i = 1; i &lt; numTemperatures; i++) {</div></li><li class="li1"><div class="de1">      if (temperatures[i] &lt; minima) {</div></li><li class="li1"><div class="de1">        minima = temperatures[i];</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      if (temperatures[i] &gt; maxima) {</div></li><li class="li1"><div class="de1">        maxima = temperatures[i];</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.print((maxima - minima));</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>

<p>
<strong>Repte 4</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  public void mostrarDiferencia() {</div></li><li class="li1"><div class="de1">    if (numTemperatures &gt; 0) {</div></li><li class="li1"><div class="de1">      System.out.print(&quot;\nFins avui &quot;);</div></li><li class="li1"><div class="de1">      mostrarData();</div></li><li class="li1"><div class="de1">      System.out.print(&quot; la diferència màxima ha estat de &quot;);</div></li><li class="li1"><div class="de1">      calculaDiferencia();</div></li><li class="li1"><div class="de1">      System.out.println(&quot; graus.&quot;);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;\nNo hi ha temperatures registrades.&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li></ol></pre>

</div>

	 </article>
     <div class="pnpage">
      <div class="left-corner"></div>
      <div id="prevpage">Anar a la p&agrave;gina anterior:<br /><a href="../../../WebContent/u4/referencies.html">Referències</a></div>
      <div id="nextpage">Anar a la p&agrave;gina seg&uuml;ent:<br /><a href="../../../WebContent/u4/a1/activitats.html">Activitats</a></div>
      <div class="right-corner"></div>
     </div>
    </div>
    <footer class="footer">
      <div><small>Aquest document està subjecte a una llicència oberta de Creative Commons, es reserva el dret de reconeixement de l'autoria, d'exigir que no se'n faci cap mena d'ús comercial. Si altereu o transformeu aquesta obra, o en genereu obres derivades, només podeu distribuir l'obra generada amb una llicència idèntica a aquesta.</small></div>
    </footer>
 </div>
 <div id="back_preview" class="hidden"></div>
 <div id="preview" class="hidden">
  <div class="prevcontent"></div>
 </div>
 <div id="help-tooltips">
  <div id="help-toc" class="hidden tooltip"><span>Taula de continguts:</span> Ofereix una vista general de l&#39;estructura del m&ograve;dul, que us facilitar&agrave; la navegaci&oacute; a trav&eacute;s dels seus continguts.<span class="arrow-left"></span></div> 
  <div id="help-settings" class="hidden tooltip"><span>Opcions de format:</span> Permet configurar el format de lectura a partir de les vostres prefer&egrave;ncies, modificant la mida de la lletra, el color del fons, l&#39;amplada de la p&agrave;gina o l&#39;ocultaci&oacute; dels continguts complementaris, entre d&#39;altres.<span class="arrow-left"></span></div>
  <div id="help-printer" class="hidden tooltip"><span>Imprimir:</span>  Envia el contingut seleccionat a la impressora.<span class="arrow-left"></span></div>
  <div id="help-favorites" class="hidden tooltip"><span>Prefereits:</span> Permet desar aquelles parts del contingut a les que us interessi accedir en un moment posterior; us permetr&agrave; anar creant un repositori personalitzat de les seccions que considereu m&eacute;s rellevants. Un cop l&#39;hageu començat a fer servir se us mostrar&agrave; a sota un comptador que us informar&agrave; del nombre de preferits que s&#39;hagin emmagatzemat fins al moment.<span class="arrow-left"></span></div>
  <div id="help-favcounter" class="hidden tooltip"><span>Comptador i llistat de preferits:</span> Indica el nombre de preferits que s&#39;han desat fins el moment; clicant damunt seu accedireu al llistat de preferits, i a trav&eacute;s d&#39;aquest podreu accedir directament als continguts que hageu emmagatzemat.<span class="arrow-left"></span></div>
  <div id="help-help_icon" class="hidden tooltip"><span>Ajuda:</span> Aquesta opci&oacute; activa la informaci&oacute; de les funcionalitats del web tot situant el punter del ratol&iacute; al damunt dels diferents &iacute;tems.<span class="arrow-left"></span></div>
  <div id="help-sidebar-hide" class="hidden tooltip"><span>Mostrar/Ocultar barra lateral:</span>  Deshabilita la barra d&#39;opcions, permetent la seva recuperaci&oacute; quan es desitgi.<span class="arrow-left"></span></div>
  <div id="help-search" class="hidden tooltip"><span>Cerca:</span>  Introdu&iuml;u les paraules clau sobre aquells conceptes que desitgeu localitzar en els continguts del m&ograve;dul. Tamb&eacute; podeu excloure un terme de la cerca tot afegint-hi el signe &#8220;-&#8221; al davant.<span class="arrow-top"></span></div>
  <div id="help-header" class="hidden tooltip"><span>Cap&ccedil;alera:</span>  Indica l&#39;apartat o secci&oacute; que es mostra en pantalla. Tingueu present que les capçaleres de segon, tercer i quart nivell tamb&eacute; es poden desar com a marcadors.<span class="arrow-left"></span></div>
</div> 
</body>
</html>
