<!doctype html>

<!--[if lt IE 7 ]> <html class="ie ie6 no-js" lang="ca"> <![endif]-->
<!--[if IE 7 ]>    <html class="ie ie7 no-js" lang="ca"> <![endif]-->
<!--[if IE 8 ]>    <html class="ie ie8 no-js" lang="ca"> <![endif]-->
<!--[if IE 9 ]>    <html class="ie ie9 no-js" lang="ca"> <![endif]-->
<!--[if gt IE 9]><!--><html class="no-js" lang="ca"><!--<![endif]-->
<!-- the "no-js" class is for Modernizr. -->

<head id="www-sitename-com" data-template-set="html5-reset">

	<meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html">
        
	<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Programació bàsica (ASX) \ Programació (DAM i DAW)</title>
	
<!-- <meta name="title" content=""> --> 
	<meta name="description" content="">
	<!-- Google will often use this as its description of your page/site. Make it good. -->
	
	<meta name="google-site-verification" content="">
	<!-- Speaking of Google, don't forget to set your site up: http://google.com/webmasters -->
	
	<meta name="author" content="Institut Obert de Catalunya">
	<meta name="Copyright" content="Copyright Institut Obert de Catalunya 2011. All Rights Reserved.">

	<!-- Dublin Core Metadata : http://dublincore.org/ -->
	<meta name="DC.title" content="Programació bàsica (ASX) \ Programació (DAM i DAW)">
	<meta name="DC.subject" content="Informàtica i comunicacions">
	<meta name="DC.creator" content="Institut Obert de Catalunya">
	
	<!--  Mobile Viewport Fix
	j.mp/mobileviewport & davidbcalhoun.com/2010/viewport-metatag 
	device-width : Occupy full width of the screen in its current orientation
	initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
	maximum-scale = 1.0 retains dimensions instead of zooming in if page width < device width
	-->
	<!-- Uncomment to use � use thoughtfully!
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	-->

	<link rel="shortcut icon" href="../../../img/favicon.ico">
	<!-- This is the traditional favicon.
		 - size: 16x16 or 32x32
		 - transparency is OK
		 - see wikipedia for info on browser support: http://mky.be/favicon/ -->
		 
	<link rel="apple-touch-icon" href="../../../img/apple-touch-icon.png">
	<!-- The is the icon for iOS's Web Clip.
		 - size: 57x57 for older iPhones, 72x72 for iPads, 114x114 for iPhone4's retina display (IMHO, just go ahead and use the biggest one)
		 - To prevent iOS from applying its styles to the icon name it thusly: apple-touch-icon-precomposed.png
		 - Transparency is not recommended (iOS will put a black BG behind the icon) -->
	
	<!-- CSS: screen, mobile & print are all in the same file -->
	<link rel="stylesheet" href="../../../_/css/style.css">

	<!-- CSS: jQuery UI -->
	<link rel="stylesheet" href="../../../_/css/jquery-ui.css">
	
	<!-- all our JS is at the bottom of the page, except for Modernizr. -->
	<script src="../../../_/js/modernizr-1.7.min.js"></script>
	<script src="../../../_/js/Hyphenator.js" type="text/javascript"></script>
	<script type="text/javascript">
	   Hyphenator.config({
		minwordlength : 4
	   });
	   Hyphenator.run();
	</script>
    <script src="../../../_/js/build.js" type="text/javascript"></script>
</head>

<body class="style-newspaper">

<div class="wrapper"><!-- not needed? up to you: http://camendesign.com/code/developpeurs_sans_frontieres -->

	<header id="header">
		<div class="head"><a href="http://ioc.gencat.cat"><img src="../../../img/logo.png" alt="Institut Obert de Catalunya"/></a><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/es/deed.ca"><img src="../../../img/license.png" alt="Llic&egrave;ncia" class="license"/></a></div>
		<div class="headdocument"><a href="../../../index.html">Programació bàsica (ASX) \ Programació (DAM i DAW)</a></div>
        <div id="search" class="search" name="search">
         <form id="frmsearch" action="../../../search.html" method="get">
          <input type="text" name="q"/>
        </form>
        </div>
	</header>
   <div id="upbutton" class="upbutton" style="display:none;"><img src="../../../img/uparrow.png" alt="Pujar a l'inici de p&agrave;gina"/></div>
   <aside id="aside">
    <div id="menu">
      <ul>
       <li name="toc"><div><img src="../../../img/toc.png" alt="&Iacute;ndex"/></div></li>
       <li name="settings"><div><img src="../../../img/settings.png" alt="Configuraci&oacute;"/></div></li>
       <li name="printer"><div><img src="../../../img/printer.png" alt="Imprimir"/></div></li>
       <li name="favorites"><div><img src="../../../img/favorites.png" alt="Favorits"/></div></li>
       <li name="help_icon" class="help_icon"><div><img src="../../../img/help_icon.png" alt="Ajuda"/></div></li>
      </ul>
     </div>
   </aside>
   <div id="sidebar-hide" name="sidebar-hide"><img src="../../../img/arrows.png"/></div>
   <section>
     <div id="toc" class="hidden">
      <div class="menucontent">
        <ul>
        <li id="u6" class="parentnode"><p><a class="unit" href="../../../WebContent/u6/introduccio.html">6. Fitxers</a></p><ul class="expander"><li id="u6introduccio"><a href="../../../WebContent/u6/introduccio.html">Introducció</a></li><li id="u6resum"><a href="../../../WebContent/u6/resum.html">Resum</a></li><li id="u6resultats_d_aprenentatge"><a href="../../../WebContent/u6/resultats_d_aprenentatge.html">Resultats d'aprenentatge</a></li><li id="u6mapa"><a href="../../../WebContent/u6/mapa.html">Mapa conceptual</a></li><li id="u6referencies"><a href="../../../WebContent/u6/referencies.html">Referències</a></li><li id="u6a1" class="tocsection"><p id='u6a1continguts'><a class="section" href="../../../WebContent/u6/a1/continguts.html">Gestió de fitxers</a><span class="buttonexp"></span></p><ul><li id="u6a1activitats"><a href="../../../WebContent/u6/a1/activitats.html">Activitats</a></li><li id="u6a1exercicis"><a href="../../../WebContent/u6/a1/exercicis.html">Exercicis d'autoavaluació</a></li></ul></li><div data-parent-id='u6a1' class='tocssection hidden'><div class="toc"><ul><li><a href="../../../WebContent/u6/a1/continguts.html#la_classe_file">La classe File</a></li><li><a href="../../../WebContent/u6/a1/continguts.html#solucio_dels_reptes_proposats">Solució dels reptes proposats</a></li></ul></div></div><li id="u6a2" class="tocsection"><p id='u6a2continguts'><a class="section" href="../../../WebContent/u6/a2/continguts.html">Tractament bàsic de dades</a><span class="buttonexp"></span></p><ul><li id="u6a2activitats"><a href="../../../WebContent/u6/a2/activitats.html">Activitats</a></li><li id="u6a2exercicis"><a href="../../../WebContent/u6/a2/exercicis.html">Exercicis d'autoavaluació</a></li></ul></li><div data-parent-id='u6a2' class='tocssection hidden'><div class="toc"><ul><li><a href="../../../WebContent/u6/a2/continguts.html#acces_sequeencial_a_fitxers_orientats_a_caracter">Accés seqüencial a fitxers orientats a caràcter</a></li><li><a href="../../../WebContent/u6/a2/continguts.html#aspectes_importants_de_l_acces_sequeencial">Aspectes importants de l'accés seqüencial</a></li><li><a href="../../../WebContent/u6/a2/continguts.html#acces_sequeencial_a_fitxers_orientats_a_byte">Accés seqüencial a fitxers orientats a byte</a></li><li><a href="../../../WebContent/u6/a2/continguts.html#acces_relatiu_a_les_dades">Accés relatiu a les dades</a></li><li><a href="../../../WebContent/u6/a2/continguts.html#solucions_als_reptes_proposats">Solucions als reptes proposats</a></li></ul></div></div><li id="u6a3" class="tocsection"><p id='u6a3continguts'><a class="section" href="../../../WebContent/u6/a3/continguts.html">Tractament modular de dades. El joc de combats a l'arena</a><span class="buttonexp"></span></p><ul><li id="u6a3activitats"><a href="../../../WebContent/u6/a3/activitats.html">Activitats</a></li><li id="u6a3exercicis"><a href="../../../WebContent/u6/a3/exercicis.html">Exercicis d'autoavaluació</a></li><li id="u6a3annexos"><a href="../../../WebContent/u6/a3/annexos.html">Annexos</a></li></ul></li><div data-parent-id='u6a3' class='tocssection hidden'><div class="toc"><ul><li><a href="../../../WebContent/u6/a3/continguts.html#descripcio_del_problema">Descripció del problema</a></li><li><a href="../../../WebContent/u6/a3/continguts.html#criteris_d_eleccio_de_tipus_de_fitxer">Criteris d'elecció de tipus de fitxer</a></li><li><a href="../../../WebContent/u6/a3/continguts.html#la_biblioteca_jocarenafitxers">La biblioteca "joc.arena.fitxers"</a></li><li><a href="../../../WebContent/u6/a3/continguts.html#esmenes_als_moduls_originals">Esmenes als mòduls originals</a></li></ul></div></div></ul></li><li id="" class="indexnode"><p><a href="../../../index.html">Anar a l&#39;&iacute;ndex general</a></p></li>
        </ul>
      </div>
    </div>
   </section>
   <section>
   <div id="settings" class="hidden">
    <div class="menucontent">
     <div class="allsettings">
     <div class="settings">
      <label>Font i Color</label>
		<div class="setting-option">
	        <ul class="fontBackground">
				<li id="style-newspaper" title="Newspaper" class="appearance-style-newspaper"><span>Newspaper</span></li>
                <li id="style-novel" title="Novel" class="appearance-style-novel"><span>Novel</span></li>
                <li id="style-ebook" title="eBook" class="appearance-style-ebook"><span>eBook</span></li>
				<li id="style-inverse" title="Inverse" class="appearance-style-inverse active"><span>Inverse</span></li>
				<li id="style-athelas" title="Athelas" class="appearance-style-athelas"><span>Athelas</span></li>
			</ul>
		</div>
     </div>
	<div class="settings">
      <label>Amplada</label>
		<div class="setting-option">
	        <div id="slider-width"></div>
		</div>
     </div>
     <div class="settings">
      <label>Mida de la font</label>
		<div class="setting-option">
	        <div id="slider-font"></div>
		</div>
     </div>
     <div class="settings">
      <label>Mida de la font</label>
	  <div class="setting-option">
       <form action="" class="sett-options">
		<ul>
		    <li><input type="checkbox" id="secondary-content" /><label for="secondary-content">Mostra recursos complementaris</label></li>
		    <li><input type="checkbox" id="main-images" /><label for="main-images">Mostra imatges</label></li>
		    <li><input type="checkbox" id="text-alignment" /><label for="text-alignment">Text justificat</label></li>
			<li><input type="checkbox" id="text-hyphen" /><label for="text-hyphen">Partici&oacute; sil·l&agrave;bica</label></li>
		</ul>
       </form>
	  </div>
     </div>
     </div>
    </div>
   </div>
   </section>
 <section>
 <div id="favorites" class="hidden"></div>
 </section>   
 <div id="bridge" class="hidden"></div>
 <div id="help" class="hidden">
  <div class="helptitle">Dreceres del teclat<hr></div>
  <div class="helpsection"><span>General</span>
   <ul>
    <li><span class="shortcut">g</span>: Anar al men&uacute; de navegaci&oacute;</li>
    <li><span class="shortcut">o</span>: Anar a opcions</li>
    <li><span class="shortcut">s</span>: Guardar la p&agrave;gina actual a favorits</li>
    <li><span class="shortcut">p</span>: Imprimir la p&agrave;gina actual</li>
    <li><span class="shortcut">?</span>: Mostrar/Ocultar l&#39;ajuda</li>
   </ul>
  </div>
  <div class="helpsection"><span>Navegaci&oacute;</span>
   <ul>
    <li><span class="shortcut">i</span>: Anar a l&#39;&iacute;ndex general</li>
    <li><span class="shortcut">t</span>: Anar a l&#39;inici de p&agrave;gina</li>
    <li><span class="shortcut">b</span>: Anar al final de p&agrave;gina</li>
    <li><span class="shortcut">j</span>: Anar cap endavant dintre la p&agrave;gina</li>
    <li><span class="shortcut">k</span>: Anar cap enrere dintre la p&agrave;gina</li>
    <li><span class="shortcut">h</span>: Anar a la p&agrave;gina anterior:</li>
    <li><span class="shortcut">l</span>: Anar a la p&agrave;gina seg&uuml;ent:</li>
   </ul>
   </div>
 </div>
 <div id="favcounter" name="favcounter" class="hidden"><span></span></div>
 <div id="navmenu" class="navmenu"><ul class="webnav"><li><a href="../../../index.html" title="Anar a l&#39;&iacute;ndex general">Inici</a></li><li><a href="../introduccio.html">Fitxers</a></li><li>Tractament bàsic de dades</li></ul></div>
	<div id="content" lang="ca" class="hyphenate text">
     <article lang="ca" class="sheet">
        <h1><a id="tractament_basic_de_dades"> Tractament bàsic de dades </a></h1>
    	
<p>
Normalment, les aplicacions que fan servir fitxers no estan centrades en la gestió del sistema de fitxers del vostre ordinador. L’objectiu principal d’usar fitxers és poder emmagatzemar-hi dades, de manera que entre diferents execucions del programa, fins i tot en diferents equips, és possible recuperar-les. El cas més típic és un editor de documents, que mentre s’executa s’encarrega de gestionar les dades relatives al text que esteu escrivint, però en qualsevol moment podeu desar-lo en un fitxer per poder recuperar aquest text en qualsevol moment posterior, i afegir-ne de nou, si escau. El fitxer amb les dades del document el podeu obrir tant en l’editor del vostre ordinador com en el d’un altre company.
</p>

<p>
Per saber com tractar les dades d’un fitxer dins un programa, cal tenir molt clar com s’hi estructuren. Dins un fitxer es poden emmagatzemar tota mena de valors de qualsevol tipus de dades. La part més important és que aquests valors s’emmagatzemen en forma de seqüència, un rere l’altre. Per tant, com aviat veureu, la manera més habitual de tractar fitxers és seqüencialment, de manera semblant a com es fa per llegir-les del teclat, mostrar-les per pantalla o recórrer les posicions d’un <em>array</em>.
</p>

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10m3u6_02.png" class="imgB" title="Un exemple d&#039;accés seqüencial a dades: el missatge d&#039;un telègraf. Font: Wallace Study-Telegraph/1" alt="Un exemple d&#039;accés seqüencial a dades: el missatge d&#039;un telègraf. Font: Wallace Study-Telegraph/1" /></li><li><small>Un exemple d&#039;accés seqüencial a dades: el missatge d&#039;un telègraf. Font: Wallace Study-Telegraph</small></li>
</ul></div>

</p>
<div class="iocimportant"><div class="ioccontent">
<p>
S’anomena <strong>accés seqüencial</strong> al tractament d’un conjunt d’elements de manera que només és possible accedir-hi d’acord al seu l’ordre d’aparició. Per poder tractar un element, cal haver tractat tots els elements anteriors.
</p>
</div></div>
<p>
Java, juntament amb d’altres llenguatges de programació, diferencia entre dos tipus de fitxers segons com es representen els valors emmagatzemats dins un fitxer. 
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
En els fitxers <strong>orientats a caràcter</strong>, les dades es representen com una seqüència de cadenes de text, on cada valor es diferencia de l’altre usant un delimitador. En canvi, en els fitxers <strong>orientats a byte</strong>, les dades es representen directament d’acord al seu format en binari, sense cap separació.
</p>
</div></div>
<p>
Si bé, a grans trets, l’accés seqüencial a les dades segueix el mateix esquema independentment del tipus de fitxer, cada cas té certes particularitats que fa interessant estudiar-los de manera diferenciada. 
</p>

<h2><a id="acces_sequeencial_a_fitxers_orientats_a_caracter" >Accés seqüencial a fitxers orientats a caràcter</a></h2>
<div class="level2">

<p>
Un fitxer orientat a caràcter no és més que un document de text, com el que podríeu generar amb qualsevol editor de text simple. Els valors estan emmagatzemats segons la seva representació en cadena de text, exactament en el mateix format que heu usat fins ara per entrar dades des del teclat. De la mateixa manera, els diferents valors es distingeixen en estar separats entre ells amb un delimitador, que per defecte és qualsevol conjunt d’espais en blanc o salt de línia. Tot i que aquests valors es puguin distribuir en línies de text diferents, conceptualment, es pot considerar que estan organitzats un rere l’altre, seqüencialment, com les paraules a la pàgina d’un llibre.
</p>

<p>
El següent podria ser el contingut d’un fitxer orientat a text on hi ha deu valors de tipus real:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">1,5 0,75 -2,35 18 9,4 3,1416 -15,785 </div></li><li class="li1"><div class="de1">-200,4 2,56 9,3785</div></li></ol></pre>

<p>
I el d’un fitxer amb 4 valors de tipus <code>String</code> (“Hi”, “havia”, “una” i “vegada…”):
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">Hi havia una vegada...</div></li></ol></pre>

<p>
El principal avantatge d’un fitxer d’aquest tipus és, doncs, que resulta molt senzill inspeccionar el seu contingut, generar-los d’acord a les vostres necessitats o representar quin ha de ser el seu contingut dins del text d’un altre document, com tot just s’acaba de fer.
</p>

</div>

<h3><a id="inicialitzacio" >Inicialització</a></h3>
<div class="level3">

<p>
Per al cas dels fitxers orientats a caràcter, cal usar dues classes diferents segons si el que es vol és llegir o escriure dades a un fitxer. Normalment, això no és gaire problemàtic, ja que en un bloc de codi donat només es duran a terme operacions de lectura de dades o d’escriptura sobre un mateix fitxer, però no els dos tipus d’operació alhora. Normalment, es llegeixen les dades a l’inici del programa, igual que es pot demanar escriure-les usant el teclat, i es desen quan es disposa dels resultats que cal calcular, com quan correspondria mostrar-les per pantalla.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Per tractar de manera senzilla fitxers orientats a caràcter, Java ofereix les classes <code>Scanner</code>, pertanyent al <em>package</em> <code>java.util</code>, i <code>PrintStream</code>, pertanyent al <em>package</em> <code>java.io</code>.
</p>
</div></div>
<p>
Com en el cas de qualsevol altra classe que us calgui usar dins el vostre programa, abans de poder realitzar cap operació és imprescindible inicialitzar-la, de manera que es disposi d’una variable sobre la qual es poden invocar els mètodes corresponents.
</p>

</div>

<h4><a id="scanner" >Scanner</a></h4>
<div class="level4">

<p>
La classe que permet dur a terme la lectura de dades des d’un fitxer orientat a caràcter és exactament la mateixa que permet llegir dades des del teclat. Al cap i a la fi, els valors emmagatzemats en els fitxers d’aquest tipus es troben exactament en el mateix format que heu usat fins ara per entrar informació als vostres programes: una seqüència de cadenes de text. L’única diferència és que aquests valors no es demanen a l’usuari durant l’execució, sinó que són escrits tots amb anterioritat.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Recordeu que per usar la classe Scanner us cal importar-la des del <em>package</em> java.util.
</p>
</div></div>
<p>
Per tal de processar dades des d’un fitxer, la classe <code>Scanner</code> permet usar una ruta com a paràmetre per inicialitzar-la.  El codi següent mostra l’esquema bàsic d’inicialització d’una variable d’aquest tipus de manera que es llegeixin dades des d’un fitxer.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">Scanner lectorFitxer = new Scanner(File f);</div></li></ol></pre>

<p>
El paràmetre <code>f</code> es correspon a qualsevol variable de tipus <code>File</code> prèviament inicialitzada correctament. En fer-ho, cal tenir en compte que la classe <code>Scanner</code> també es comporta com un tipus compost. Per tant, en el cas de treballar amb diferents fitxers, caldrà inicialitzar diferents variables.
</p>

<p>
Per exemple, per inicialitzar una variable de tipus <code>Scanner</code> de manera que permeti llegir dades des del fitxer ubicat a la ruta “C:\Programes\Unitat 6\Apartat 2\Exemples\Document.txt”, caldria fer:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">File fitxer = new File(&quot;C:\Programes\Unitat 6\Apartat 2\Exemples\Document.txt&quot;);</div></li><li class="li1"><div class="de1">Scanner lectorFitxer = new Scanner(fitxer );</div></li></ol></pre>

</div>

<h4><a id="printstream" >PrintStream</a></h4>
<div class="level4">

<p>
Per escriure dades a un fitxer, la classe que cal usar és <code>PrintStream</code>.  Igual com amb <code>Scanner</code>, per inicialitzar-la correctament només cal indicar la ruta del fitxer amb el qual treballar. En aquest cas, en tractar-se d’escriptura, la ruta pot indicar un fitxer que pot existir o no dins el sistema. En el cas d’indicar un fitxer que no existeixi, se’n crearà un de nou. En el cas que ja existeixi, les dades contingudes dins del fitxer es perden totalment i aquest queda en blanc, amb mida igual a 0. 
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Per usar la classe PrintStream us cal importar-la des del <em>package</em> java.io.
</p>
</div></div><pre class="code java"><ol><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.PrintStream;</div></li><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">PrintStream escriptorFitxer = new PrintStream(File f);</div></li></ol></pre>

<p>
En aquest cas, per inicialitzar una variable de tipus <code>PrintStream</code> de manera que permeti escriure dades a un nou fitxer ubicat a la ruta “C:\Programes\Unitat 6\Apartat 2\Exemples\Document.txt”, caldria fer el següent. Com podeu veure, l’esquema és pràcticament idèntic al de <code>Scanner</code>. Però en aquest cas es prepara el fitxer per a l’escriptura.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.PrintStream;</div></li><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">File fitxer = new File(&quot;C:\Programes\Unitat 6\Apartat 2\Exemples\Document.txt&quot;);</div></li><li class="li1"><div class="de1">PrintStream escriptorFitxer = new PrintStream(fitxer );</div></li></ol></pre>
<div class="iocimportant"><div class="ioccontent">
<p>
Alerta, però, ja que el tractament seqüencial de dades mitjançant <code>PrintStream</code> només permet treballar amb fitxers nous. Si la ruta especificada es refereix a un fitxer que ja existeix, el seu contingut serà eliminat totalment.
</p>
</div></div>
</div>

<h3><a id="control_d_errors" >Control d&#039;errors</a></h3>
<div class="level3">

<p>
Quan es realitzen operacions de lectura i escriptura sobre fitxers poden passar moltes situacions anòmales. Des que, simplement, el fitxer  no existeixi a la ruta especificada, fins a que hi hagi algun error en el sistema d’entrada/sortida de l’ordinador o el fitxer estigui corromput i l’operació es vegi interrompuda inesperadament. El tractament de dades amb fitxers és un procés molt més delicat del que aparenta inicialment.
</p>

<p>
El llenguatge Java considera imprescindible tenir en consideració totes aquestes circumstàncies especials, a les quals anomena <em>excepcions</em>. Per controlar-les, disposa d’un mecanisme una mica especial que és obligatori usar sempre, ja que en cas de no fer-ho s’indicarà que hi ha un error de compilació. Per tant, abans de continuar, és necessari conèixer com funciona el mecanisme de control d’excepcions, ja que en cas contrari no us serà possible dur a terme cap programa que tracti fitxers. Aquesta secció no té cap intenció d’explicar-ho en la seva totalitat, només pretén mostrar-vos el mínim imprescindible per poder seguir endavant, i treballar amb fitxers.
</p>

<p>
Per començar, i veure que no és possible compilar un programa que no controli excepcions en treballar amb fitxers, proveu el programa següent al vostre entorn de treball. D’acord al seu codi, aquest hauria d’obrir un fitxer anomenat “Document.txt” que hi ha la carpeta de treball de l’aplicació.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class ObrirFitxer {</div></li><li class="li1"><div class="de1">    public static void main(String[] args) {</div></li><li class="li1"><div class="de1">      ObrirFitxer programa = new ObrirFitxer();</div></li><li class="li1"><div class="de1">      programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    File f = new File(&quot;Document.txt&quot;);</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(f);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Fitxer obert correctament.&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
En fer-ho, podreu veure com el compilador de Java es queixa d’un error d’aquest estil. 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">unreported exception java.io.FileNotFoundException; must be caught or declared to be thrown</div></li></ol></pre>

<p>
El compilador ha detectat que, donada aquesta inicialització, pot succeir una excepció en el procés d’entrada / sortida, però el codi del programa no l’està controlant (<em>unreported exception …; must be caught</em>, “excepció no declarada ni controlada”, en anglès). Concretament, avisa que pot donar-se el cas d’intentar obrir un fitxer que no existeix (<em>FileNotFound</em>, “fitxer no trobat”, en anglès ). Per evitar aquest error, totes les instruccions vinculades a treballar amb fitxers han d’estar dins del que s’anomena una sentència <code>try/catch</code>.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Una sentència <strong>try/catch</strong> es composa de dos blocs de codi. Un per indicar les instruccions que cal anar executant mentre no hi ha excepcions (bloc <code>try</code>), i un altre en el moment que se’n produeixi qualsevol (bloc <code>catch</code>).
</p>
</div></div>
<p>
La sintaxi d’aquest bloc de codi té una certa similitud amb una sentència <code>if/else</code>, des de la perspectiva que es creen dos blocs de codi. Un d’ells s’executa només si es dóna una condició, i l’altre en cas contrari. La sintaxi és la següent:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">try {</div></li><li class="li1"><div class="de1">  //Codi amb les instruccions per fer operacions d'entrada / sortida.</div></li><li class="li1"><div class="de1">  //...</div></li><li class="li1"><div class="de1">} catch (Exception e) {</div></li><li class="li1"><div class="de1">  //Codi en el cas que hi hagi un error en qualsevol operació anterior</div></li><li class="li1"><div class="de1">  //...</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10m3u6_03.png" class="imgB" title="La sentència catch captura l&#039;excepció, per tractar-la. Font: Rdikeman" alt="La sentència catch captura l&#039;excepció, per tractar-la. Font: Rdikeman" /></li><li><small>La sentència catch captura l&#039;excepció, per tractar-la. Font: Rdikeman</small></li>
</ul></div>

</p>

<p>
La principal diferència amb un bloc <code>if/else</code> és que no hi ha cap condició lògica a comprovar per decidir quin bloc cal executar. Dins el bloc <code>try</code> s’escriuen normalment les instruccions del programa. Si en qualsevol moment durant l’execució es produeix una excepció en alguna operació d’entrada / sortida, les instruccions dins d’aquest bloc deixen d’executar-se immediatament, i el flux de control del programa salta a la primera instrucció del bloc <code>catch</code>. Llavors, s’executen totes les instruccions dins d’aquest bloc. Si no es produeix cap excepció dins el bloc <code>try</code>, mai s’executa el bloc <code>catch</code>. Per tant, dins del bloc <code>catch</code> es posen les instruccions per tractar que ha succeït un error.
</p>

<p>
Partint de la traducció del nom de la sentència de l’anglès, bàsicament diu “intenta (<em>try</em>) fer això, i si mai hi ha cap excepció durant el procés, la captures (<em>catch</em>) i la tractes.”
</p>

<p>
La manera més gràfica de veure aquest fet és directament amb un exemple de codi. Escriviu el programa següent al vostre entorn de treball. Primer de tot, veureu que ja no hi ha cap error de compilació, ja que la instrucció per inicialitzar <code>Scanner</code> ara està dins una sentència <code>try/catch</code>. Un cop escrit, executeu-lo sense que hi hagi un fitxer amb aquest nom, i en el cas contrari. Veureu com el resultat del programa serà diferent. La <span class="figref"><a href="#Figure2"><span>figura</span></a></span> mostra un esquema del flux de control del programa en cada cas.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class ObrirFitxer {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    ObrirFitxer programa = new ObrirFitxer();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      //Bloc &quot;try&quot;: operacions d'entrada / sortida</div></li><li class="li1"><div class="de1">      //S'intenta obrir un fitxer per a lectura  </div></li><li class="li1"><div class="de1">      File f = new File(&quot;Document.txt&quot;);</div></li><li class="li1"><div class="de1">      Scanner lector = new Scanner(f);</div></li><li class="li1"><div class="de1">      //El fitxer existeix. Tot correcte</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Fitxer obert correctament.&quot;);</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Enhorabona!&quot;);</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Bloc &quot;catch&quot;: Tractament d'errors</div></li><li class="li1"><div class="de1">      //S'ha produït una excepció en algun lloc del bloc &quot;try&quot;!  </div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Les instruccions fora de la sentència &quot;try/catch&quot; sempre s'executen</div></li><li class="li1"><div class="de1">    //Igual que les que hi ha després d'una sentència &quot;if/else&quot;</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Finalització del programa...&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>
<div class="iocfigure"><a name="Figure2"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Esquema de flux de control davant d’un bloc try-catch.

</figcaption><img src="../media/ic10m3u6_04.png" alt="" /></figure>
</div>
<p>
Si us fixeu en l’exemple, aquest també mostra una particularitat de la sintaxi d’aquesta sentència. A l’inici del bloc <code>catch</code> hi ha una variable declarada, amb l’identificador <strong>e</strong>, de manera molt semblant a com es faria amb el paràmetre d’un mètode: <strong>(Exception e)</strong>. Aquesta variable pertany a la classe <code>Exception</code>, que està al <em>package</em> <code>java.lang</code> (i per tant, no cal importar). 
</p>
<div class="iocnote"><div class="ioccontent">
<p>
No s’haurien de dur a terme operacions d’entrada / sortida dins un bloc <code>catch</code>
</p>
</div></div><div class="iocimportant"><div class="ioccontent">
<p>
Les variables de la classe <strong>Exception</strong> contenen informació sobre l’excepció que ha desencadenat el bloc <code>catch</code> on pertanyen. Java s’encarrega d’inicialitzar-les correctament sempre que es produeix alguna excepció. 
</p>
</div></div>
<p>
Per tant, només us heu de preocupar que ja disposeu d’aquesta variable per poder descriure quin error s’ha produït exactament. Aquesta descripció és sempre una cadena de text, que pot ser impresa de la mateixa manera que es faria amb una variable de tipus <code>String</code>. Quan es produeix una excepció, si el codi afectat és dins el mètode <code>inici()</code>, normalment n’hi ha prou a mostrar el missatge d’error per pantalla. 
</p>

<p>
Ara bé, si el codi és dins un altre mètode auxiliar, i aquest a la seva declaració indica que té un paràmetre de sortida, cal tenir en compte que dins el codi és sempre obligatori invocar la sentència <code>return</code>, tant si ha succeït una excepció com si no. En cas contrari, Java dóna un error de compilació. Donat aquest fet, caldrà que dins del bloc <code>catch</code> s’invoqui <code>return</code> amb algun valor que es consideri no vàlid, i que sigui <em>a posteriori</em> quan es comprovi si el valor retornat en invocar aquest mètode és vàlid o no.
</p>

<p>
A mesura que aneu veient nous aspectes del tractament de fitxers al llarg de l’apartat, es veurà més clar el funcionament de la sentència <code>try/catch</code> i el tractament d’excepcions, especialment pel que fa a la detecció d’errors a mètodes auxiliars.
</p>

</div>

<h3><a id="lectura_de_dades" >Lectura de dades</a></h3>
<div class="level3">

<p>
Des del punt de vista d’instruccions que cal executar, la lectura seqüencial de dades des d’un fitxer orientat a caràcter és pràcticament igual a llegir dades des del teclat. Els valors es van llegint de manera ordenada, des de l’inici de la seqüència que representen fins al final. De fet, ara que ja coneixeu què és una classe, i que aquestes es poden comportar com tipus compostos, com inicialitzar-les sobre una variable i com invocar mètodes correctament a partir d’aquesta variable, és un bon moment per recapitular sobre el funcionament de la classe <code>Scanner</code>, amb vista a mostrar com dur a terme la lectura de dades des d’un fitxer.
</p>

<p>
Les operacions de lectura usant <code>Scanner</code> es duen a terme mitjançant la invocació dels mètodes que ofereix, resumits a la <span class="tabref"><a href="#Table2"><span>taula</span></a></span>, els quals avaluen el valor tot just llegit.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table2"><span>Taula: </span></a>Mètodes de lectura de dades de la classe <code>Scanner</code></div>
<div class="table"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Mètode            </th><th class="col1 leftalign"> Tipus de dada llegida    </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> <code>nextByte()</code>    </td><td class="col1 leftalign"> <code>byte</code>                 </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> <code>nextShort()</code>   </td><td class="col1 leftalign"> <code>short</code>                </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> <code>nextInt()</code>     </td><td class="col1 leftalign"> <code>int</code>                  </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> <code>nextLong()</code>    </td><td class="col1 leftalign"> <code>long</code>                 </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> <code>nextFloat()</code>   </td><td class="col1 leftalign"> <code>float</code>                </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> <code>nextDouble()</code>  </td><td class="col1 leftalign"> <code>double</code>               </td>
	</tr>
	<tr class="row7">
		<td class="col0"> <code>nextBoolean()</code> </td><td class="col1 leftalign"> <code>boolean</code>              </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign"> <code>next()</code>        </td><td class="col1"> <code>String</code> (una paraula) </td>
	</tr>
	<tr class="row9">
		<td class="col0 leftalign"> <code>nextLine()</code>    </td><td class="col1 leftalign"> <code>String</code> (una frase)   </td>
	</tr>
</table></div>
</div>
<p>
En el cas d’un fitxer, la variable de tipus <code>Scanner</code> gestiona internament un apuntador que sempre indica sobre quin valor actuaran les operacions de lectura. Cada cop que es fa una lectura, l’apuntador avança automàticament fins al valor següent dins el fitxer, i no hi ha cap manera de fer-lo recular. Quan una variable de tipus <code>Scanner</code> s’inicialitza, aquest apuntador es troba en el primer valor dins el fitxer. Aquest procés es va repetint fins que s’han llegit tants valors com es desitja. La <span class="figref"><a href="#Figure3"><span>figura</span></a></span> mostra un petit esquema d’aquest procés, recalcant com avança l’apuntador a l’hora de fer operacions de lectura sobre un fitxer que conté valors de tipus enter.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Un cop s’ha llegit un valor, aquest no pot ser “rellegit”.
</p>
</div></div><div class="iocfigure"><a name="Figure3"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Lectura seqüencial de valors en un fitxer orientat a caràcter

</figcaption><img src="../media/ic10m3u6_05.png" alt="" /></figure>
</div>
<p>
Un cop s’ha mostrat com funciona l’apuntador intern en llegir valors des d’un fitxer, val la pena tornar a repassar la diferència entre el mètode <code>next()</code> i <code>nextLine()</code>, ja que ambdós avaluen una cadena de text. El primer només llegeix una paraula individual, considerant “paraula” un conjunt de caràcters que no estan separats per espais o salts de línia. Aquest conjunt de caràcters poden ser tant paraules, tal com es trobarien en un diccionari (“casa”, “hola”, etc.), com valors numèrics expressats en format text (“2”, “3,14”, “1024”, etc.). En canvi, <code>nextLine()</code> llegeix una frase completa. Concretament, el que llegeix és tot el text que hi ha entre la posició actual de l’apuntador i el proper salt de línia. L’apuntador es posa llavors a l’inici de la línia següent. 
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Els diferents valors es distingeixen en separar-se per espais o salts de línia.
</p>
</div></div>
<p>
Un cop s’ha finalitzat la lectura de les dades del fitxer, ja siguin totes o només una part, i ja no cal llegir-ne més, és imprescindible executar un mètode especial anomenat <code>close()</code>. Aquest indica al sistema operatiu que el fitxer ja no està essent utilitzat pel programa. Això és molt important, ja que mentre un fitxer es considera en ús, el seu accés es pot veure limitat. Si no invoqueu <code>close()</code>, el sistema operatiu pot trigar un temps a adonar-se que el fitxer ja no es troba en ús tot i que el vostre programa ja hagi finalitzat. Sempre cal tancar el fitxer un cop heu finalitzat totes les operacions d’entrada / sortida.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
El sistema operatiu diu que un fitxer on s’estan fent operacions d’entrada / sortida està en ús o obert. Si no, es diu que està tancat.
</p>
</div></div>
<p>
El programa següent mostra un exemple de com llegir deu valors enters des d’un fitxer anomenat “Enters.txt”, ubicat a la seva carpeta de treball. Aquest fitxer de text l’haureu de crear vosaltres, garantint que conté exactament 10 valors enters, separats entre ells per espais en blanc o salts de línia. Fixeu-vos com totes les instruccions relatives a la lectura del fitxer, les operacions d’entrada / sortida, són dins una sentència <code>try/catch</code>. També, fixeu-vos que en acabar la lectura, s’invoca el mètode <strong>close)</strong>.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class LlegirEnters {</div></li><li class="li1"><div class="de1">  public static final int NUM_VALORS = 10;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    LlegirEnters programa = new LlegirEnters();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">      try {</div></li><li class="li1"><div class="de1">        //S'intenta obrir el fitxer</div></li><li class="li1"><div class="de1">        File f = new File(&quot;Enters.txt&quot;);</div></li><li class="li1"><div class="de1">        Scanner lector = new Scanner(f);</div></li><li class="li1"><div class="de1">        //Si s'executa aquesta instrucció, s'ha obert el fitxer</div></li><li class="li1"><div class="de1">        for (int i = 0; i &lt; NUM_VALORS; i ++) {</div></li><li class="li1"><div class="de1">          int valor = lector.nextInt();</div></li><li class="li1"><div class="de1">          System.out.println(&quot;El valor llegit és: &quot; + valor);</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">        //Cal tancar el fitxer</div></li><li class="li1"><div class="de1">        lector.close();</div></li><li class="li1"><div class="de1">      } catch (Exception e) {</div></li><li class="li1"><div class="de1">        //Excepció!</div></li><li class="li1"><div class="de1">        System.out.println(&quot;Error: &quot; + e);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Una diferència important a l’hora de tractar amb fitxers respecte a llegir dades del teclat és que les operacions de lectura no són producte d’una interacció directa amb l’usuari, que és qui escriu les dades. Només es pot treballar amb les dades que hi ha al fitxer i res més. Això té dos efectes sobre el procés de lectura.
</p>

<p>
D’una banda, recordeu que quan es duu a terme el procés de lectura d’una seqüència de valors, sempre cal anar amb compte d’usar el mètode adient al tipus de valor que s’espera que vingui a continuació. Saber quin tipus de valor s’espera és quelcom que heu decidit vosaltres a l’hora de fer el programa, però res garanteix que, en escriure el fitxer de text, no us hagueu equivocat sense voler, com pot passar quan escriviu dades mitjançant el teclat. Ara bé, en aquest cas, com que opereu amb fitxers, i no pel teclat, no hi ha l’opció de demanar simplement a l’usuari que el torni a escriure. Per tant, el programa hauria de dir que s’ha produït un error ja que el fitxer no té el format correcte i finalitzar el procés de lectura.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Els mètodes next() o nextLine() mai poden donar error, ja que els valors en un fitxer orientat a caràcter sempre es poden considerar cadenes de text.
</p>
</div></div>
<p>
D’altra banda, també cal que controleu que mai llegiu més valors dels que hi ha disponibles per llegir. En un cas com aquest, a l’hora de fer entrada de dades pel teclat, el programa simplement es bloquejava, esperant que l’usuari escrivís nous valors. Quan opereu amb fitxers això no succeeix. Intentar llegir un nou valor quan l’apuntador ja ha superat el darrer disponible es considera erroni. Un cop s’arriba al final del fitxer, ja no queda més remei que invocar <code>close()</code> i finalitzar la lectura.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Si el tipus llegit no es correspon al mètode invocat (per exemple, s’ha invocat el mètode <code>nextInt()</code> quan l’apuntador és sobre un real) o s’intenta fer una lectura quan l’apuntador ja ha superat tots els valors del fitxer, es produirà una excepció.
</p>
</div></div>
<p>
Per veure-ho, proveu d’executar l’exemple anterior amb fitxer on, o bé algun dels valors continguts no és de tipus enter, o el nombre de valors emmagatzemats és inferior a deu.
</p>

<p>
<strong>Repte 1</strong>. Feu un programa que llegeixi successivament 15 valors de tipus real des d’un fitxer anomenat “Reals.txt”. Aquest fitxer el podeu fer vosaltres mateixos. El programa ha de mostrar quin dels valors dins el fitxer és el més gran. 
</p>

</div>

<h3><a id="escriptura_de_dades" >Escriptura de dades</a></h3>
<div class="level3">

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10m3u6_06.png" class="imgB" title=" L&#039;escriptura seqüencial de valors també és com usar una màquina d&#039;escriure. Font: LjL/-7" alt=" L&#039;escriptura seqüencial de valors també és com usar una màquina d&#039;escriure. Font: LjL/-7" /></li><li><small> L&#039;escriptura seqüencial de valors també és com usar una màquina d&#039;escriure. Font: LjL</small></li>
</ul></div>

</p>

<p>
En aquest cas, l’escriptura seqüencial de dades en un fitxer orientat a caràcter és molt semblant a mostrar text per pantalla. Les dades es van escrivint una rere l’altra, amb l’opció de fer-ho consecutivament o separades per línies. Un cop s’ha escrit una dada, ja no hi ha marxa enrere. No és possible escriure informació abans o enmig de valors que ja estan escrits.
</p>

<p>
En aquest cas, les operacions d’escriptura es porten a terme mitjançant els mètodes proporcionats per la classe <code>PrintStream</code>. Aquests són bàsicament dos, ara ja vells coneguts vostres, que accepten com a únic paràmetre qualsevol tipus primitiu de dades, o una cadena de text: <code>print(…)</code> i <code>println(…)</code>. La diferència és que el primer només escriu el valor usat com a paràmetre en format cadena de text, mentre que el segon també inclou automàticament un salt de línia, ja que “println” significa, “<em>print line</em>” (“imprimir línia”, en anglès).
</p>
<div class="iocfigure"><a name="Figure4"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Escriptura seqüencial de valors en un fitxer orientat a caràcter

</figcaption><img src="../media/ic10m3u6_07.png" alt="" /></figure>
</div>
<p>
Com en el cas de la lectura, la classe <code>PrintStream</code> també gestiona un apuntador que li permet saber a partir de quina posició del text ha d’anar escrivint. Cada cop que s’invoca un dels seus mètodes d’escriptura, l’apuntador avança automàticament, i no és possible fer-lo recular. A efectes pràctics, aquest apuntador sempre està al final del fitxer, de manera que, a mesura que es van escrivint dades, el fitxer va incrementant la seva mida. La <span class="figref"><a href="#Figure4"><span>figura</span></a></span> mostra un esquema del funcionament de les escriptures.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Recordeu que <code>PrintStream</code> només opera amb fitxer nous. Si s’escriu en un fitxer existent, se sobreescriu totalment.
</p>
</div></div>
<p>
Un aspecte que val la pena remarcar, i que preveu la figura, és que el procés d’escriptura no genera automàticament el delimitador entre valors. Per tant, és responsabilitat del vostre programa escriure els espais en blanc o salt de línia corresponents. En cas contrari, els valors quedaran enganxats, i en una posterior lectura s’interpretaran com un únic valor. Per exemple, si s’escriu el valor enter 2 i després el 4, sense preveure cap delimitador, en el fitxer s’haurà escrit al final el text del valor 24.
</p>

<p>
El codi següent serveix com a exemple d’un programa que escriu un fitxer dins la seva carpeta de treball anomenat “Enters.txt”. Aquest conté 20 valors enters, de manera que, començant per l’1, cadascun sigui el doble de l’anterior. Compileu-lo i proveu-lo. Fixeu-vos que si ja existia un fitxer amb aquest nom, quedarà totalment sobreescrit. Després, podeu intentar llegir-lo amb el programa d’exemple anterior per llegir 10 valors enters i mostrar-los per pantalla. 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.PrintStream;</div></li><li class="li1"><div class="de1">public class EscriureEntersDobles {</div></li><li class="li1"><div class="de1">  public static final int NUM_VALORS = 20;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    EscriureEntersDobles programa = new EscriureEntersDobles();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">      try {</div></li><li class="li1"><div class="de1">        //S'intenta obrir el fitxer</div></li><li class="li1"><div class="de1">        File f = new File(&quot;Enters.txt&quot;);</div></li><li class="li1"><div class="de1">        PrintStream escriptor = new PrintStream(f);</div></li><li class="li1"><div class="de1">        //S'escriu el primer valor, que no necessita un espai abans</div></li><li class="li1"><div class="de1">        int valor = 1;</div></li><li class="li1"><div class="de1">        escriptor.print(valor);</div></li><li class="li1"><div class="de1">        //Es van generant la resta de valors i escrivint</div></li><li class="li1"><div class="de1">        for (int i = 1; i &lt; 20; i ++) {</div></li><li class="li1"><div class="de1">          //S'escriu abans com delimitador un espai en blanc</div></li><li class="li1"><div class="de1">          escriptor.print(&quot; &quot;);</div></li><li class="li1"><div class="de1">          //Es calcula i escriu el nou valor</div></li><li class="li1"><div class="de1">          valor = valor*2;</div></li><li class="li1"><div class="de1">          escriptor.print(valor);</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">        //Cal tancar el fitxer</div></li><li class="li1"><div class="de1">        escriptor.close();</div></li><li class="li1"><div class="de1">        System.out.println(&quot;Fitxer escrit satisfactòriament.&quot;);</div></li><li class="li1"><div class="de1">      } catch (Exception e) {</div></li><li class="li1"><div class="de1">        //Excepció!</div></li><li class="li1"><div class="de1">        System.out.println(&quot;Error: &quot; + e);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>
<div class="iocimportant"><div class="ioccontent">
<p>
En acabar l’escriptura d’un fitxer també és imprescindible invocar el mètode <strong>close()</strong> sobre la variable de tipus <code>PrintStream</code>.
</p>
</div></div>
<p>
En el cas de les operacions d’escriptura, el tancament del fitxer encara és molt més important. Això es deu al fet que els sistemes operatius sovint porten a terme de manera diferida l’actualització de les dades. O sigui, el fet d’executar una instrucció d’escriptura no vol dir que immediatament aquestes dades ja estan escrites al fitxer. Pot passar un interval de temps variable entre les dues accions. Només a l’hora d’executar el mètode <code>close()</code> es força a què totes les dades pendents d’escriure s’actualitzin definitivament al fitxer.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
El procés d’actualització de les dades es coneix com <em>flush</em> (“tirar de la cadena”, en anglès).
</p>
</div></div>
<p>
<strong>Repte 2</strong>. Modifiqueu l’exemple de manera que els valors enters, en lloc d’estar tots escrits en una sola línia en el fitxer de text, estiguin dividits en 4 línies. A cada línia hi ha d’haver escrits 5 valors.
</p>

</div>

<h2><a id="aspectes_importants_de_l_acces_sequeencial" >Aspectes importants de l&#039;accés seqüencial</a></h2>
<div class="level2">

<p>
Un cop s’ha presentat com dur a terme l’accés seqüencial a un fitxer orientat a caràcter, i ja sabeu exactament com es materialitza en sentències del Java, val la pena exposar algunes situacions o problemàtiques que us podeu trobar i que poden complicar el procés. L’objectiu d’aquest apartat és indicar alguns esquemes o estratègies que podeu preveure per dur a terme correctament la lectura o l’escriptura d’un fitxer d’aquest tipus.
</p>

</div>

<h3><a id="deteccio_de_final_de_sequeencia" >Detecció de final de seqüència</a></h3>
<div class="level3">

<p>
Tot i que el procés de lectura seqüencial de fitxers és força semblant a la lectura de dades des del teclat, una de les diferències substancials que cal tenir molt en compte és que el nombre de valors que es poden llegir està fixat pel propi contingut de fitxer. Mai es donarà el cas que el programa es quedi esperant que l’usuari escrigui text. Si s’intenta llegir valors d’un fitxer quan ja s’ha arribat al final de la seqüència i s’han esgotat els valors continguts, es produirà una excepció. Tot i que mitjançant el control d’excepcions es pot detectar i tractar aquest cas, en general, és millor generar codi dins els vostres programes que eviti arribar a aquesta situació. Per això, disposeu bàsicament de tres estratègies:
</p>

<p>
<strong>1. Nombre de valors coneguts a priori</strong>
</p>

<p>
El nombre de valors dins el fitxer ja és conegut dins del programa. Per exemple, si s’espera que el fitxer tingui 9 valors, el programa només hauria de fer 9 lectures i cap més. Si se’n fan menys, no passarà res, a part que deixarem valors sense llegir, però si se’n fan més, es produirà una excepció. Aquest és el cas de l’exemple de lectura que s’ha mostrat.
</p>

<p>
<strong>2. Usar una marca de finalització</strong>
</p>

<p>
El darrer valor no representa realment una dada que es vol tractar, sinó que és un valor especial que identifica el final de la seqüència. Aquest valor no es considera com part dels valors a tractar dins el fitxer, només és una marca de finalització. Ara bé, l’estratègia només val si hi ha valors que no es donaran mai dins la seqüència, ja que en cas contrari és impossible distingir entre un valor que indica la marca de finalització, o un que realment és vàlid i cal tractar. Per exemple, si se sap que tots els valors seran sempre entre -50 i 50, es podria usar un valor -100 com a marca de finalització, tal com mostra l’exemple de fitxer següent. Si el fitxer pogués preveure qualsevol valor, llavors aquesta estratègia no us serveix.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">2 10 8 6 23 -15 0 -2 5 -100</div></li></ol></pre>

<p>
El programa següent seria l’adaptació de l’exemple de lectura de dades des d’un fitxer anomenat “EntersMarca.txt” partint d’aquesta estratègia. Proveu-lo usant fitxers amb diferents valors escrits. En aquest cas, la marca de següent és el valor enter -100.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class LLegirMarcaFi {</div></li><li class="li1"><div class="de1">  public static final int MARCA_FI = -100;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    LLegirMarcaFi programa = new LLegirMarcaFi();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">      try {</div></li><li class="li1"><div class="de1">        //S'intenta obrir el fitxer</div></li><li class="li1"><div class="de1">        File f = new File(&quot;EntersMarca.txt&quot;);</div></li><li class="li1"><div class="de1">        Scanner lector = new Scanner(f);</div></li><li class="li1"><div class="de1">        //Aquesta estratègia es basa en un semàfor</div></li><li class="li1"><div class="de1">        boolean llegir = true;</div></li><li class="li1"><div class="de1">        //Si s'executa aquesta instrucció, s'ha obert el fitxer</div></li><li class="li1"><div class="de1">        while (llegir) {</div></li><li class="li1"><div class="de1">          int valor = lector.nextInt();</div></li><li class="li1"><div class="de1">          if (valor == MARCA_FI) {</div></li><li class="li1"><div class="de1">            //Marca de finalització. Ja s'ha acabat la lectura</div></li><li class="li1"><div class="de1">            llegir = false;</div></li><li class="li1"><div class="de1">          } else {</div></li><li class="li1"><div class="de1">            //Encara no s'ha acabat. Tractar dada</div></li><li class="li1"><div class="de1">            System.out.println(&quot;El valor llegit és: &quot; + valor);</div></li><li class="li1"><div class="de1">          }</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">        //Cal tancar el fitxer</div></li><li class="li1"><div class="de1">        lector.close();</div></li><li class="li1"><div class="de1">      } catch (Exception e) {</div></li><li class="li1"><div class="de1">        //Excepció!</div></li><li class="li1"><div class="de1">        System.out.println(&quot;Error: &quot; + e);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>3. Nombre de valors indicat al propi fitxer </strong>
</p>

<p>
El primer valor de tota la seqüència pot ser un enter que identifica quants valors hi ha escrits a continuació, de manera que el programa mai farà més lectures de les establertes. Per exemple, en el fitxer següent, el primer valor indica que tot seguit hi ha 9 enters. Per tant, un programa no hauria d’intentar llegir-ne més dels indicats, o està garantit que es produirà una excepció.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">9 2 10 8 6 23 -15 0 -2 5</div></li></ol></pre>

<p>
El programa següent seria l’adaptació de l’exemple de lectura de dades des d’un fitxer anomenat “EntersMida.txt” partint d’aquesta estratègia. Proveu-lo usant fitxers amb diferents valors escrits.
</p>

<p>

</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class LlegirMida {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    LlegirMida programa = new LlegirMida();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">      try {</div></li><li class="li1"><div class="de1">        //S'intenta obrir el fitxer</div></li><li class="li1"><div class="de1">        File f = new File(&quot;EntersMida.txt&quot;);</div></li><li class="li1"><div class="de1">        Scanner lector = new Scanner(f);</div></li><li class="li1"><div class="de1">        //Es llegeix la mida</div></li><li class="li1"><div class="de1">        int mida = lector.nextInt();</div></li><li class="li1"><div class="de1">        System.out.println(&quot;Hi ha &quot; +  mida + &quot; valors.&quot;);</div></li><li class="li1"><div class="de1">        //Si s'executa aquesta instrucció, s'ha obert el fitxer</div></li><li class="li1"><div class="de1">        for (int i = 0; i &lt; mida; i ++) {</div></li><li class="li1"><div class="de1">          int valor = lector.nextInt();</div></li><li class="li1"><div class="de1">          System.out.println(&quot;El valor llegit és: &quot; + valor);</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">        //Cal tancar el fitxer</div></li><li class="li1"><div class="de1">        lector.close();</div></li><li class="li1"><div class="de1">      } catch (Exception e) {</div></li><li class="li1"><div class="de1">        //Excepció!</div></li><li class="li1"><div class="de1">        System.out.println(&quot;Error: &quot; + e);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Evidentment, aquests mecanismes no són immunes als errors de programació, ja que pot succeir que us despisteu i que les coses no encaixin. Potser us heu oblidat d’escriure tots els valors que toca al fitxer, que per algun motiu s’hagi truncat o corromput i s’hagi perdut la marca de finalització, o que el nombre de valors escrit al principi no sigui correcte. Per això és important tractar les excepcions i mostrar l’error per pantalla, ja que en operar amb fitxers, mai es pot estar del tot segur que les dades que es volen llegir tindran un format correcte. 
</p>

</div>

<h3><a id="processament_de_les_dades_llegides" >Processament de les dades llegides</a></h3>
<div class="level3">

<p>
Una de les particularitats del tractament seqüencial de dades des d’un fitxer és que, un cop s’inicialitza la variable a usar per accedir-hi, les dades només es poden llegir una rere l’altra, però no és possible recular. L’apuntador del fitxer només avança cada cop que es fa una operació, però no pot retrocedir. Això vol dir que s’hauria de plantejar el processament de les dades de manera que amb un únic recorregut el programa ja sigui possible de fer la tasca en qüestió. Això normalment porta a dos plantejaments possibles.
</p>

<p>
<strong>1. Tractament a mesura que es llegeix</strong>
</p>

<p>
En alguns casos, les tasques que ha de dur a terme el programa es basen en un únic recorregut. Es pot establir un cert paral·lelisme entre una situació en la qual es parteix d’un <em>array</em> on estan disposades ja les dades, i vosaltres per tractar-les en teniu prou a fer un recorregut des del primer al darrer element. En aquest cas, en lloc d’avançar posició a posició dins un <em>array</em>, s’avança valor a valor dins d’un fitxer. Exemples d’aquest cas pot ser trobar el màxim, el mínim, calcular una mitjana, mostrar els valors que compleixen certes condicions per pantalla, etc.
</p>

<p>
Per exemple, el programa següent, el qual, donat un fitxer anomenat “Document.txt” amb diferents paraules, compta la mitjana, sense decimals, de vocals per paraula que hi ha en total (nombre de vocals / nombre de paraules). Per saber quan acaba el fitxer, s’usa la paraula “fi” com a marca (que no ha de ser tractada). Com es pot veure, fins i tot en casos on cal acumular resultats i fer codi una mica complex usant disseny descendent es poden dur a terme les tasques d’una sola passada, si es plantegen correctament.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class MitjanaVocals {</div></li><li class="li1"><div class="de1">  //la paraula &quot;fi&quot; serveix com a marca de final de fitxer</div></li><li class="li1"><div class="de1">  public static final String MARCA_FI = &quot;fi&quot;;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    MitjanaVocals programa = new MitjanaVocals();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {     </div></li><li class="li1"><div class="de1">     try {</div></li><li class="li1"><div class="de1">       //S'intenta obrir el fitxer</div></li><li class="li1"><div class="de1">       File f = new File(&quot;Document.txt&quot;);</div></li><li class="li1"><div class="de1">       Scanner lector = new Scanner(f);</div></li><li class="li1"><div class="de1">       //Dades a recopilar</div></li><li class="li1"><div class="de1">       int numParaules = 0;</div></li><li class="li1"><div class="de1">       int numVocals = 0;    </div></li><li class="li1"><div class="de1">       //Marca de finalització de lectura</div></li><li class="li1"><div class="de1">       boolean llegir = true;</div></li><li class="li1"><div class="de1">       while (llegir) {</div></li><li class="li1"><div class="de1">         String paraula = lector.next();</div></li><li class="li1"><div class="de1">         if (MARCA_FI.equals(paraula)) {</div></li><li class="li1"><div class="de1">           //Marca de final</div></li><li class="li1"><div class="de1">           llegir = false;</div></li><li class="li1"><div class="de1">         } else {</div></li><li class="li1"><div class="de1">           //Tractar dada</div></li><li class="li1"><div class="de1">           numParaules++;</div></li><li class="li1"><div class="de1">           numVocals = numVocals + comptarVocals(paraula);</div></li><li class="li1"><div class="de1">         }</div></li><li class="li1"><div class="de1">       }</div></li><li class="li1"><div class="de1">       System.out.println(&quot;Hi ha &quot; + numParaules + &quot; paraules.&quot;);</div></li><li class="li1"><div class="de1">       System.out.println(&quot;Hi ha &quot; + numVocals + &quot; vocals.&quot;);</div></li><li class="li1"><div class="de1">       double mitjana = numVocals/numParaules;</div></li><li class="li1"><div class="de1">       System.out.println(&quot;La mitjana és &quot; + mitjana);</div></li><li class="li1"><div class="de1">       //Cal tancar el fitxer</div></li><li class="li1"><div class="de1">       lector.close();</div></li><li class="li1"><div class="de1">     } catch (Exception e) {</div></li><li class="li1"><div class="de1">       //Excepció!</div></li><li class="li1"><div class="de1">       System.out.println(&quot;Error: &quot; + e);</div></li><li class="li1"><div class="de1">     }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Compta les vocals en una paraula.</div></li><li class="li1"><div class="de1">   *</div></li><li class="li1"><div class="de1">   * @param paraula Cadena de text on cal comptar les vocals</div></li><li class="li1"><div class="de1">   * @return Nombre de vocals</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public int comptarVocals(String paraula) {</div></li><li class="li1"><div class="de1">    int res = 0;</div></li><li class="li1"><div class="de1">    //Es passa a minúscula tot per fer-ho mes fàcil</div></li><li class="li1"><div class="de1">    paraula = paraula.toLowerCase();</div></li><li class="li1"><div class="de1">    for(int i = 0;i &lt; paraula.length(); i++) {</div></li><li class="li1"><div class="de1">      if (esVocal(paraula.charAt(i))) {</div></li><li class="li1"><div class="de1">        res++;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return res;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Diu si, donat un caràcter en minúscula, aquest és o no una vocal.</div></li><li class="li1"><div class="de1">   *</div></li><li class="li1"><div class="de1">   * @param c Caràcter a comprovar</div></li><li class="li1"><div class="de1">   * @return Si és (true) o no (false) una vocal</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public boolean esVocal(char c) {</div></li><li class="li1"><div class="de1">    switch(c) {</div></li><li class="li1"><div class="de1">        case 'a':</div></li><li class="li1"><div class="de1">        case 'e':</div></li><li class="li1"><div class="de1">        case 'i':</div></li><li class="li1"><div class="de1">        case 'o':</div></li><li class="li1"><div class="de1">        case 'u': return true;</div></li><li class="li1"><div class="de1">        default: return false;</div></li><li class="li1"><div class="de1">    }    </div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>2. Primer lectura i tractament posterior</strong>
</p>

<p>

</p>

<p>
Una altra opció disponible és primer anar emmagatzemant les dades llegides dins un <em>array</em> a mesura que es llegeixen, i posteriorment operar sobre aquest <em>array</em>. Aquest estratègia té el desavantatge que els vostres programes són una mica menys eficients, ja que primer fan la lectura de dades i després realment es dediquen a fer la seva feina. A més a més, ocupen més memòria, ja que cal declarar l’<em>array</em> on desar totes les dades del fitxer. 
</p>

<p>
Malauradament, hi ha situacions on és inevitable fer-ho d’aquesta manera. Qualsevol situació on abans de tractar les dades cal fer alguna modificació que depèn de totes elles, caldrà fer-ho d’aquesta manera. Molts programes d’ordinador precisament per això usen aquesta estratègia. Per exemple, els editors de text o fulls de càlcul fan precisament això. Primer carreguen el fitxer a memòria i posteriorment el mostren per pantalla de manera que us permeten modificar-lo. Fins que no feu “desar”, no s’actualitzen les dades de memòria a disc.
</p>

<p>
L’exemple següent és un altre cas, molt més senzill que un processador de text, en què no es pot fer la feina requerida sense carregar abans les dades a un <em>array</em>. Llegeix les dades d’un fitxer anomenat “Enters.txt”, les ordena, i llavors les escriu en un nou fitxer anomenat “EntersOrdenat.txt”. Per ordenar un conjunt de valors, cal disposar de tots ells alhora. No hi ha cap altra manera. El programa es basa en indicar en el seu primer valor el nombre d’elements del fitxer per saber quants cal llegir. Fixeu-vos també com, mitjançant disseny descendent, es distribueix el codi per tractar cada fitxer en mètodes diferenciats.
</p>

<p>
També fixeu-vos que aquest és un cas en què es fa tractament d’excepcions en un mètode auxiliar, a <code>llegirDades</code>. En un cas com aquest, normalment no es mostra directament l’error per pantalla, sinó que s’invoca la sentència <code>return</code> amb un valor invàlid, i és <strong>inici</strong> qui comprova si aquest mètode ha acabat correctament o incorrectament. Això es deu al fet que tot mètode declarat amb un paràmetre de sortida sempre ha de retornar algun valor, tant si succeeix una excepció com si no.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.PrintStream;</div></li><li class="li1"><div class="de1">import java.util.Arrays;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class OrdenarFitxer {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    OrdenarFitxer programa = new OrdenarFitxer();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    //Es llegeixen els valors</div></li><li class="li1"><div class="de1">    int[] valors = llegirDades(&quot;Enters.txt&quot;);</div></li><li class="li1"><div class="de1">    if (valors != null) {</div></li><li class="li1"><div class="de1">      //S'han pogut llegir les dades correctament</div></li><li class="li1"><div class="de1">      //S'ordenen</div></li><li class="li1"><div class="de1">      Arrays.sort(valors);</div></li><li class="li1"><div class="de1">      //S'escriuen en un nou fitxer</div></li><li class="li1"><div class="de1">      escriureArray(&quot;EntersOrdenats.txt&quot;, valors);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      //Ha succeït un error llegint les dades</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Hi ha hagut un error llegint les dades.&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Donat el nom d'un fitxer, llegeix els seus valors i el carrega en un array</div></li><li class="li1"><div class="de1">   * d'enters.</div></li><li class="li1"><div class="de1">   * @param nom Nom del fitxer</div></li><li class="li1"><div class="de1">   * @return Array amb les dades carregades des del fitxer</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public int[] llegirDades(String nom) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(nom);</div></li><li class="li1"><div class="de1">      Scanner lector = new Scanner(f);</div></li><li class="li1"><div class="de1">      int mida = lector.nextInt();</div></li><li class="li1"><div class="de1">      int[] dades = new int[mida];</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; mida; i++) {</div></li><li class="li1"><div class="de1">        dades[i] = lector.nextInt();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      return dades;</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //No s'han pogut llegir les dades...</div></li><li class="li1"><div class="de1">      return null;</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Donat un nom de fitxer i un array d'enters, l'escriu en aquest fitxer.</div></li><li class="li1"><div class="de1">   *</div></li><li class="li1"><div class="de1">   * @param nom Nom de la ruta del fitxer destinació</div></li><li class="li1"><div class="de1">   * @param dades Array amb les dades que cal escriure</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public void escriureArray(String nom, int[] dades) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      //S'intenta crear el fitxer</div></li><li class="li1"><div class="de1">      File f = new File(nom);</div></li><li class="li1"><div class="de1">      PrintStream escriptor = new PrintStream(f);</div></li><li class="li1"><div class="de1">      //Primer s'escriu el nombre de valors</div></li><li class="li1"><div class="de1">      escriptor.print(dades.length);</div></li><li class="li1"><div class="de1">      //S'escriuen els valors de l'array, separats per espais</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; dades.length; i++) {</div></li><li class="li1"><div class="de1">        escriptor.print(&quot; &quot; + dades[i]);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Fitxer generat satisfactòriament.&quot;);</div></li><li class="li1"><div class="de1">      //Cal tancar el fitxer</div></li><li class="li1"><div class="de1">      escriptor.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error escrivint dades: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Un altre cas on cal usar aquesta estratègia per tractar dades és quan cal modificar alguna de les dades que hi ha en un fitxer orientat a caràcter. Per exemple, suposeu que voleu canviar només un dels seus valors, deixant la resta igual. Atès que <code>PrintStream</code> elimina les dades d’un fitxer tan bon punt s’inicialitza, en realitat no és possible modificar un valor concret. Cal reescriure el seu contingut totalment, preveient els valors que es volen modificar en fer-ho.
</p>

<p>
Per exemple, el programa següent modifica un fitxer orientat a caràcter que conté 10 valors de tipus enter i suma 5 als valors que hi ha a les posicions parell. Per fer-ho, caldrà llegir tots els valors, emmagatzemar-los en un <em>array</em>, fer les modificacions escaients, i després sobreescriure el fitxer original al complet. Per saber quants valors hi ha, s’usa l’estratègia d’indicar-ho a l’inici del fitxer.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.PrintStream;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class ModificarValorsParells {</div></li><li class="li1"><div class="de1">  public static final String NOM_FITXER = &quot;Enters.txt&quot;;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    ModificarValorsParells programa = new ModificarValorsParells();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    //Es llegeixen els valors</div></li><li class="li1"><div class="de1">    int[] valors = llegirDades(NOM_FITXER);</div></li><li class="li1"><div class="de1">    if (valors != null) {</div></li><li class="li1"><div class="de1">      //S'han pogut llegir les dades correctament</div></li><li class="li1"><div class="de1">      //Es modifiquen</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; valors.length; i = i + 2) {</div></li><li class="li1"><div class="de1">        valors[i] = valors[i] + 5;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Es tornen a escriure tots al fitxer original</div></li><li class="li1"><div class="de1">      escriureArray(NOM_FITXER, valors);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      //Ha succeït un error llegint les dades</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Hi ha hagut un error llegint les dades.&quot;);        </div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Donat el nom d'un fitxer, llegeix els seus valors i el carrega en un array</div></li><li class="li1"><div class="de1">   * d'enters.</div></li><li class="li1"><div class="de1">   * @param nom Nom del fitxer</div></li><li class="li1"><div class="de1">   * @return Array amb les dades carregades des del fitxer</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public int[] llegirDades(String nom) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(nom);</div></li><li class="li1"><div class="de1">      Scanner lector = new Scanner(f);</div></li><li class="li1"><div class="de1">      int mida = lector.nextInt();</div></li><li class="li1"><div class="de1">      int[] dades = new int[mida];</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; mida; i++) {</div></li><li class="li1"><div class="de1">        dades[i] = lector.nextInt();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      return dades;</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //No s'han pogut llegir les dades...</div></li><li class="li1"><div class="de1">      return null;</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Donat un nom de fitxer i un array d'enters, l'escriu a aquest fitxer.</div></li><li class="li1"><div class="de1">   *</div></li><li class="li1"><div class="de1">   * @param nom Nom de la ruta del fitxer destinació.</div></li><li class="li1"><div class="de1">   * @param dades Array amb les dades que cal escriure</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public void escriureArray(String nom, int[] dades) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      //S'intenta crear el fitxer</div></li><li class="li1"><div class="de1">      File f = new File(nom);</div></li><li class="li1"><div class="de1">      PrintStream escriptor = new PrintStream(f);</div></li><li class="li1"><div class="de1">      //Primer s'escriu el nombre de valors</div></li><li class="li1"><div class="de1">      escriptor.print(dades.length);</div></li><li class="li1"><div class="de1">      //S'escriuen els valors de l'array, separats per espais</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; dades.length; i++) {</div></li><li class="li1"><div class="de1">        escriptor.print(&quot; &quot; + dades[i]);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Fitxer generat satisfactòriament.&quot;);</div></li><li class="li1"><div class="de1">      //Cal tancar el fitxer</div></li><li class="li1"><div class="de1">      escriptor.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error escrivint dades: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h4><a id="multiples_accessos_al_fitxer" >Múltiples accessos al fitxer</a></h4>
<div class="level4">

<p>
Us podeu trobar casos en què un programa ha de fer moltes operacions senzilles sobre les dades d’un fitxer, de manera que cadascuna d’elles, individualment, es podria fer a mesura que el llegeix el fitxer. Per exemple, suposeu un programa que ha de trobar el màxim, el mínim, i la mitjana aritmètica dels valors a un fitxer. En un cas com aquest, intentar fer moltes coses alhora en una única passada sobre les dades d’un fitxer pot arribar a complicar el codi, o fins i tot trencar el vostre disseny descendent, ja que tindreu blocs de codi que fan moltes coses en paral·lel en lloc de fer una tasca molt concreta i fàcil d’identificar. Es va calculant tot alhora a mesura que es llegeixen les dades, de manera que en lloc de tres mètodes <code>calculMaxim</code>, <code>calculMinim</code> i <code>calculMitjana</code>, podeu acabar amb un de sol anomenat <code>calculMinimMaximMitjana</code>!.
</p>

<p>
Una possible opció en aquest cas seria fer múltiples accessos al mateix fitxer, de manera que es fa un recorregut seqüencial nou per cada tasca individual. El fitxer s’obre, es tracten els valors i es tanca diverses vegades. Ara bé, això no és massa eficient donades les capacitats dels ordinadors moderns, en els quals la memòria és abundant, ja que precisament l’accés a fitxers és un dels punts més lents del sistema. En casos com aquest, el millor és usar l’estratègia de primer llegir els valors i desar-los en un <em>array</em>, i després tractar-lo per dur a terme cada tasca individual.
</p>

<p>
Només seria aconsellable fer múltiples recorreguts en el cas de voler limitar la despesa de memòria del vostre programa. Per exemple, si realment els fitxers són enormes, o el programa ha de funcionar en un ordinador amb una quantitat modesta de memòria. A escala d’aquests materials, no es donarà mai el cas. Al cap i a la fi, recordeu que, actualment, un simple processador de text no té problemes per carregar fitxers amb diversos megabytes d’informació.
</p>

</div>

<h3><a id="fitxers_amb_valors_de_diferents_tipus" >Fitxers amb valors de diferents tipus</a></h3>
<div class="level3">

<p>
Un aspecte que també val la pena tenir en compte és que, tot i que en els exemples mostrats sempre s’ha treballat amb fitxers que contenen valors del mateix tipus, res impedeix barrejar-los. Simplement haureu de tenir sempre present quin és el format del fitxer que llegiu, i seguir-lo fidelment quan n’escriviu un de nou. En casos com aquest, és molt recomanable fer-se un esquema d’aquest format, per tenir-lo sempre present. Llavors, només cal cridar el mètode adient segons el tipus de dada esperat.
</p>

<p>
Per exemple, suposeu un programa que mostra la nota mitjana d’un conjunt d’estudiants. Per cada estudiant, els valors es desen en línies diferents, per facilitar la seva comprensió, d’acord al format següent. A la darrera línia hi ha la paraula “fi” com a marca de final.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">Nom(String) Cognom(String) Número de notes(enter) Nota1(real) ... NotaN(real)</div></li></ol></pre>

<p>
Per exemple:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">Maria Almerich 3 4 3,5 6</div></li><li class="li1"><div class="de1">Joan Sebastià 5 4,5 8,5 5 6,5 7</div></li><li class="li1"><div class="de1">Carme Gonzàlez 4 6,5 8,75 10 9,5 </div></li><li class="li1"><div class="de1">fi</div></li></ol></pre>

<p>
El codi que el resol podria ser el següent. Estudieu-lo amb atenció, ja que pot resultar una mica més complicat, a l’hora de llegir dades de diferents tipus barrejats. El punt més interessant és el fet que una variable de tipus <code>Scanner</code> pot ser usada com a paràmetre d’entrada d’un mètode. En aquest aspecte, en tractar-se d’un tipus compost, no és diferent d’un <code>String</code> o un <em>array</em>.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class LlegirNotes {</div></li><li class="li1"><div class="de1">  //la paraula fi serveix com a marca de final de fitxer</div></li><li class="li1"><div class="de1">  public static final String MARCA_FI = &quot;fi&quot;;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    LlegirNotes programa = new LlegirNotes();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(&quot;Notes.txt&quot;);</div></li><li class="li1"><div class="de1">      Scanner lector = new Scanner(f);</div></li><li class="li1"><div class="de1">      boolean llegir = true;</div></li><li class="li1"><div class="de1">      while (llegir) {</div></li><li class="li1"><div class="de1">        String nom = lector.next();</div></li><li class="li1"><div class="de1">        if (MARCA_FI.equals(nom)) {</div></li><li class="li1"><div class="de1">          llegir = false;</div></li><li class="li1"><div class="de1">        } else {</div></li><li class="li1"><div class="de1">          String cognom = lector.next();</div></li><li class="li1"><div class="de1">          System.out.print(&quot;Estudiant: &quot; + nom + &quot; &quot; + cognom);</div></li><li class="li1"><div class="de1">          //Noteu com un scanner es pot passar com paràmetre</div></li><li class="li1"><div class="de1">          double mitjana = llegirNotes(lector);</div></li><li class="li1"><div class="de1">          System.out.println(&quot;- Mitjana: &quot; + mitjana);</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Cal tancar el fitxer</div></li><li class="li1"><div class="de1">      lector.close();</div></li><li class="li1"><div class="de1">    } catch(Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error llegint estudiants: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Donat un Scanner en un fitxer quan l'apuntador es troba sobre l'inici</div></li><li class="li1"><div class="de1">   * de les notes, s'extreuen i es calcula la mitjana.</div></li><li class="li1"><div class="de1">   *</div></li><li class="li1"><div class="de1">   * @param lector Scanner a processar</div></li><li class="li1"><div class="de1">   * @return Mitjana de notes</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public double llegirNotes(Scanner lector) {</div></li><li class="li1"><div class="de1">    double res = 0;</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      //Es fan lectures. Cal controlar excepcions també!</div></li><li class="li1"><div class="de1">      int numNotes = lector.nextInt();</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; numNotes; i++) {</div></li><li class="li1"><div class="de1">        //S'acumula el valor de les notes</div></li><li class="li1"><div class="de1">        res = res + lector.nextDouble();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Es calcula nota mitjana</div></li><li class="li1"><div class="de1">      res = res/numNotes;</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error llegint notes: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return res;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 3</strong>. Modifiqueu l’exemple de manera que ara faci el següent. D’una banda, en lloc de mostrar les dades per pantalla, les ha d’escriure en un fitxer anomenat “NotaMitja.txt”. D’altra banda, es canvia el format del fitxer “Notes.txt”. Per controlar el nombre de notes de cada estudiant, enlloc d’indicar-ho directament al tercer valor de cada línia, ara es posa al final de cada línia el valor -1. Per exemple, ara ha de poder llegir el fitxer següent:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">Maria Almerich 4 3,5 6 -1</div></li><li class="li1"><div class="de1">Joan Sebastià 4,5 8,5 5 6,5 7 -1</div></li><li class="li1"><div class="de1">Carme Gonzàlez 6,5 8,75 10 9,5 -1</div></li><li class="li1"><div class="de1">fi</div></li></ol></pre>

</div>

<h2><a id="acces_sequeencial_a_fitxers_orientats_a_byte" >Accés seqüencial a fitxers orientats a byte</a></h2>
<div class="level2">

<p>
En el cas dels fitxers orientats a byte, les dades també s’emmagatzemen com una seqüència de valors, i per tant, l’esquema general que aplica en fitxers orientats a caràcter també es pot aplicar a aquest altre tipus. Totes les estratègies per saber quantes lectures és possible dur a terme també apliquen. La diferència fonamental és que no s’utilitza la seva representació en forma de cadena de text, sinó que s’usa el seu format binari, directament tal com s’usa dins de la memòria de l’ordinador. Segons el tipus de dades del valor emmagatzemat, aquest s’emmagatzemarà dins d’un nombre determinat de bytes. A més a més, els fitxers orientats a byte no usen cap delimitador per separar els valors. 
</p>

<p>
La <span class="tabref"><a href="#Table3"><span>taula</span></a></span> mostra un recull de la mida de les representacions en binari dels diferents tipus primitius de Java.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table3"><span>Taula: </span></a>Espai necessari per emmagatzemar els diferents tipus primitius</div>
<div class="table"><table class="inline">
	<tr class="row0">
		<th class="col0">Tipus </th><th class="col1">Paraula clau Java </th><th class="col2">Mida (bytes) </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> caràcter                </td><td class="col1 leftalign"> <code>char</code>   </td><td class="col2 rightalign">  normalment 2 </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> byte                    </td><td class="col1 leftalign"> <code>byte</code>   </td><td class="col2 rightalign">  1 </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> enter curt              </td><td class="col1 leftalign"> <code>short</code>  </td><td class="col2 rightalign">  2 </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> enter simple            </td><td class="col1 leftalign"> <code>int</code>    </td><td class="col2 rightalign">  4 </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> enter llarg             </td><td class="col1 leftalign"> <code>long</code>   </td><td class="col2 rightalign">  8 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> real de simple precisió </td><td class="col1 leftalign"> <code>float</code>  </td><td class="col2 rightalign">  4 </td>
	</tr>
	<tr class="row7">
		<td class="col0 leftalign"> real de doble precisió  </td><td class="col1"> <code>double</code> </td><td class="col2 rightalign">  8 </td>
	</tr>
</table></div>
</div>
<p>
Donat aquest fet, suposeu que voleu emmagatzemar dins un fitxer d’aquestes característiques els valors enters 2, -14 i 25. Això vol dir que dins el fitxer es desen d’acord a la seva representació binària en 4 bytes (32 bits), que seria la següent per a Java:
</p>
<div class="iocnote"><div class="ioccontent">
<p>
La representació binària dels enters en Java és el complement a dos.
</p>
</div></div><ul>
<li class="level1"><div class="li"> <strong>2</strong>: <code>00000000000000000000000000000010</code></div>
</li>
<li class="level1"><div class="li"> <strong>-14:</strong> <code>11111111111111111111111111110010</code></div>
</li>
<li class="level1"><div class="li"> <strong>25:</strong> <code>00000000000000000000000000011001</code></div>
</li>
</ul>

<p>
La <span class="figref"><a href="#Figure5"><span>figura</span></a></span> mostra un esquema de quina seria l’estructura d’un fitxer orientat a byte que conté aquests tres valors. Primer es mostra el seu equivalent en fitxer orientat a caràcter i quin seria el contingut directament en format binari (els tres conjunts de 0 i 1 tot just presentats, un rere l’altre). Tot i que, per motius d’espai a la figura, cada valor està en una fila diferent, dins un fitxer estarien escrits com una seqüència completa. No hi ha salts de línia. Finalment, a la figura es mostra en un format en què es diferencia el valor de cada byte, de manera que és més fàcil de seguir-ne el contingut, comptant que cada enter es representa amb 4 bytes. 
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Per inspeccionar un fitxer orientat a byte cal un editor hexadecimal, com l’HexEdit (Windows) o el GHex (Unix).
</p>
</div></div><div class="iocexample"><div class="ioccontent"><p class="ioctitle">La notació hexadecimal</p>
<p>
Treballar amb notació binària és una mica farragós, ja que els valors es codifiquen en seqüències de 0 i 1 que poden ser llargues (32-64 bits), de manera que ocupen força espai i resulten difícils de llegir. Normalment, per facilitar la comprensió, els valors es representen en sistema hexadecimal, de manera que queden millor resumits i són fàcils de dividir en bytes. En el sistema hexadecimal, els dígits van del 0 al 15, comptant que els valors del 10 al 15 es representen amb les lletres A a la F. Cada dígit representa 4 bits, de manera que 0 = 0000, 1 = 0001 … E = 1110, F = 1111.  D’aquesta manera, un byte es representa usant dos dígits.
</p>

<p>
Quan un valor es vol representar en hexadecimal, s’usa el prefix “0x”. Aquest no és part del valor, només és un símbol per indicar això.
</p>
</div></div><div class="iocfigure"><a name="Figure5"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Estructura d’un fitxer orientat a byte

</figcaption><img src="../media/ic10m3u6_08.png" alt="" /></figure>
</div>
<p>
Tingueu en compte que quan es diu que les dades es representen en binari, es vol dir exactament això. No es tracta que al fitxer s’escriu text amb els caràcters ‘1’ i ‘0’. Si intenteu obrir un fitxer orientat a byte amb un editor de text, no visualitzareu res. A mode d’exemple, la majoria de fitxers dels processadors de text o de fulls de càlcul són orientats a byte. Per tant, si els obriu amb un editor de text simple, el que es visualitzarà serà totalment incomprensible (i a més a més, patiu el risc de fer malbé les dades contingudes).
</p>

<p>
Si us fixeu en la figura, quan els valors es resumeixen separant els seus bytes en hexadecimal, un fitxer orientat a byte té una estructura semblant a la d’un <em>array</em>, on cada posició seria representada per cadascun dels seus bytes, i cada valor concret en realitat ocupa un cert nombre de posicions. Aquesta característica cal que la tingueu ben present, ja que serà molt rellevant més endavant.
</p>

<p>
Tot això vol dir que no és possible generar fitxers orientats a byte només amb un editor de text, ni tampoc són gens fàcils d’inspeccionar a simple vista. El principal avantatge d’un fitxer d’aquest tipus és que, a costa d’una certa complicació a l’hora de controlar el seu contingut, tots els valors d’un mateix tipus sempre ocuparan exactament el mateix espai dins del fitxer. En molts casos, això vol dir que el fitxer ocupa menys espai. Per exemple, si es volen emmagatzemar els valors de tipus enter 15 i 10371, en un fitxer orientat a caràcter el primer ocupa 2 caràcters i el segon cinc. Tenint en compte que s’han de separar d’un espai, això equival a 8 o 16 bytes, ja que, depenent de la configuració del vostre entorn de treball, cada caràcter a Java es desa en 1 o 2 bytes. En el cas d’un fitxer orientat byte, escriure tots dos sempre ocuparà 8 bytes.
</p>

</div>

<h3><a id="inicialitzacio1" >Inicialització</a></h3>
<div class="level3">

<p>
En aquest cas, per als fitxers orientats a byte es pot usar la mateixa classe tant si es volen llegir dades com si es volen escriure. 
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Per tractar de manera senzilla fitxers orientats a byte, Java ofereix la classe <code>RandomAccessFile</code>, pertanyent al <em>package</em> <code>java.io</code>. Aquesta s’usa tant per llegir com per escriure dades.
</p>
</div></div>
<p>
Novament, aquesta actua com un tipus compost. Per tant, igual que passa amb les classes <code>File</code>, <code>Scanner</code> o <code>PrintStream</code>, cal inicialitzar-la amb una variable diferent per cada fitxer sobre el qual es vol treballar (en el cas de treballar amb més d’un fitxer alhora). La manera de fer-ho és amb la instrucció següent:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">RandomAccessFile raf = new RandomAccessFile(File ruta, String mode);</div></li></ol></pre>

<p>
En aquest cas, per inicialitzar una variable d’aquest tipus correctament calen dos paràmetres. D’una banda, i igual que passava amb <code>Scanner</code>, cal especificar la ruta del fitxer amb el qual es vol treballar. Addicionalment, cal indicar mitjançat una cadena de text el mode de treball a l’hora de processar les dades del fitxer. Hi ha diversos modes de treball, però només veureu els dos més senzills, usats en la immensa majoria de casos. La utilitat dels altres modes és més marginal.
</p>

<p>
Aquests dos modes són:
</p>
<ul>
<li class="level1"><div class="li"> <strong>r</strong>: mode lectura. Indica que només es volen llegir dades des del fitxer representat per la ruta especificada. Això implica que la ruta ha de referir-se a un fitxer que hi ha al sistema de fitxers. En cas contrari, es produirà un error. També produirà un error qualsevol intent d’invocar mètodes associats a l’escriptura de dades sobre la variable <code>RandomAccessFile</code> tot just inicialitzada.</div>
</li>
<li class="level1"><div class="li"> <strong>rw</strong>: mode escriptura-lectura. Aquest mode permet tant llegir dades des d’un fitxer, igual que l’anterior, com escriure’n. Si la ruta usada es refereix a un fitxer que no existeix, se’n crearà un de nou, que estigui buit.</div>
</li>
</ul>

<p>
Per tant, si només es volen llegir dades d’un fitxer ubicat a la ruta “C:\Programes\Unitat 6\Apartat 2\Exemples\Document.txt”, caldria fer:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">File f = new File(&quot;C:\Programes\Unitat 6\Apartat 2\Exemples\Document.txt&quot;);</div></li><li class="li1"><div class="de1">RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;);</div></li></ol></pre>

<p>
Si, per contra, es volen escriure dades a un fitxer en aquesta mateixa ubicació, caldrà fer:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">File f = new File(&quot;C:\Programes\Unitat 6\Apartat 2\Exemples\Document.txt&quot;);</div></li><li class="li1"><div class="de1">RandomAccessFile raf = new RandomAccessFile(f, &quot;rw&quot;);</div></li></ol></pre>

<p>
Al contrari que amb la classe <code>PrintStream</code>, si la ruta usada en inicialitzar una variable d’aquesta classe en mode “rw” es correspon a un fitxer que ja existeix, no s’esborren les seves dades, ni queden afectades en cap mesura.
</p>

<p>
Potser us pot semblar una mica estrany o redundant el mode “r”, existint el mode “rw”, que permet fer exactament el mateix i més coses. En realitat, usar el mode “r” sempre que només es volen llegir dades és força útil, ja que garanteix que si, per un error en programar, el vostre programa intenta escriure al fitxer amb el qual treballeu, l’operació d’escriptura s’avortarà immediatament. Aquesta possibilitat és especialment interessant quan s’està treballant amb dades de fitxers, ja que no fa gens de gràcia sobreescriure (i, per tant, perdre) la informació que hi havia en un fitxer a causa d’un error involuntari al codi.
</p>

<p>
Per tant, a partir d’ara, si només es volen llegir dades d’un fitxer, sempre s’usarà el mode “r” exclusivament.
</p>

</div>

<h3><a id="escriptura_de_dades1" >Escriptura de dades</a></h3>
<div class="level3">

<p>
En aquest cas, es començarà per explicar l’escriptura de dades, en lloc de la lectura. El motiu principal és que, atès que <code>RandomAccesFile</code> treballa amb fitxers orientats a byte, no hi ha cap manera senzilla de generar fitxers de dades pel vostre compte, al contrari que per al cas dels fitxers orientats a caràcter, on n’hi ha prou a usar un editor de text. L’única manera de generar fitxers orientats a byte que puguin ser llegits correctament és mitjançant codi d’un programa.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Cada cop que es fa una operació de lectura o escriptura, l’apuntador es desplaça automàticament el mateix nombre de bytes amb què s’ha operat.
</p>
</div></div>
<p>

</p>

<p>
El nombre de bytes desplaçats dependrà de la mida associada al tipus primitiu del Java que s’ha escrit. Cal tenir sempre en compte que, com que <code>RandomAccesFile</code> treballa amb fitxers orientats a byte, aquesta classe transforma el valor del tipus primitiu a una seqüència de bytes, segons el mètode invocat. Per saber exactament en quant ha variat l’apuntador del fitxer, cal saber quants bytes ocupa cada tipus primitiu del Java. 
</p>

<p>
A la <span class="tabref"><a href="#Table4"><span>taula</span></a></span> es mostren els mètodes disponibles per escriure dades.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table4"><span>Taula: </span></a>Mètodes d’escriptura de dades de la classe <code>RandomAccessFile</code></div>
<div class="table"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Mètode                      </th><th class="col1"> Bytes escrits </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <code>writeBoolean(boolean b)</code> </td><td class="col1 leftalign"> 1             </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> <code>writeByte(byte v)</code>       </td><td class="col1 leftalign"> 1             </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> <code>writeChar(char c)</code>       </td><td class="col1 leftalign"> 2             </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> <code>writeDouble(double d)</code>   </td><td class="col1 leftalign"> 8             </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> <code>writeFloat(float f)</code>     </td><td class="col1 leftalign"> 4             </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> <code>writeInt(int i)</code>         </td><td class="col1 leftalign"> 4             </td>
	</tr>
	<tr class="row7">
		<td class="col0 leftalign"> <code>writeLong(long l)</code>       </td><td class="col1 leftalign"> 8             </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign"> <code>writeShort(short s)</code>     </td><td class="col1 leftalign"> 2             </td>
	</tr>
</table></div>
</div>
<p>
A més a més de la diferència en el format de representació de les dades del fitxer i que no cal encarregar-se d’escriure cap delimitador entre els valors, el procés general d’escriptura de dades és similar a la dels fitxers orientats a caràcter: un valor rere l’altre. La <span class="figref"><a href="#Figure6"><span>figura</span></a></span> mostra un esquema del funcionament del procés d’escriptura.
</p>
<div class="iocfigure"><a name="Figure6"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Escriptura seqüencial de valors en un fitxer orientat a byte

</figcaption><img src="../media/ic10m3u6_09.png" alt="" /></figure>
</div>
<p>
Com a exemple, estudieu i proveu el programa següent. Aquesta és la versió de l’exemple anterior que escriu una seqüència de 20 valors enters, de manera que, començant per l’1, cada valor és el doble de l’anterior. Fixeu-vos com ara no cal escriure cap delimitador. Els valors es van escrivint consecutivament, un rere l’altre.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">public class EscriureEntersDoblesBinari {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    EscriureEntersDoblesBinari programa = new EscriureEntersDoblesBinari();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(&quot;Enters.bin&quot;);</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f,&quot;rw&quot;);</div></li><li class="li1"><div class="de1">      //Ara no hi ha delimitadors. S'escriuen els valors consecutius.</div></li><li class="li1"><div class="de1">      //Es van generant els valors i escrivint</div></li><li class="li1"><div class="de1">      int valor = 1;</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; 20; i ++) {</div></li><li class="li1"><div class="de1">        raf.writeInt(valor);</div></li><li class="li1"><div class="de1">        valor = valor*2;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Fitxer escrit satisfactòriament.&quot;);</div></li><li class="li1"><div class="de1">      //La mida d'un enter són 4 bytes.</div></li><li class="li1"><div class="de1">      //La mida del fitxer hauria de ser 20*4 = 80 bytes</div></li><li class="li1"><div class="de1">      //No oblidar-se de tancar el fitxer</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error escrivint dades: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h4><a id="sobreescriptura_de_fitxers" >Sobreescriptura de fitxers</a></h4>
<div class="level4">

<p>
La classe <code>RandomAccessFile</code> té un comportament una mica especial quan escriu dades sobre un fitxer que ja existeix, en lloc de fer-ho sobre un de completament nou. Al contrari que <code>PrintStream</code>, aquest fitxer existent no s’esborra i es comença a escriure des de zero, sinó que les noves dades es van escrivint directament sobre les antigues, reemplaçant-les byte a byte. Aquest és un fet amb el qual cal tenir molta cura, ja que si el nombre de bytes escrits és inferior a la mida del fitxer existent, quedarà “brossa” al final (les dades del fitxer existent que no s’han arribat a sobreescriure). 
</p>

<p>
La <span class="figref"><a href="#Figure7"><span>figura</span></a></span> us mostra un esquema d’aquest fet, en un cas en què hi ha un fitxer amb 6 valors enters escrits i volem reemplaçar el seu contingut a només dos valors, 15 i -100.
</p>

<p>
Segons aquest comportament, cal anar molt amb compte amb el fet que les dades que no són sobreescrites es mantenen al fitxer, sobretot quan es vol reemplaçar tot el contingut d’un fitxer per dades noves. Normalment, el que se sol fer en aquests casos, és eliminar tots els bytes sobrants un cop s’ha acabat l’escriptura de dades. Per fer-ho, es disposa dels mètodes: 
</p>
<ul>
<li class="level1"><div class="li"> <code>setLength(long mida)</code>. Modifica la mida del fitxer, de manera que si el valor especificat com a paràmetre és més petit que la mida actual, s’eliminen totes les dades per sobre de la mida especificada. Si és més gran, s’omple la diferència amb bytes tot a 0.</div>
</li>
<li class="level1"><div class="li"> <code>long getFilePointer()</code>. Avalua la posició on és en aquests moments l’apuntador, mesurat en el nombre de bytes des de l’inici del fitxer. Per al cas que esteu tractant, si s’invoca quan heu acabat totes les operacions d’escriptura, us dirà la mida de les dades escrites, i per tant, la nova mida que ha de tenir el fitxer.</div>
</li>
</ul>
<div class="iocfigure"><a name="Figure7"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Sobreescriptura de fitxers en usar RandomAccessFile

</figcaption><img src="../media/ic10m3u6_10.png" alt="" /></figure>
</div>
<p>
El programa següent usa aquest mecanisme per reemplaçar completament el fitxer resultant de l’exemple anterior (20 valors enters, cadascun el doble de l’anterior), anomenat “enters.bin”, per cinc valors enters -1. El resultat final és un fitxer de només 20 bytes, en lloc de 80. Proveu també què succeeix si abans d’executar-lo sobre aquest fitxer de 80 bytes s’elimina la sentència <code>raf.setLength(apuntador)</code>.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">public class SobreescriureEntersBinari {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    SobreescriureEntersBinari programa = new SobreescriureEntersBinari();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(&quot;Enters.bin&quot;);</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;rw&quot;);</div></li><li class="li1"><div class="de1">      //L'apuntador està al primer byte</div></li><li class="li1"><div class="de1">      long apuntador = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Inici: Apuntador a posició &quot; + apuntador);</div></li><li class="li1"><div class="de1">      //Sobreescrivim els primers cinc valors</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; 5; i++) {</div></li><li class="li1"><div class="de1">        raf.writeInt(-1);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Si el fitxer ja tenia més de cinc enters, al final hi ha brossa</div></li><li class="li1"><div class="de1">      apuntador = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Fi: Apuntador a posició &quot; + apuntador);</div></li><li class="li1"><div class="de1">      //Es fixa la mida del fitxer als valors escrits</div></li><li class="li1"><div class="de1">      raf.setLength(apuntador);</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Fitxer modificat correctament.&quot;);</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error escrivint dades: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h3><a id="lectura_de_dades1" >Lectura de dades</a></h3>
<div class="level3">

<p>
Un cop conegut el procés de lectura de dades de manera seqüencial i el format com s’escriuen les dades en un fitxer orientat a byte, no hi ha gaires sorpreses en el procés de lectura. Novament, es parteix d’un apuntador a la posició inicial que va avançant a mesura que s’invoquen mètodes per fer operacions de lectura. Exactament igual com passava amb la classe <code>Scanner</code>, hi ha un mètode específic per a cada tipus de dades esperat dins la seqüència de valors, enumerats a la <span class="tabref"><a href="#Table5"><span>taula</span></a></span>.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table5"><span>Taula: </span></a>Mètodes de lectura de dades de la classe <code>RandomAccessFile</code></div>
<div class="table"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Mètode            </th><th class="col1"> Tipus de dada llegida </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> <code>readByte()</code>    </td><td class="col1 leftalign"> <code>byte</code>              </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> <code>readShort()</code>   </td><td class="col1 leftalign"> <code>short</code>             </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> <code>readInt()</code>     </td><td class="col1 leftalign"> <code>int</code>               </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> <code>readLong()</code>    </td><td class="col1 leftalign"> <code>long</code>              </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> <code>readFloat()</code>   </td><td class="col1 leftalign"> <code>float</code>             </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> <code>readDouble()</code>  </td><td class="col1 leftalign"> <code>double</code>            </td>
	</tr>
	<tr class="row7">
		<td class="col0"> <code>readBoolean()</code> </td><td class="col1 leftalign"> <code>boolean</code>           </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign"> <code>readChar()</code>    </td><td class="col1 leftalign"> <code>char</code>              </td>
	</tr>
</table></div>
</div>
<p>
La <span class="figref"><a href="#Figure8"><span>figura</span></a></span> mostra un exemple del funcionament del procés de lectura en un fitxer orientat a byte. 
</p>
<div class="iocfigure"><a name="Figure8"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Lectura seqüencial de valors en un fitxer orientat a byte

</figcaption><img src="../media/ic10m3u6_11.png" alt="" /></figure>
</div>
<p>
En el cas dels fitxers binaris també cal controlar no llegir més valors dels que realment hi ha escrits al fitxer, o en cas contrari es produirà una excepció. Ara bé, en aquest tipus de fitxer teniu un avantatge, i és que no sempre cal una marca de finalització o indicar el nombre d’elements prèviament. Atès que cada valor del mateix tipus sempre ocupa el mateix espai (els <code>int</code> 4 bytes, els <code>double</code> 8 bytes, etc.), si coneixeu la mida del fitxer en bytes, es pot calcular quants valors d’un tipus conté fent una simple divisió: mida fitxer/mida tipus.
</p>

<p>
El codi d’exemple següent llegeix un fitxer orientat a byte anomenat “Enters.bin”, el qual conté cert nombre de valors enters, i els va mostrant per pantalla. Podeu usar el resultat dels exemples d’escriptura de dades. Fixeu-vos especialment en la manera com es calcula el nombre de valors que cal llegir, donada la mida del fitxer i coneguda la mida de la representació en binari d’un enter a Java (4 bytes).
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">public class LlegirEntersBinari {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    LlegirEntersBinari programa = new LlegirEntersBinari();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(&quot;Enters.bin&quot;);</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;);</div></li><li class="li1"><div class="de1">      //Càlcul del nombre d'enters</div></li><li class="li1"><div class="de1">      long numEnters = f.length() / 4;</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Hi ha &quot; + numEnters + &quot; enters.&quot;);</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; numEnters; i++) {</div></li><li class="li1"><div class="de1">        int valor = raf.readInt();</div></li><li class="li1"><div class="de1">        System.out.println(&quot;S'ha llegit el valor &quot; + valor);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error en la lectura: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 4</strong>. Feu un programa que llegeixi un fitxer orientat a byte que contingui una seqüència de valors reals qualsevol. Cal mostrar-los per pantalla ordenats de més gran a més petit. Tingueu en compte que, per poder provar-lo, abans haureu de generar aquest fitxer vosaltres mateixos d’alguna manera.
</p>

</div>

<h4><a id="lectura_incorrecta_de_dades" >Lectura incorrecta de dades</a></h4>
<div class="level4">

<p>
A l’hora de llegir dades en un fitxer orientat a byte, cal procurar sempre usar el mètode encertat a cada moment, d’acord al tipus que s’espera llegir. Ara bé, la classe <code>RandomAccessFile</code> actua d’una manera força diferent a <code>Scanner</code>, ja que quan realitza una lectura incorrecta no es produeix cap excepció. Aquesta classe, quan executa qualsevol dels seus mètode de lectura, sempre llegeix el nombre de bytes associats al tipus de dada que es vol llegir, i els interpreta al valor que correspon dins aquest tipus. Això ho fa independentment del fet que, en realitat, això sigui correcte o no.
</p>
<div class="ioctext"><div class="ioccontent"><p class="ioctitle">Lectura incorrecta de dades</p>
<p>
És semblant al que passa si, amb un processador de text, per exemple, intenteu obrir un fitxer que no li pertoca, fet amb un altre programa.
</p>
</div></div>
<p>
La <span class="figref"><a href="#Figure9"><span>figura</span></a></span> mostra un exemple d’aquest comportament, llegint un valor de tipus real sobre un fitxer on hi ha emmagatzemats valors enters.
</p>
<div class="iocfigure"><a name="Figure9"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Lectura incorrecta de dades en un fitxer orientat a byte

</figcaption><img src="../media/ic10m3u6_12.png" alt="" /></figure>
</div>
<p>
Per veure-ho més clar, tot seguit hi ha una versió de l’exemple anterior que llegeix i presenta valors reals. En aquest cas, executar-lo sobre un fitxer on només hi ha escrits valors enters seria incorrecte, ja que no s’està usant el mètode adient per llegir els valors continguts. Ara bé, el mètode <code>readDouble()</code> simplement llegeix 8 bytes consecutius (o sigui, en aquest cas, la representació dins el fitxer de dos enters seguits, 4 + 4 bytes), i intenta interpretar aquests 8 bytes com si fossin un valor de tipus real. Evidentment, el valor resultant de fer aquest procés serà totalment incorrecte, ja que dins del fitxer no hi ha cap valor de tipus real. Executeu-lo per veure’n el resultat.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">public class LlegirDoubleBinari {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    LlegirDoubleBinari programa = new LlegirDoubleBinari();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(&quot;Enters.bin&quot;);</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;rw&quot;);</div></li><li class="li1"><div class="de1">      //Càlcul del nombre d'enters</div></li><li class="li1"><div class="de1">      long numEnters = f.length() / 8;</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Crec que hi ha &quot; + numEnters + &quot; reals.&quot;);</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; numEnters; i++) {</div></li><li class="li1"><div class="de1">        double valor = raf.readDouble();</div></li><li class="li1"><div class="de1">        System.out.println(&quot;S'ha llegit el valor real &quot; + valor);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error en la lectura: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Per tant, cal ser molt acurat a l’hora de fer lectures sobre fitxers orientats a byte, i tenir ben clar el seu format i quin tipus de dades cal llegir a cada moment, ja que el programa no ens avisarà amb cap excepció. Simplement, aquest comportarà de manera ben estranya en executar-lo.
</p>

</div>

<h2><a id="acces_relatiu_a_les_dades" >Accés relatiu a les dades</a></h2>
<div class="level2">

<p>
L’accés seqüencial a les dades d’un fitxer permet processar el seu contingut de manera relativament senzilla, en basar-se en un mecanisme pràcticament idèntic a la lectura de dades des del teclat, o la seva escriptura a la pantalla. Els blocs d’instruccions per dur a terme operacions de lectura i escriptura són bàsicament els mateixos, només varia l’origen i la destinació de les dades en les operacions d’entrada / sortida, així com els aspectes vinculats a si el fitxer és orientat a caràcter o a byte. 
</p>

<p>
Ara bé, en realitat, un fitxer no és ben bé com el teclat o la pantalla, ja que les dades ni deixen d’estar disponibles un cop llegides, ni té sentit que resulti impossible sobreescriure-les parcialment. L’accés seqüencial és una manera còmoda de tractar fitxers, però a canvi de perdre un cert grau de versatilitat. 
</p>

<p>
Si considereu que un fitxer orientat a byte, i només aquest tipus, és com un <em>array</em> de certa envergadura on cada byte representa una posició, ha de ser possible accedir a les dades que conté de la mateixa manera que es fa amb els <em>arrays</em>. D’una banda, de manera seqüencial, fent recorreguts sobre cadascuna de les seves posicions, com heu vist fins ara. Però també ha de ser possible accedir directament a una posició concreta només indicant una ubicació per al seu apuntador de lectura o escriptura. O sigui, donat un fitxer orientat a byte, es pot dir que disposeu d’<em>accés relatiu</em>. 
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
S’anomena <code>accés relatiu</code> a la capacitat d’accedir a qualsevol element dins una seqüència de dades sense haver de tractar prèviament els elements anteriors.
</p>
</div></div>
<p>
Una bona manera d’entendre aquesta definició és contrastant l’accés relatiu al seqüencial, en ser precisament termes contraposats. Donat un fitxer amb una seqüència de 10 elements, per poder tractar només el desè, si s’hi accedeix seqüencialment, primer cal llegir (i anar descartant successivament) els nou elements anteriors. L’accés relatiu, en canvi, proporciona operacions que fan possible llegir aquest desè element directament, sense haver de processar abans tots els anteriors usant mètodes de lectura.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
L’accés relatiu a un fitxer sovint també s’anomena <em>accés aleatori</em> o <em>accés directe</em>. Dins d’aquest context, són termes sinònims.
</p>
</div></div><div class="iocimportant"><div class="ioccontent">
<p>
La classe <strong>RandomAccessFile</strong> permet l’accés relatiu als fitxers orientats a byte.
</p>
</div></div>
<p>
Al cap i a la fi, el seu nom, en anglès, vol dir “fitxer d’accés aleatori”.
</p>

</div>

<h3><a id="posicionament" >Posicionament</a></h3>
<div class="level3">

<p>
El primer pas per poder dur a terme accés relatiu a un fitxer és especificar l’índex de la posició que es vol accedir, ja sigui tant per llegir la dada que hi ha emmagatzemada com per escriure-hi un valor nou. Un cop conegut aquest índex, mitjançant la sintaxi adient, és possible aquella posició. En el cas dels <em>arrays</em>, aquesta sintaxi és del tipus: 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">array[índex]</div></li></ol></pre>

<p>
Atès que <code>RandomAccessFile</code> és una classe, la sintaxi per accedir a les posicions del fitxer és mitjançant la invocació de mètodes. Cada byte individual dins del fitxer és com una posició d’un <em>array</em>, i el primer byte del fitxer es consideraria la seva posició 0.
</p>

<p>
Per dur a terme la tasca d’indicar l’índex per fer una operació de lectura o escriptura, les variables de tipus <code>RandomAccessFile</code> tenen una diferència important en l’accés a les dades respecte a un <em>array</em>. Si ho recordeu, els seus mètodes de lectura i escriptura no disposen de cap paràmetre on s’especifiqui un índex. Això es deu al fet que les classes que tracten les dades d’un fitxer disposen d’un apuntador intern que indica en tot moment quina és la dada següent a processar. Cada cop que es fa una operació, aquest apuntador es va desplaçant automàticament fins a arribar al final de la seqüència de valors. El que <code>RandomAccessFile</code> proporciona són un seguit de mètodes que permeten modificar el valor d’aquest apuntador, indicant de manera explícita la seva posició. Per tant, per accedir a una posició qualsevol del fitxer, primer cal un pas previ on s’indica la posició en què es vol operar, invocant algun d’aquests mètodes de posicionament de l’apuntador i, posteriorment, es pot dur a terme la lectura o l’escriptura.
</p>

<p>
Per gestionar el posicionament de l’apuntador, la classe defineix els mètodes següents:
</p>

<p>
<strong>1.</strong> <code>void seek(long pos)</code>. Ubica l’apuntador exactament a la posició especificada pel paràmetre <code>pos</code>, mesurat en bytes, de manera que qualsevol accés a les dades serà tot just sobre el byte següent. No hi ha cap restricció en el valor d’aquest paràmetre, essent possible ubicar l’apuntador molt mes enllà del final real del fitxer. Això pot semblar una mica estrany, però aviat veureu el motiu.
</p>

<p>
La <span class="figref"><a href="#Figure10"><span>figura</span></a></span> mostra un esquema del funcionament d’aquest mètode donat un fitxer orientat a bytes que conté un conjunt d’enters. Recordeu que cada enter ocupa 4 bytes.
</p>

<p>
El codi d’exemple següent usa el mètode <strong>seek</strong> per moure l’apuntador del fitxer a diferents posicions de manera arbitrària, tal com es podria fer amb l’índex d’un <em>array</em>.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">public class MoureApuntadorSeek {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    MoureApuntadorSeek programa = new MoureApuntadorSeek();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(&quot;Enters.bin&quot;);</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;);</div></li><li class="li1"><div class="de1">      raf.seek(20);</div></li><li class="li1"><div class="de1">      long pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      System.out.println(&quot;L'apuntador està a la posició &quot; + pos);</div></li><li class="li1"><div class="de1">      raf.seek(0);</div></li><li class="li1"><div class="de1">      pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      System.out.println(&quot;L'apuntador està a la posició &quot; + pos);</div></li><li class="li1"><div class="de1">      raf.seek(100);</div></li><li class="li1"><div class="de1">      pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      System.out.println(&quot;L'apuntador està a la posició &quot; + pos);</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>
<div class="iocfigure"><a name="Figure10"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Accés aleatori mitjançant posicionament d’apuntador usant el mètode <strong>seek</strong>

</figcaption><img src="../media/ic10m3u6_13.png" alt="" /></figure>
</div>
<p>
<strong>2.</strong> <code>int skipBytes(int n)</code>. Avança la posició de l’apuntador en <code>n</code> bytes, de manera que aquest passa a valer <code>valor actual + n</code>. La seva invocació avalua el nombre de bytes que realment s’ha avançat. Cal tenir en compte que es pot donar el cas quan el valor resultant no sigui igual a <code>n</code>. Per exemple, si l’apuntador arriba al final del fitxer, el desplaçament de l’apuntador s’atura. Per tant, Independentment del valor del paràmetre <code>n</code>, sempre heu de controlar la posició de l’apuntador del fitxer a partir del valor retornat. 
</p>

<p>
La <span class="figref"><a href="#Figure11"><span>figura</span></a></span> mostra un exemple de com es modifica l’apuntador a partir d’un seguit de crides al mètode <strong>skipBytes</strong>. Fixeu-vos que si a l’hora d’executar-la l’apuntador sobrepassa la mida del fitxer, aquest incrementa la seva mida amb nous bytes, tots a 0.
</p>
<div class="iocfigure"><a name="Figure11"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Accés aleatori mitjançant posicionament d’apuntador usant el mètode <strong>skipBytes</strong>

</figcaption><img src="../media/ic10m3u6_14.png" alt="" /></figure>
</div>
<p>
El codi d’exemple següent usa el mètode <strong>skipBytes</strong> per moure l’apuntador a diferents posicions dins del fitxer. Fixeu-vos com, en el darrer posicionament, s’intenta anar molt més enllà de la mida del fitxer. Si se sobrepassa aquest límit, l’apuntador mai avança més enllà de la mida del fitxer.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">public class MoureApuntadorSkipBytes {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    MoureApuntadorSkipBytes programa = new MoureApuntadorSkipBytes();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(&quot;Enters.bin&quot;);</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;);</div></li><li class="li1"><div class="de1">      long skip = raf.skipBytes(20);</div></li><li class="li1"><div class="de1">      long pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      System.out.print(&quot;L'apuntador ha avançat &quot; + skip + &quot; posicions. &quot;);</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Està a la posició &quot; + pos);</div></li><li class="li1"><div class="de1">      skip = raf.skipBytes(8);</div></li><li class="li1"><div class="de1">      pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      System.out.print(&quot;L'apuntador ha avançat &quot; + skip + &quot; posicions. &quot;);</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Està a la posició &quot; + pos);</div></li><li class="li1"><div class="de1">      //S'intenta avançar molt més enllà de la mida del fitxer</div></li><li class="li1"><div class="de1">      skip = raf.skipBytes(400);</div></li><li class="li1"><div class="de1">      pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      System.out.print(&quot;L'apuntador ha avançat &quot; + skip + &quot; posicions. &quot;);</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Està a la posició &quot; + pos);</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h3><a id="lectura_de_dades_relativa" >Lectura de dades relativa</a></h3>
<div class="level3">

<p>
Mitjançant els mètodes <code>seek</code> i <code>skipBytes</code> és possible indicar des de quina posició del fitxer, mesurada en bytes, es vol dur a terme la lectura, la qual es duu a terme amb les mateixes instruccions que el tractament seqüencial (els mètodes <code>readInt()</code>, <code>readDouble</code>,etc.), i de fet, mentre no es torni a invocar cap dels dos mètodes de posicionament de l’apuntador, el tractament del fitxer passa a ser totalment seqüencial. Cada cop que es llegeix un valor, l’apuntador avança tants bytes com la mida del tipus del valor (4 bytes si és un enter, 8 si és un <code>double</code>, etc.).
</p>

<p>

</p>

<p>
El programa d’exemple següent fa ús dels mètodes <code>seek</code> i <code>skipBytes</code> per llegir les dades d’un fitxer que només conté valors enters. S’ignora la primera meitat dels valors i es van mostrant els valors de la segona meitat de manera intermitent. O sigui, si hi ha 20 valors, se salten els 10 primers valors i es mostren per pantalla els valors 11, 13, 15, etc. Al llarg de la seva execució, mitjançant el mètode <code>getFilePointer</code>, es va controlant l’evolució de l’apuntador de lectura abans d’accedir a cada valor.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">public class LlegirEntersRelatiu {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    LlegirEntersRelatiu programa = new LlegirEntersRelatiu();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(&quot;Enters.bin&quot;);</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;);</div></li><li class="li1"><div class="de1">      long numEnters = f.length()/4;</div></li><li class="li1"><div class="de1">      long meitat = numEnters/2;</div></li><li class="li1"><div class="de1">      //Apuntador a l'inici de l'enter a la meitat del fitxer</div></li><li class="li1"><div class="de1">      raf.seek(meitat*4);</div></li><li class="li1"><div class="de1">      long pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      //Es llegeix fins a arribar al final del fitxer</div></li><li class="li1"><div class="de1">      do {</div></li><li class="li1"><div class="de1">        System.out.print(&quot;(apuntador a la posició &quot; + pos + &quot;) -&gt;&quot;);</div></li><li class="li1"><div class="de1">        //Es llegeix un enter</div></li><li class="li1"><div class="de1">        int valor = raf.readInt();</div></li><li class="li1"><div class="de1">        System.out.println(&quot; S'ha llegit el valor &quot; + valor);</div></li><li class="li1"><div class="de1">        //Se salta l'enter següent (4 bytes)</div></li><li class="li1"><div class="de1">        raf.skipBytes(4);</div></li><li class="li1"><div class="de1">        pos =  raf.getFilePointer();</div></li><li class="li1"><div class="de1">      } while (pos &lt; f.length());</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error llegint dades: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Com succeïa en el tractament seqüencial, a l’hora de fer lectures mitjançant accés relatiu cal anar amb compte i usar sempre el mètode que correspon al tipus del valor al qual es vol accedir, així com procurar no accedir a posicions més enllà de la mida real del fitxer. 
</p>

<p>
Per al cas de l’accés relatiu, a més a més, també cal ser molt acurat per indicar quina ha de ser la posició de l’apuntador. Aquest sempre ha d’estar a la primera posició del grup de bytes que conformen cada valor. En cas contrari, el programa es comportarà de manera erràtica, ja que es llegiran bytes de diferents valors barrejats. Per exemple, si un fitxer només conté valors enters, les úniques posicions vàlides per fer lectures són la 0, 4, 8, 12, etc.
</p>

</div>

<h3><a id="escriptura_de_dades_relativa" >Escriptura de dades relativa</a></h3>
<div class="level3">

<p>
La classe <code>RandomAccessFile</code> té la particularitat que, sempre que fa una escriptura sobre un fitxer que ja existeix, només modifica el valor on s’ubica l’apuntador i cap altre. Per tant, amb l’ajut del mètode de posicionament és possible modificar els valors dins d’un fitxer orientat a byte directament, tal com si fossin els valors dins un <em>array</em>. De fet, normalment, l’escriptura de dades relativa només té sentit quan es treballa sobre un fitxer ja existent. 
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Cal calcular molt bé quina és la posició en número de bytes on ha d’anar l’apuntador.
</p>
</div></div><div class="iocimportant"><div class="ioccontent">
<p>
L’accés relatiu a un fitxer evita haver de carregar totes les dades a memòria, per exemple a un <em>array</em>, i després tornar-les a escriure si es volen fer modificacions a valors individuals. Aquestes esmenes es poden fer directament sobre les posicions del fitxer.
</p>
</div></div>
<p>
Un cop l’apuntador es troba a la posició que es vol modificar, el procés d’escriptura mitjançant accés relatiu és similar al de lectura, simplement canviant la invocació de mètodes de lectura pels d’escriptura (<code>writeInt(…)</code>, <code>writeDouble(…)</code>, etc.).
</p>

<p>
El programa següent mostra un exemple d’escriptura mitjançant accés relatiu, usant els mètodes de posicionament de l’apuntador. En aquest cas, el programa accedeix a un fitxer orientat a byte que conté un conjunt de valors enters i modifica els valors que ocupen una posició múltiple de cinc amb la seva pròpia posició. O sigui, reemplaça el cinquè valor per un 5, el desè element per un 10, el quinzè element per un 15, etc. fins a arribar al final del fitxer. En acabar l’escriptura, es mostren els nous valors del fitxer per pantalla.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">public class EscriureEntersRelatiu {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    EscriureEntersRelatiu programa = new EscriureEntersRelatiu();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File f = new File(&quot;Enters.bin&quot;);</div></li><li class="li1"><div class="de1">      //Es mostra el contingut original (si existeix)</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Valors inicials del fitxer.&quot;);</div></li><li class="li1"><div class="de1">      mostrarFitxerBinari(f);</div></li><li class="li1"><div class="de1">      //Es fan les modificacions</div></li><li class="li1"><div class="de1">      modificaFitxerBinari(f);</div></li><li class="li1"><div class="de1">      //I ara es mostra el nou contingut</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Nous valors del fitxer.&quot;);</div></li><li class="li1"><div class="de1">      mostrarFitxerBinari(f);</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error escrivint dades: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Mostra per pantalla tots els valors d'un fitxer orientat a byte que</div></li><li class="li1"><div class="de1">   * conté enters.</div></li><li class="li1"><div class="de1">   * </div></li><li class="li1"><div class="de1">   * @param f Ruta del fitxer a mostrar</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public void mostrarFitxerBinari(File f) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;);</div></li><li class="li1"><div class="de1">      long pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      while (pos &lt; f.length()) {</div></li><li class="li1"><div class="de1">        int valor = raf.readInt();</div></li><li class="li1"><div class="de1">        System.out.print(&quot; &quot; + valor);</div></li><li class="li1"><div class="de1">        pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">      System.out.println();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error llegint dades: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Modifica el contingut d'un fitxer orientat a byte que conté enters, de</div></li><li class="li1"><div class="de1">   * manera que cada 5 posicions se sobreescriu el valor pel número de </div></li><li class="li1"><div class="de1">   * la pròpia posició.</div></li><li class="li1"><div class="de1">   * </div></li><li class="li1"><div class="de1">   * @param f Ruta del fitxer a modificar</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public void modificaFitxerBinari(File f) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;rw&quot;);</div></li><li class="li1"><div class="de1">      //S'avança fins a l'inici del cinquè enter</div></li><li class="li1"><div class="de1">      //valor 1 = posició 0, valor 2 = posició 4, valor 3 = posició 8</div></li><li class="li1"><div class="de1">      //valor 4 = posició 12, valor 5 = posició 16</div></li><li class="li1"><div class="de1">      raf.seek(16);</div></li><li class="li1"><div class="de1">      long pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      int i = 1;</div></li><li class="li1"><div class="de1">      while (pos &lt; f.length()) {</div></li><li class="li1"><div class="de1">        //S'escriu un valor a l'apuntador actual</div></li><li class="li1"><div class="de1">        raf.writeInt(i*5);</div></li><li class="li1"><div class="de1">        i++;</div></li><li class="li1"><div class="de1">        //Se salten 4 valors enters. Aquests no es toquen</div></li><li class="li1"><div class="de1">        raf.skipBytes(4*4);</div></li><li class="li1"><div class="de1">        //En total, l'apuntador ha avançat 5 valors (escrit + saltats)</div></li><li class="li1"><div class="de1">        pos = raf.getFilePointer();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Escriptura finalitzada</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error escrivint dades: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Com passava amb la lectura, cal tenir molta cura a l’hora de posicionar l’apuntador, de manera que aquest estigui sempre en el primer byte del valor que es vol sobreescriure. En aquest cas, però, fer bé els càlculs és especialment crític, ja que en cas contrari fareu malbé dades dins del fitxer.
</p>

<p>
La <span class="figref"><a href="#Figure12"><span>figura</span></a></span> mostra un exemple d’escriptura sobre una posició invàlida en fer un accés relatiu incorrecte sobre un fitxer orientat a byte amb 6 valors enters. Fixeu-vos que l’apuntador se situa just a la meitat del tercer valor, de manera que, al escriure els 4 bytes d’un nou valor enter, se sobreescriu la segona meitat del tercer valor (2 bytes) i la primera meitat del quart (2 bytes més). El resultat és que es canvia part dels bytes corresponents a aquests valors, de manera que ara passen a representar valors completament diferents. Ja a simple vista, aquests nous valors només deixen entreveure que alguna cosa s’ha fet malament.
</p>
<div class="iocfigure"><a name="Figure12"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Escriptura incorrecta en un accés relatiu.

</figcaption><img src="../media/ic10m3u6_15.png" alt="" /></figure>
</div>
</div>

<h4><a id="seek_mes_enlla_de_la_mida_del_fitxer" >Seek més enllà de la mida del fitxer</a></h4>
<div class="level4">

<p>
En el procés d’escriptura mitjançant accés relatiu també hi ha un cas especial. Es tracta de quan s’ha cridat el mètode <code>seek</code> de manera que l’apuntador s’ubica més enllà del final del fitxer (per exemple, el fitxer té 80 bytes i s’ubica a la posició 100), i llavors es duu a terme una escriptura. En aquest cas, la mida del fitxer s’incrementa automàticament fins a la posició de l’apuntador, omplint tots els nous bytes amb 0.  Un cop fet, llavors es materialitza l’escriptura. 
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Mitjançant el sistema d’accés relatiu, també és possible escriure dades directament des del final d’un fitxer existent, de manera que s’annexin.
</p>
</div></div>
<p>
Per exemple, si donat un fitxer de 80 bytes s’usa el mètode <strong>seek</strong> per ubicar l’apuntador fins a la posició 100 i llavors es fa l’escriptura d’un enter, el fitxer creixerà fins als 100 bytes, i els seus darrers 20 bytes estaran tots a 0. Llavors es durà a terme l’escriptura, de manera que la mida del fitxer final queda en 104 bytes. El programa següent mostra aquest cas.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">public class SeekCreixFitxerBinari {</div></li><li class="li1"><div class="de1">  public static final String NOM_FITXER = &quot;Seek.bin&quot;;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    SeekCreixFitxerBinari programa = new SeekCreixFitxerBinari();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    File f = new File(NOM_FITXER);</div></li><li class="li1"><div class="de1">    crearFitxer(f);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La mida inicial és &quot; + f.length());</div></li><li class="li1"><div class="de1">    executaSeek(f);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La mida a l'hora de fer seek i escriure és &quot; + f.length());</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Crea un fitxer qualsevol de 80 bytes.</div></li><li class="li1"><div class="de1">   *</div></li><li class="li1"><div class="de1">   * @param f Ruta del fitxer a crear</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public void crearFitxer(File f) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;rw&quot;);</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; 20; i++) {</div></li><li class="li1"><div class="de1">        raf.writeInt(i);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      raf.setLength(20*4);</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error escrivint dades: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Crea un fitxer qualsevol de 80 bytes.</div></li><li class="li1"><div class="de1">   *</div></li><li class="li1"><div class="de1">   * @param f Ruta del fitxer a crear</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public void executaSeek(File f) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;rw&quot;);</div></li><li class="li1"><div class="de1">      //Es va 20 bytes més enllà de la mida del fitxer</div></li><li class="li1"><div class="de1">      raf.seek(f.length() + 20);</div></li><li class="li1"><div class="de1">      //S'escriu un valor qualsevol</div></li><li class="li1"><div class="de1">      raf.writeInt(100);</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error escrivint dades: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Mitjançant aquest sistema, també és possible escriure dades directament des del final d’un fitxer existent, de manera que s’annexin.
</p>

<p>
<strong>Repte 5</strong>. Feu un programa que, donat un fitxer orientat a byte que conté qualsevol nombre de valors reals, els ordeni de menor a major. Aquesta tasca l’ha de dur directament sobre el fitxer, i no pas carregant les dades a un <em>array</em>, ordenant i després escrivint-les de nou al fitxer. Per veure que funciona, fer que mostri per pantalla els valors continguts abans i després de l’ordenació.
</p>

</div>

<h2><a id="solucions_als_reptes_proposats" >Solucions als reptes proposats</a></h2>
<div class="level2">

<p>
<strong>Repte 1</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class LlegirEnters {</div></li><li class="li1"><div class="de1">  public static final int NUM_VALORS = 15;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    LlegirEnters programa = new LlegirEnters();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">      Scanner lector = null;</div></li><li class="li1"><div class="de1">      try {</div></li><li class="li1"><div class="de1">        //S'intenta obrir el fitxer</div></li><li class="li1"><div class="de1">        File f = new File(&quot;Reals.txt&quot;);</div></li><li class="li1"><div class="de1">        lector = new Scanner(f);</div></li><li class="li1"><div class="de1">        //De moment, el màxim és el primer valor</div></li><li class="li1"><div class="de1">        double maxim = lector.nextDouble();</div></li><li class="li1"><div class="de1">        //Recorrem la resta de valors</div></li><li class="li1"><div class="de1">        for (int i = 1; i &lt; NUM_VALORS; i ++) {</div></li><li class="li1"><div class="de1">          double valor = lector.nextDouble();</div></li><li class="li1"><div class="de1">          //El nou valor és més gran?</div></li><li class="li1"><div class="de1">          if (maxim &lt; valor) {</div></li><li class="li1"><div class="de1">            maxim = valor;</div></li><li class="li1"><div class="de1">          }</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">        System.out.println(&quot;El valor més gran és: &quot; + maxim);</div></li><li class="li1"><div class="de1">      } catch (Exception e) {</div></li><li class="li1"><div class="de1">        //Excepció!</div></li><li class="li1"><div class="de1">        System.out.println(&quot;Error: &quot; + e);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Amb error o sense, cal tancar el fitxer</div></li><li class="li1"><div class="de1">      lector.close();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>

</p>

<p>
<strong>Repte 2</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.exemples;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.PrintStream;</div></li><li class="li1"><div class="de1">public class EscriureEntersDobles {</div></li><li class="li1"><div class="de1">  public static final int NUM_VALORS = 20;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    EscriureEntersDobles programa = new EscriureEntersDobles();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">      PrintStream escriptor = null;</div></li><li class="li1"><div class="de1">      try {</div></li><li class="li1"><div class="de1">        //S'intenta obrir el fitxer</div></li><li class="li1"><div class="de1">        File f = new File(&quot;Enters.txt&quot;);</div></li><li class="li1"><div class="de1">        escriptor = new PrintStream(f);</div></li><li class="li1"><div class="de1">        //S'escriu el primer valor, que no necessita un espai abans</div></li><li class="li1"><div class="de1">        int valor = 1;</div></li><li class="li1"><div class="de1">        escriptor.print(valor);</div></li><li class="li1"><div class="de1">        //Es van generant la resta de valors i escrivint</div></li><li class="li1"><div class="de1">        for (int i = 1; i &lt; 20; i ++) {</div></li><li class="li1"><div class="de1">          if (i%5 == 0) {</div></li><li class="li1"><div class="de1">            //Cada 5 elements, s'escriu com a delimitador un salt de línia</div></li><li class="li1"><div class="de1">            escriptor.print(&quot;\n&quot;);</div></li><li class="li1"><div class="de1">          }  else {</div></li><li class="li1"><div class="de1">            //Si no, s'escriu com a delimitador un espai en blanc</div></li><li class="li1"><div class="de1">            escriptor.print(&quot; &quot;);</div></li><li class="li1"><div class="de1">          }</div></li><li class="li1"><div class="de1">          //Es calcula i escriu el nou valor</div></li><li class="li1"><div class="de1">          valor = valor*2;</div></li><li class="li1"><div class="de1">          escriptor.print(valor);</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">        System.out.println(&quot;Fitxer escrit satisfactòriament.&quot;);</div></li><li class="li1"><div class="de1">      } catch (Exception e) {</div></li><li class="li1"><div class="de1">        //Excepció!</div></li><li class="li1"><div class="de1">        System.out.println(&quot;Error: &quot; + e);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Amb error o sense, cal tancar el fitxer</div></li><li class="li1"><div class="de1">      escriptor.close();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>

</p>

<p>
<strong>Repte 3</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.reptes;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">import java.io.PrintStream;</div></li><li class="li1"><div class="de1">public class GenerarFitxerNotes {</div></li><li class="li1"><div class="de1">  //la paraula fi serveix com a marca de final de fitxer</div></li><li class="li1"><div class="de1">  public static final String MARCA_FI = &quot;fi&quot;;</div></li><li class="li1"><div class="de1">  public static final double MARCA_FI_NOTES = -1;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    GenerarFitxerNotes programa = new GenerarFitxerNotes();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      File in = new File(&quot;NotesMarca.txt&quot;);</div></li><li class="li1"><div class="de1">      Scanner lector = new Scanner(in);</div></li><li class="li1"><div class="de1">      File out = new File (&quot;NotaMitja.txt&quot;);    //Es genera el fitxer de sortida</div></li><li class="li1"><div class="de1">      PrintStream escriptor = new PrintStream(out);</div></li><li class="li1"><div class="de1">      boolean llegir = true;</div></li><li class="li1"><div class="de1">      //Només cal canviar les escriptures a pantalla per al fitxer de sortida</div></li><li class="li1"><div class="de1">      //O sigui, on posa &quot;System.out&quot; posar &quot;escriptor&quot;</div></li><li class="li1"><div class="de1">      while (llegir) {</div></li><li class="li1"><div class="de1">        String nom = lector.next();</div></li><li class="li1"><div class="de1">        if (MARCA_FI.equals(nom)) {</div></li><li class="li1"><div class="de1">          llegir = false;</div></li><li class="li1"><div class="de1">        } else {</div></li><li class="li1"><div class="de1">          String cognom = lector.next();</div></li><li class="li1"><div class="de1">          escriptor.print(&quot;Estudiant: &quot; + nom + &quot; &quot; + cognom);</div></li><li class="li1"><div class="de1">          //Noteu com un Scanner es pot passar com a paràmetre</div></li><li class="li1"><div class="de1">          double mitjana = llegirNotes(lector);</div></li><li class="li1"><div class="de1">          escriptor.println(&quot; - Mitjana: &quot; + mitjana);</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      lector.close();               //Cal tancar els fitxers</div></li><li class="li1"><div class="de1">      escriptor.close();</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Fitxer escrit satisfactòriament.&quot;);</div></li><li class="li1"><div class="de1">    } catch(Exception e) {          //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error llegint estudiants: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Donat un Scanner en un fitxer quan l'apuntador és sobre l'inici</div></li><li class="li1"><div class="de1">   * de les notes, s'extreuen i es calcula la mitjana.</div></li><li class="li1"><div class="de1">   * @param lector - Scanner a processar</div></li><li class="li1"><div class="de1">   * @return Mitjana de notes</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public double llegirNotes(Scanner lector) {</div></li><li class="li1"><div class="de1">    double res = 0;</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      //Ara es llegeix fins a una marca de fi (-1)</div></li><li class="li1"><div class="de1">      boolean llegir = true;</div></li><li class="li1"><div class="de1">      int numNotes = 0;</div></li><li class="li1"><div class="de1">      while (llegir) {</div></li><li class="li1"><div class="de1">        double valor = lector.nextDouble();</div></li><li class="li1"><div class="de1">        if (valor == MARCA_FI_NOTES) {    //Final</div></li><li class="li1"><div class="de1">          llegir = false;</div></li><li class="li1"><div class="de1">        } else {                  //S'acumula el valor de les notes</div></li><li class="li1"><div class="de1">          res = res + valor;</div></li><li class="li1"><div class="de1">          numNotes++;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      res = res/numNotes;           //Es calcula nota mitjana</div></li><li class="li1"><div class="de1">    } catch (Exception e) {         //Excepció!</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error llegint notes: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    return res;</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 4</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.reptes;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">import java.util.Arrays;</div></li><li class="li1"><div class="de1">import java.util.Random;</div></li><li class="li1"><div class="de1">public class CalculsRealsBinari {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    CalculsRealsBinari programa = new CalculsRealsBinari();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    File f = new File(&quot;Reals.bin&quot;);</div></li><li class="li1"><div class="de1">    crearReals(f);</div></li><li class="li1"><div class="de1">    double[] valors = llegirReals(f);</div></li><li class="li1"><div class="de1">    if (valors != null) {</div></li><li class="li1"><div class="de1">      //Tot correcte</div></li><li class="li1"><div class="de1">      Arrays.sort(valors);  </div></li><li class="li1"><div class="de1">      for (int i = valors.length - 1; i &gt;= 0; i--) {</div></li><li class="li1"><div class="de1">        System.out.println(valors[i]);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      //Hi ha hagut un error en la lectura</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error llegint dades.&quot;);   </div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Donat un fitxer orientat a byte amb reals, els llegeix tots</div></li><li class="li1"><div class="de1">   * i els posa a un array.</div></li><li class="li1"><div class="de1">   * @param f Ruta del fitxer a llegir</div></li><li class="li1"><div class="de1">   * @return Array de reals</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public double[] llegirReals(File f) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;);</div></li><li class="li1"><div class="de1">      //Càlcul del nombre de reals</div></li><li class="li1"><div class="de1">      long numReals = f.length() / 8;</div></li><li class="li1"><div class="de1">      //per inicialitzar un array cal un &quot;int&quot;, no un &quot;long&quot;</div></li><li class="li1"><div class="de1">      int n = (int)numReals;</div></li><li class="li1"><div class="de1">      double[] array = new double[n];</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; numReals; i++) {</div></li><li class="li1"><div class="de1">        array[i] = raf.readDouble();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">      return array;</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      //Excepció!</div></li><li class="li1"><div class="de1">      return null;</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Genera un fitxer orientat a byte amb 20 valors reals, entre 0 i 100,</div></li><li class="li1"><div class="de1">   * a l'atzar.</div></li><li class="li1"><div class="de1">   *</div></li><li class="li1"><div class="de1">   * @param f Ruta del fitxer a generar</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public void crearReals(File f) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">      RandomAccessFile raf = new RandomAccessFile(f, &quot;rw&quot;);</div></li><li class="li1"><div class="de1">      Random r = new Random();</div></li><li class="li1"><div class="de1">      for (int i = 0; i &lt; 20; i++) {</div></li><li class="li1"><div class="de1">        raf.writeDouble(100*r.nextDouble());</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error generant fitxer: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 5</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">package unitat6.apartat2.reptes;</div></li><li class="li1"><div class="de1">import java.io.File;</div></li><li class="li1"><div class="de1">import java.io.RandomAccessFile;</div></li><li class="li1"><div class="de1">public class OrdenarRealsBinari {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    OrdenarRealsBinari programa = new OrdenarRealsBinari();</div></li><li class="li1"><div class="de1">    programa.inici();</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  public void inici() {</div></li><li class="li1"><div class="de1">    File f = new File (&quot;Reals.bin&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Contingut original del fitxer:&quot;);</div></li><li class="li1"><div class="de1">    mostrarFitxer(f);</div></li><li class="li1"><div class="de1">    ordenarFitxer(f);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;-----------------------------&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Contingut ordenat del fitxer:&quot;);</div></li><li class="li1"><div class="de1">    mostrarFitxer(f);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Donat un fitxer orientat a byte que conté reals, ordena directament sobre </div></li><li class="li1"><div class="de1">   * el fitxer tots els seus valors, de menor a major. </div></li><li class="li1"><div class="de1">   * </div></li><li class="li1"><div class="de1">   * @param f Ruta al fitxer amb les dades a ordenar</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public void ordenarFitxer(File f) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">     RandomAccessFile raf = new RandomAccessFile(f, &quot;rw&quot;);</div></li><li class="li1"><div class="de1">     //Cada real ocupa 8 byes, per tant, cal avançar de 8 en 8</div></li><li class="li1"><div class="de1">     for(long i = 0; i &lt; f.length(); i = i + 8) {</div></li><li class="li1"><div class="de1">       for(long j = i + 8; j &lt; f.length(); j = j + 8) {</div></li><li class="li1"><div class="de1">         //Es llegeix el valor a la posició &quot;i&quot;</div></li><li class="li1"><div class="de1">         raf.seek(i);</div></li><li class="li1"><div class="de1">         double valorI = raf.readDouble();</div></li><li class="li1"><div class="de1">         //Es llegeix el valor a la posició &quot;j&quot;</div></li><li class="li1"><div class="de1">         raf.seek(j);</div></li><li class="li1"><div class="de1">         double valorJ = raf.readDouble();</div></li><li class="li1"><div class="de1">         //Es comparen</div></li><li class="li1"><div class="de1">         if (valorI &gt; valorJ) {</div></li><li class="li1"><div class="de1">           //Si &quot;i&quot; major que &quot;j&quot;, s'intercanvien el lloc</div></li><li class="li1"><div class="de1">           raf.seek(i);</div></li><li class="li1"><div class="de1">           raf.writeDouble(valorJ);</div></li><li class="li1"><div class="de1">           raf.seek(j);</div></li><li class="li1"><div class="de1">           raf.writeDouble(valorI);</div></li><li class="li1"><div class="de1">         }</div></li><li class="li1"><div class="de1">       }</div></li><li class="li1"><div class="de1">     }</div></li><li class="li1"><div class="de1">     raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error ordenant fitxer: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">  /** Donat un fitxer orientat a byte que conté reals, mostra els valors</div></li><li class="li1"><div class="de1">   * per pantalla.</div></li><li class="li1"><div class="de1">   * </div></li><li class="li1"><div class="de1">   * @param f Ruta del fitxer a mostrar</div></li><li class="li1"><div class="de1">   */</div></li><li class="li1"><div class="de1">  public void mostrarFitxer(File f) {</div></li><li class="li1"><div class="de1">    try {</div></li><li class="li1"><div class="de1">     RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;);</div></li><li class="li1"><div class="de1">     long numReals = f.length()/8;</div></li><li class="li1"><div class="de1">     for (int i = 0; i &lt; numReals; i++) {</div></li><li class="li1"><div class="de1">       System.out.println(raf.readDouble());</div></li><li class="li1"><div class="de1">     }</div></li><li class="li1"><div class="de1">     raf.close();</div></li><li class="li1"><div class="de1">    } catch (Exception e) {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Error mostrant fitxer: &quot; + e);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

	 </article>
     <div class="pnpage">
      <div class="left-corner"></div>
      <div id="prevpage">Anar a la p&agrave;gina anterior:<br /><a href="../../../WebContent/u6/a1/exercicis.html">Exercicis d'autoavaluació</a></div>
      <div id="nextpage">Anar a la p&agrave;gina seg&uuml;ent:<br /><a href="../../../WebContent/u6/a2/activitats.html">Activitats</a></div>
      <div class="right-corner"></div>
     </div>
    </div>
    <footer class="footer">
      <div><small>Aquest document està subjecte a una llicència oberta de Creative Commons, es reserva el dret de reconeixement de l'autoria, d'exigir que no se'n faci cap mena d'ús comercial. Si altereu o transformeu aquesta obra, o en genereu obres derivades, només podeu distribuir l'obra generada amb una llicència idèntica a aquesta.</small></div>
    </footer>
 </div>
 <div id="back_preview" class="hidden"></div>
 <div id="preview" class="hidden">
  <div class="prevcontent"></div>
 </div>
 <div id="help-tooltips">
  <div id="help-toc" class="hidden tooltip"><span>Taula de continguts:</span> Ofereix una vista general de l&#39;estructura del m&ograve;dul, que us facilitar&agrave; la navegaci&oacute; a trav&eacute;s dels seus continguts.<span class="arrow-left"></span></div> 
  <div id="help-settings" class="hidden tooltip"><span>Opcions de format:</span> Permet configurar el format de lectura a partir de les vostres prefer&egrave;ncies, modificant la mida de la lletra, el color del fons, l&#39;amplada de la p&agrave;gina o l&#39;ocultaci&oacute; dels continguts complementaris, entre d&#39;altres.<span class="arrow-left"></span></div>
  <div id="help-printer" class="hidden tooltip"><span>Imprimir:</span>  Envia el contingut seleccionat a la impressora.<span class="arrow-left"></span></div>
  <div id="help-favorites" class="hidden tooltip"><span>Prefereits:</span> Permet desar aquelles parts del contingut a les que us interessi accedir en un moment posterior; us permetr&agrave; anar creant un repositori personalitzat de les seccions que considereu m&eacute;s rellevants. Un cop l&#39;hageu començat a fer servir se us mostrar&agrave; a sota un comptador que us informar&agrave; del nombre de preferits que s&#39;hagin emmagatzemat fins al moment.<span class="arrow-left"></span></div>
  <div id="help-favcounter" class="hidden tooltip"><span>Comptador i llistat de preferits:</span> Indica el nombre de preferits que s&#39;han desat fins el moment; clicant damunt seu accedireu al llistat de preferits, i a trav&eacute;s d&#39;aquest podreu accedir directament als continguts que hageu emmagatzemat.<span class="arrow-left"></span></div>
  <div id="help-help_icon" class="hidden tooltip"><span>Ajuda:</span> Aquesta opci&oacute; activa la informaci&oacute; de les funcionalitats del web tot situant el punter del ratol&iacute; al damunt dels diferents &iacute;tems.<span class="arrow-left"></span></div>
  <div id="help-sidebar-hide" class="hidden tooltip"><span>Mostrar/Ocultar barra lateral:</span>  Deshabilita la barra d&#39;opcions, permetent la seva recuperaci&oacute; quan es desitgi.<span class="arrow-left"></span></div>
  <div id="help-search" class="hidden tooltip"><span>Cerca:</span>  Introdu&iuml;u les paraules clau sobre aquells conceptes que desitgeu localitzar en els continguts del m&ograve;dul. Tamb&eacute; podeu excloure un terme de la cerca tot afegint-hi el signe &#8220;-&#8221; al davant.<span class="arrow-top"></span></div>
  <div id="help-header" class="hidden tooltip"><span>Cap&ccedil;alera:</span>  Indica l&#39;apartat o secci&oacute; que es mostra en pantalla. Tingueu present que les capçaleres de segon, tercer i quart nivell tamb&eacute; es poden desar com a marcadors.<span class="arrow-left"></span></div>
</div> 
</body>
</html>
