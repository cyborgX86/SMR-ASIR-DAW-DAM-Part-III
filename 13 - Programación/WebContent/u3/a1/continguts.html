<!doctype html>

<!--[if lt IE 7 ]> <html class="ie ie6 no-js" lang="ca"> <![endif]-->
<!--[if IE 7 ]>    <html class="ie ie7 no-js" lang="ca"> <![endif]-->
<!--[if IE 8 ]>    <html class="ie ie8 no-js" lang="ca"> <![endif]-->
<!--[if IE 9 ]>    <html class="ie ie9 no-js" lang="ca"> <![endif]-->
<!--[if gt IE 9]><!--><html class="no-js" lang="ca"><!--<![endif]-->
<!-- the "no-js" class is for Modernizr. -->

<head id="www-sitename-com" data-template-set="html5-reset">

	<meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html">
        
	<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Programació bàsica (ASX) \ Programació (DAM i DAW)</title>
	
<!-- <meta name="title" content=""> --> 
	<meta name="description" content="">
	<!-- Google will often use this as its description of your page/site. Make it good. -->
	
	<meta name="google-site-verification" content="">
	<!-- Speaking of Google, don't forget to set your site up: http://google.com/webmasters -->
	
	<meta name="author" content="Institut Obert de Catalunya">
	<meta name="Copyright" content="Copyright Institut Obert de Catalunya 2011. All Rights Reserved.">

	<!-- Dublin Core Metadata : http://dublincore.org/ -->
	<meta name="DC.title" content="Programació bàsica (ASX) \ Programació (DAM i DAW)">
	<meta name="DC.subject" content="Informàtica i comunicacions">
	<meta name="DC.creator" content="Institut Obert de Catalunya">
	
	<!--  Mobile Viewport Fix
	j.mp/mobileviewport & davidbcalhoun.com/2010/viewport-metatag 
	device-width : Occupy full width of the screen in its current orientation
	initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
	maximum-scale = 1.0 retains dimensions instead of zooming in if page width < device width
	-->
	<!-- Uncomment to use � use thoughtfully!
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	-->

	<link rel="shortcut icon" href="../../../img/favicon.ico">
	<!-- This is the traditional favicon.
		 - size: 16x16 or 32x32
		 - transparency is OK
		 - see wikipedia for info on browser support: http://mky.be/favicon/ -->
		 
	<link rel="apple-touch-icon" href="../../../img/apple-touch-icon.png">
	<!-- The is the icon for iOS's Web Clip.
		 - size: 57x57 for older iPhones, 72x72 for iPads, 114x114 for iPhone4's retina display (IMHO, just go ahead and use the biggest one)
		 - To prevent iOS from applying its styles to the icon name it thusly: apple-touch-icon-precomposed.png
		 - Transparency is not recommended (iOS will put a black BG behind the icon) -->
	
	<!-- CSS: screen, mobile & print are all in the same file -->
	<link rel="stylesheet" href="../../../_/css/style.css">

	<!-- CSS: jQuery UI -->
	<link rel="stylesheet" href="../../../_/css/jquery-ui.css">
	
	<!-- all our JS is at the bottom of the page, except for Modernizr. -->
	<script src="../../../_/js/modernizr-1.7.min.js"></script>
	<script src="../../../_/js/Hyphenator.js" type="text/javascript"></script>
	<script type="text/javascript">
	   Hyphenator.config({
		minwordlength : 4
	   });
	   Hyphenator.run();
	</script>
    <script src="../../../_/js/build.js" type="text/javascript"></script>
</head>

<body class="style-newspaper">

<div class="wrapper"><!-- not needed? up to you: http://camendesign.com/code/developpeurs_sans_frontieres -->

	<header id="header">
		<div class="head"><a href="http://ioc.gencat.cat"><img src="../../../img/logo.png" alt="Institut Obert de Catalunya"/></a><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/es/deed.ca"><img src="../../../img/license.png" alt="Llic&egrave;ncia" class="license"/></a></div>
		<div class="headdocument"><a href="../../../index.html">Programació bàsica (ASX) \ Programació (DAM i DAW)</a></div>
        <div id="search" class="search" name="search">
         <form id="frmsearch" action="../../../search.html" method="get">
          <input type="text" name="q"/>
        </form>
        </div>
	</header>
   <div id="upbutton" class="upbutton" style="display:none;"><img src="../../../img/uparrow.png" alt="Pujar a l'inici de p&agrave;gina"/></div>
   <aside id="aside">
    <div id="menu">
      <ul>
       <li name="toc"><div><img src="../../../img/toc.png" alt="&Iacute;ndex"/></div></li>
       <li name="settings"><div><img src="../../../img/settings.png" alt="Configuraci&oacute;"/></div></li>
       <li name="printer"><div><img src="../../../img/printer.png" alt="Imprimir"/></div></li>
       <li name="favorites"><div><img src="../../../img/favorites.png" alt="Favorits"/></div></li>
       <li name="help_icon" class="help_icon"><div><img src="../../../img/help_icon.png" alt="Ajuda"/></div></li>
      </ul>
     </div>
   </aside>
   <div id="sidebar-hide" name="sidebar-hide"><img src="../../../img/arrows.png"/></div>
   <section>
     <div id="toc" class="hidden">
      <div class="menucontent">
        <ul>
        <li id="u3" class="parentnode"><p><a class="unit" href="../../../WebContent/u3/introduccio.html">3. Tipus de dades compostes</a></p><ul class="expander"><li id="u3introduccio"><a href="../../../WebContent/u3/introduccio.html">Introducció</a></li><li id="u3resum"><a href="../../../WebContent/u3/resum.html">Resum</a></li><li id="u3resultats_d_aprenentatge"><a href="../../../WebContent/u3/resultats_d_aprenentatge.html">Resultats d'aprenentatge</a></li><li id="u3mapa"><a href="../../../WebContent/u3/mapa.html">Mapa conceptual</a></li><li id="u3referencies"><a href="../../../WebContent/u3/referencies.html">Referències</a></li><li id="u3a1" class="tocsection"><p id='u3a1continguts'><a class="section" href="../../../WebContent/u3/a1/continguts.html">Tipus de dades compostes: "arrays"</a><span class="buttonexp"></span></p><ul><li id="u3a1activitats"><a href="../../../WebContent/u3/a1/activitats.html">Activitats</a></li><li id="u3a1exercicis"><a href="../../../WebContent/u3/a1/exercicis.html">Exercicis d'autoavaluació</a></li></ul></li><div data-parent-id='u3a1' class='tocssection hidden'><div class="toc"><ul><li><a href="../../../WebContent/u3/a1/continguts.html#declaracio_i_inicialitzacio_d_arrays">Declaració i inicialització d'"arrays"</a></li><li><a href="../../../WebContent/u3/a1/continguts.html#manipulacio_de_dades_dins_d_arrays">Manipulació de dades dins d'"arrays"</a></li><li><a href="../../../WebContent/u3/a1/continguts.html#emmagatzematge_de_l_entrada_de_dades_en_un_array">Emmagatzematge de l'entrada de dades en un "array"</a></li><li><a href="../../../WebContent/u3/a1/continguts.html#esquemes_fonamentals_en_la_utilitzacio_d_arrays">Esquemes fonamentals en la utilització d'"arrays"</a></li><li><a href="../../../WebContent/u3/a1/continguts.html#arrays_multidimensionals">"Arrays" multidimensionals</a></li><li><a href="../../../WebContent/u3/a1/continguts.html#solucions_dels_reptes_proposats">Solucions dels reptes proposats</a></li></ul></div></div><li id="u3a2" class="tocsection"><p id='u3a2continguts'><a class="section" href="../../../WebContent/u3/a2/continguts.html">Tractament de cadenes de text</a><span class="buttonexp"></span></p><ul><li id="u3a2activitats"><a href="../../../WebContent/u3/a2/activitats.html">Activitats</a></li><li id="u3a2exercicis"><a href="../../../WebContent/u3/a2/exercicis.html">Exercicis d'autoavaluació</a></li><li id="u3a2annexos"><a href="../../../WebContent/u3/a2/annexos.html">Annexos</a></li></ul></li><div data-parent-id='u3a2' class='tocssection hidden'><div class="toc"><ul><li><a href="../../../WebContent/u3/a2/continguts.html#la_classe_string">La classe "String"</a></li><li><a href="../../../WebContent/u3/a2/continguts.html#entrada_de_cadenes_de_text">Entrada de cadenes de text</a></li><li><a href="../../../WebContent/u3/a2/continguts.html#manipulacio_de_cadenes_de_text">Manipulació de cadenes de text</a></li><li><a href="../../../WebContent/u3/a2/continguts.html#solucions_dels_reptes_proposats">Solucions dels reptes proposats</a></li></ul></div></div></ul></li><li id="" class="indexnode"><p><a href="../../../index.html">Anar a l&#39;&iacute;ndex general</a></p></li>
        </ul>
      </div>
    </div>
   </section>
   <section>
   <div id="settings" class="hidden">
    <div class="menucontent">
     <div class="allsettings">
     <div class="settings">
      <label>Font i Color</label>
		<div class="setting-option">
	        <ul class="fontBackground">
				<li id="style-newspaper" title="Newspaper" class="appearance-style-newspaper"><span>Newspaper</span></li>
                <li id="style-novel" title="Novel" class="appearance-style-novel"><span>Novel</span></li>
                <li id="style-ebook" title="eBook" class="appearance-style-ebook"><span>eBook</span></li>
				<li id="style-inverse" title="Inverse" class="appearance-style-inverse active"><span>Inverse</span></li>
				<li id="style-athelas" title="Athelas" class="appearance-style-athelas"><span>Athelas</span></li>
			</ul>
		</div>
     </div>
	<div class="settings">
      <label>Amplada</label>
		<div class="setting-option">
	        <div id="slider-width"></div>
		</div>
     </div>
     <div class="settings">
      <label>Mida de la font</label>
		<div class="setting-option">
	        <div id="slider-font"></div>
		</div>
     </div>
     <div class="settings">
      <label>Mida de la font</label>
	  <div class="setting-option">
       <form action="" class="sett-options">
		<ul>
		    <li><input type="checkbox" id="secondary-content" /><label for="secondary-content">Mostra recursos complementaris</label></li>
		    <li><input type="checkbox" id="main-images" /><label for="main-images">Mostra imatges</label></li>
		    <li><input type="checkbox" id="text-alignment" /><label for="text-alignment">Text justificat</label></li>
			<li><input type="checkbox" id="text-hyphen" /><label for="text-hyphen">Partici&oacute; sil·l&agrave;bica</label></li>
		</ul>
       </form>
	  </div>
     </div>
     </div>
    </div>
   </div>
   </section>
 <section>
 <div id="favorites" class="hidden"></div>
 </section>   
 <div id="bridge" class="hidden"></div>
 <div id="help" class="hidden">
  <div class="helptitle">Dreceres del teclat<hr></div>
  <div class="helpsection"><span>General</span>
   <ul>
    <li><span class="shortcut">g</span>: Anar al men&uacute; de navegaci&oacute;</li>
    <li><span class="shortcut">o</span>: Anar a opcions</li>
    <li><span class="shortcut">s</span>: Guardar la p&agrave;gina actual a favorits</li>
    <li><span class="shortcut">p</span>: Imprimir la p&agrave;gina actual</li>
    <li><span class="shortcut">?</span>: Mostrar/Ocultar l&#39;ajuda</li>
   </ul>
  </div>
  <div class="helpsection"><span>Navegaci&oacute;</span>
   <ul>
    <li><span class="shortcut">i</span>: Anar a l&#39;&iacute;ndex general</li>
    <li><span class="shortcut">t</span>: Anar a l&#39;inici de p&agrave;gina</li>
    <li><span class="shortcut">b</span>: Anar al final de p&agrave;gina</li>
    <li><span class="shortcut">j</span>: Anar cap endavant dintre la p&agrave;gina</li>
    <li><span class="shortcut">k</span>: Anar cap enrere dintre la p&agrave;gina</li>
    <li><span class="shortcut">h</span>: Anar a la p&agrave;gina anterior:</li>
    <li><span class="shortcut">l</span>: Anar a la p&agrave;gina seg&uuml;ent:</li>
   </ul>
   </div>
 </div>
 <div id="favcounter" name="favcounter" class="hidden"><span></span></div>
 <div id="navmenu" class="navmenu"><ul class="webnav"><li><a href="../../../index.html" title="Anar a l&#39;&iacute;ndex general">Inici</a></li><li><a href="../introduccio.html">Tipus de dades compostes</a></li><li>Tipus de dades compostes: "arrays"</li></ul></div>
	<div id="content" lang="ca" class="hyphenate text">
     <article lang="ca" class="sheet">
        <h1><a id="tipus_de_dades_compostesarrays"> Tipus de dades compostes: "arrays" </a></h1>
    	
<p>
Suposeu que voleu fer un programa per analitzar les notes finals d’un conjunt d’estudiants. Les operacions per fer poden ser diverses: calcular la nota mitjana, veure quants estudiants han aprovat, suspès o han superat cert llindar de nota, fer gràfiques de rendiment, etc. A més, no es descarta que en el futur el programa es modifiqui per afegir-hi noves funcionalitats. El <em>quid</em> de la qüestió és que, per poder preveure totes aquestes possibilitats i d’altres de futures encara desconegudes, us cal disposar dins del programa del valor de cada nota individual. En un cas com aquest, tal com s’ha plantejat fins ara l’aproximació per manipular dades dins d’un programa, això implica que cada nota s’ha d’emmagatzemar dins d’una variable diferent. Si hi ha 50 estudiants, això vol dir que caldria declarar 50 variables.
</p>

<p>
Malauradament, aquesta aproximació no funciona en un cas com aquest, en què el nombre de dades per processar és relativament alt. D’una banda, imagineu-vos l’aspecte que tindrà un codi font en què cal declarar i manipular 50 variables per fer tota mena de càlculs. Les expressions per fer càlculs entre elles, com simplement fer la mitjana (sumar-les totes i dividir pel nombre de valors), serien enormes. D’altra banda, què passa si cal processar les notes de dos-cents o mil estudiants? És factible declarar mil variables? Pitjor encara: què passa si el nombre d’estudiants de cada curs és totalment diferent? En cada curs el nombre de variables usades no encaixarà amb el d’estudiants i serà necessari modificar el codi font tenint en compte el nombre exacte de valors per tractar i tornar a compilar. 
</p>

<p>
Ja a simple vista es pot apreciar que tot plegat és inviable. Cal un sistema flexible per emmagatzemar un nombre arbitrari de valors de manera que aquests siguin fàcils de manipular. Encara més, ha de ser possible que el nombre de valors emmagatzemats pugui ser diferent per a cada execució del programa. Per resoldre aquesta problemàtica, els llenguatges de programació d’alt nivell ofereixen el tipus de dada compost <em>array</em>, o taula.
</p>

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10mu3_01.png" class="imgB" title="Un &quot;array&quot; és com una calaixera. Imatge de Liverpool Design Festival/18" alt="Un &quot;array&quot; és com una calaixera. Imatge de Liverpool Design Festival/18" /></li><li><small>Un &quot;array&quot; és com una calaixera. Imatge de Liverpool Design Festival</small></li>
</ul></div>

</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Un <strong>tipus de dada compost</strong> és aquell que permet emmagatzemar més d’un valor dins d’una única variable. En el cas de l’<strong>array</strong>, aquest permet emmagatzemar, en forma de seqüència, una quantitat predeterminada de valors pertanyents al <strong>mateix tipus</strong> de dades.
</p>
</div></div>
<p>
Per tal de diferenciar els diferents valors emmagatzemats, l’<em>array</em> gestiona el seu contingut d’acord amb posicions que segueixen un ordre numèric: el valor emmagatzemat a la primera posició, a la segona, a la tercera, etc. A efectes pràctics, es pot considerar que cada posició individual es comporta exactament igual que una variable del tipus de dada triat. Tant es pot consultar el valor com emmagatzemar-hi dades. Aquest comportament s’esquematitza a la <span class="figref"><a href="#Figure1"><span>figura</span></a></span>.
</p>
<div class="iocfigure"><a name="Figure1"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Organització de les dades emmagatzemades dins d’un <code>array</code>

</figcaption><img src="../media/ic10mu3_02.png" alt="" /></figure>
</div>
<p>
Abans de veure amb més detall com funcionen, heu de tenir present que la sintaxi per usar <em>arrays</em> en els diferents llenguatges de programació pot ser relativament diferent. Aquest apartat se centrarà en la sintaxi concreta del Java, que té certes particularitats úniques. Tot i així, el concepte general d’accés a valors ordenats com una seqüència en forma d’<em>array</em> és aplicable a qualsevol llenguatge.
</p>

<h2><a id="declaracio_i_inicialitzacio_d_arrays" >Declaració i inicialització d&#039;&quot;arrays&quot;</a></h2>
<div class="level2">

<p>
Com passa amb dades de qualsevol altre tipus, abans de poder fer ús d’una variable de tipus <em>array</em>, cal declarar-la i atorgar-li un valor inicial correctament. La sintaxi per declarar un <em>array</em> és força semblant a la d’altres tipus, però la inicialització té unes particularitats especials a causa de les seves característiques pròpies: 
</p>
<ul>
<li class="level1"><div class="li"> D’una banda, cal decidir de quantes posicions disposarà l’<em>array</em>: la seva <strong>mida</strong>. Mai no hi podrà haver emmagatzemats més valors que la seva capacitat. </div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> D’una altra banda, cal decidir el valor inicial per a cada posició individual de l’<em>array</em>. En aquest aspecte, cada posició té el mateix paper que una variable individual dins del programa, i per tant, ha d’estar inicialitzada amb algun valor.</div>
</li>
</ul>
<div class="iocimportant"><div class="ioccontent">
<p>
En el moment de la inicialització d’un <em>array</em>, la seva mida ha de ser coneguda. Un cop ha estat inicialitzat amb un nombre de posicions concretes, aquesta ja no pot canviar.
</p>
</div></div>
<p>
Abans de poder usar un <em>array</em> és obligatori inicialitzar-lo. Java donarà un error de compilació en cas contrari.
</p>

</div>

<h3><a id="inicialitzacio_a_un_valor_concret" >Inicialització a un valor concret</a></h3>
<div class="level3">

<p>
Com passa amb les variables individuals, hi ha la possibilitat que en el moment de generar el codi font ja tingueu uns valors concrets al cap amb els quals voleu inicialitzar cadascuna de les posicions de l’<em>array</em>. En aquest cas, la sintaxi de la inicialització és la següent:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">paraulaClauTipus[] identificadorVariable = {valor1, valor2, ... , valorN};</div></li></ol></pre>

<p>
La part esquerra és pràcticament igual que per a la declaració d’una variable qualsevol. El que indica que en realitat s’està declarant un <em>array</em> són els dos claudàtors <code>[]</code> immediatament després de la declaració del tipus. Cadascuna de les posicions de l’<em>array</em> només podrà emmagatzemar valors del tipus declarat aquí. 
</p>

<p>
Per especificar els valors emmagatzemats inicialment a cada posició n’hi ha prou que aquests s’enumerin entre claus <code>{…}</code>, separats per comes (<code>,</code>). Aquests valors han de ser del mateix tipus de dada que el declarat a la part esquerra i s’emmagatzemaran en el mateix ordre en què s’hagin enumerat: el primer valor a la primera posició de l’<em>array</em>, el segon a la segona posició, etc. En aquest cas, la mida de l’<em>array</em> serà automàticament igual que el nombre de valors enumerats.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
No hi pot haver dades de tipus barrejats dins d’un <em>array</em>.
</p>
</div></div>
<p>
Per exemple, per declarar un <em>array</em> de 5 posicions en què es poden emmagatzemar valors de tipus enter, cadascuna amb els valors inicials 10, 20, 30, 40 i 50, respectivament, es faria de la manera següent. La mida d’aquest <em>array</em> seria 5.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">int[] arrayEnters = {10, 20, 30, 40, 50};</div></li></ol></pre>

<p>
El resultat es mostra a la <span class="figref"><a href="#Figure2"><span>figura</span></a></span>.
</p>
<div class="iocfigure"><a name="Figure2"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Esquema d’inicialització d’un “array” en Java amb valors concrets.

</figcaption><img src="../media/ic10mu3_03.png" alt="" /></figure>
</div>
</div>

<h3><a id="inicialitzacio_a_un_valor_per_defecte" >Inicialització a un valor per defecte</a></h3>
<div class="level3">

<p>
Moltes vegades les dades que es volen emmagatzemar depenen de la lectura d’una entrada (per exemple, per teclat), o bé són resultat de càlculs que són més còmodes de dur a terme de manera automatitzada dins del codi de programa (per exemple, una llista de 1.000 nombres primers). En aquest cas, no hi ha un valor inicial concret que calgui assignar a les posicions de l’<em>array</em>, ja que els valors s’emmagatzemaran <em>a posteriori</em>. 
</p>

<p>
En aquest cas, una altra manera, més simple i habitual, de declarar i inicialitzar-lo, és assumint que totes les posicions prenen automàticament un valor per defecte, que és 0 per a les dades de tipus numèric i els caràcters, i <code>false</code> per a booleans. Més endavant ja assignareu a cada posició el valor que vulgueu. 
</p>

<p>
Això es fa de la manera següent:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">paraulaClauTipus[] identificadorVariable = new paraulaClauTipus[mida];</div></li></ol></pre>

<p>
Només varia la part dreta, relativa a l’assignació dels valors inicials. En aquest cas la sintaxi és molt estricta i cal emprar el format indicat. S’usa la paraula clau <code>new</code>, seguida novament del tipus de les dades dins l’<em>array</em> i, entre claudàtors, la mida que vulguem. Els tipus de dades especificats a la part esquerra i dreta han de ser idèntics, o hi haurà un error de compilació. 
</p>

<p>
No cal fer res més per assignar valors a les posicions de l’<em>array</em>, Java ja hi assigna automàticament el valor per defecte. Ara bé, alerta, aquesta és una propietat <strong>específica</strong> del Java i no ha de ser així necessàriament en altres llenguatges, en què el valor inicial de cada posició pot ser indeterminat.
</p>

<p>
Per exemple, per declarar un <em>array</em> de 10 posicions en què es poden emmagatzemar valors de tipus real, tots inicialment amb el valor 0, es faria de la manera següent:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">double[] arrayReals = new double[10];</div></li></ol></pre>

<p>
Aquest codi és equivalent a fer:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">double[] arrayReals = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};</div></li></ol></pre>

<p>
El resultat de fer qualsevol de les dues instruccions es visualitza a la <span class="figref"><a href="#Figure3"><span>figura</span></a></span>.
</p>
<div class="iocfigure"><a name="Figure3"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Esquema d’inicialització d’un “array” en Java amb valors per defecte

</figcaption><img src="../media/ic10mu3_04.png" alt="" /></figure>
</div>
</div>

<h2><a id="manipulacio_de_dades_dins_d_arrays" >Manipulació de dades dins d&#039;&quot;arrays&quot;</a></h2>
<div class="level2">

<p>
Tot i conformar un tipus de dada (com els enters, reals, etc.),  els <em>arrays</em> són una mica especials a l’hora de ser manipulats, ja que no disposen de cap operació. No és possible usar l’identificador de l’<em>array</em> directament per invocar operacions i així manipular les dades contingudes, tal com es pot fer amb variables d’altres tipus. Per exemple, no és possible fer el següent:
</p>
<div class="iocnote"><div class="ioccontent">
<p>
En el Java, fer operacions entre <em>arrays</em> comporta un error de compilació.
</p>
</div></div><pre class="code java"><ol><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">int[] a = {10, 20, 30, 40, 50};</div></li><li class="li1"><div class="de1">int[] b = {50, 60, 70, 80, 100};</div></li><li class="li1"><div class="de1">int[] c = a + b;</div></li><li class="li1"><div class="de1">...</div></li></ol></pre>

<p>
Sempre que es vulgui fer alguna operació amb les dades emmagatzemades dins d’<em>arrays</em> cal manipular-les de manera individual, posició per posició. En aquest aspecte, cada posició d’un <em>array</em> té exactament el mateix comportament que una variable tal com les heu estudiades fins ara. Les podeu aprofitar tant per emmagatzemar dades com per llegir-ne el contingut.
</p>

<p>
Per tal de distingir entre les diferents posicions d’un <em>array</em>, cadascuna té assignat un <strong>índex</strong>, un valor enter que n’indica l’ordre dins de l’estructura. Sempre que us vulgueu referir a una de les posicions, n’hi ha prou d’usar l’identificador de l’<em>array</em> juntament amb l’índex de la posició buscada entre claudàtors <code>[]</code>. La sintaxi exacta és:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">identificadorArray[índex]</div></li></ol></pre>

<p>
El rang dels índexs pot variar segons el llenguatge de programació. En el cas del Java, aquests van de 0, per a la primera posició, a (mida − 1), per a la darrera. Per exemple, per accedir a les posicions d’un <em>array</em> de cinc posicions usaríeu els índexs 0, 1, 2, 3 i 4. Tot seguit es mostra un exemple de com s’accedeix a les dades d’un <em>array</em> mitjançant els índexs de les seves posicions: 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">int[] arrayA = {10, 20, 30, 40, 50};</div></li><li class="li1"><div class="de1">int[] arrayB = {50, 60, 70, 80, 100};</div></li><li class="li1"><div class="de1">int[] arrayC = new int[5];</div></li><li class="li1"><div class="de1">//La variable de tipus enter &quot;r&quot; valdrà 140, 40 + 100.</div></li><li class="li1"><div class="de1">int r = arrayA[3] + arrayB[4];</div></li><li class="li1"><div class="de1">//La segona posició (índex 1) d'&quot;arrayC&quot; valdrà 150, 140 + 10.</div></li><li class="li1"><div class="de1">arrayC[1] = r + arrayA[0];</div></li><li class="li1"><div class="de1">...</div></li></ol></pre>

<p>
La <span class="figref"><a href="#Figure4"><span>figura</span></a></span> esquematitza l’accés a les dades dins d’aquest codi.
</p>
<div class="iocfigure"><a name="Figure4"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Exemple de manipulació de dades dins d’“arrays”

</figcaption><img src="../media/ic10mu3_05.png" alt="" /></figure>
</div>
<p>
És molt important que en accedir a un <em>array</em> s’utilitzi un índex correcte, d’acord amb el rang admissible. Si s’usa un valor no admissible, com per exemple un valor negatiu o un valor igual o superior a la seva mida, hi haurà un error d’execució. Concretament, es produirà una <code>IndexOutOfBoundsException</code>. Si això succeeix, podeu tenir la certesa que el programa té una errada i l’haureu de repassar i corregir. Per tant, els codi següent seria incorrecte:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">//&quot;arrayA&quot; té mida 5. </div></li><li class="li1"><div class="de1">//Els índexs vàlids van de 0 a (mida − 1), que és 4.</div></li><li class="li1"><div class="de1">int[] arrayA = {10, 20, 30, 40, 50};</div></li><li class="li1"><div class="de1">//S'assigna un valor a una posició incorrecta (índex 5).</div></li><li class="li1"><div class="de1">arrayA[5] = 60;</div></li><li class="li1"><div class="de1">//L'índex 6 és invàlid, no es pot consultar el valor.</div></li><li class="li1"><div class="de1">int r = arrayA[2] + arrayA[4] + arrayA[6];</div></li><li class="li1"><div class="de1">...</div></li></ol></pre>

<p>
Per tal d’ajudar-vos en la tasca de controlar si un índex concret està dins del rang admissible per a una variable de tipus <em>array</em> concreta, Java disposa d’una eina auxiliar, l’atribut <code>length</code> (llargària).  La seva sintaxi és la següent:  
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">identificadorArray.length</div></li></ol></pre>

<p>
El resultat d’aquesta instrucció és equivalent a avaluar una expressió que com a resultat obté la mida de l’<em>array</em> anomenat <code>identificadorArray</code>. Ara bé, recordeu que <code>length</code> us dóna la mida, però el rang d’índexs vàlid és 0 … (mida − 1). Per exemple:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">//&quot;arrayA&quot; té mida 5. Els índexs vàlids van de 0 a 4.</div></li><li class="li1"><div class="de1">int[] arrayA = {10, 20, 30, 40, 50};</div></li><li class="li1"><div class="de1">//&quot;length&quot; us diu la mida. </div></li><li class="li1"><div class="de1">//Recordeu que l'índex màxim és (mida − 1).</div></li><li class="li1"><div class="de1">if (index &lt; arrayA.length) {</div></li><li class="li1"><div class="de1">  System.out.println(&quot;La posició &quot; + index + &quot; val &quot; + a[index]);</div></li><li class="li1"><div class="de1">} else {</div></li><li class="li1"><div class="de1">  System.out.println(&quot;Aquest array no té tantes posicions!&quot;);</div></li><li class="li1"><div class="de1">}</div></li><li class="li1"><div class="de1">...</div></li></ol></pre>

</div>

<h2><a id="emmagatzematge_de_l_entrada_de_dades_en_un_array" >Emmagatzematge de l&#039;entrada de dades en un &quot;array&quot;</a></h2>
<div class="level2">

<p>
Com s’ha esmentat, els <em>arrays</em> són especialment útils per poder emmagatzemar de manera eficient un nombre arbitrari de dades provinents del sistema d’una entrada (per exemple, des del teclat). Normalment, les dades s’aniran llegint una per una, i a mesura que es faci, caldrà anar-les assignant a cadascuna de les posicions de l’<em>array</em> a partir del seu índex. Tot seguit veureu diferents esquemes per dur a terme aquesta tasca.
</p>

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10mu3_06.png" class="imgB" title="Emmagatzemar en &quot;arrays&quot; dades llegides seqüencialment és com una cadena d&#039;embotellament" alt="Emmagatzemar en &quot;arrays&quot; dades llegides seqüencialment és com una cadena d&#039;embotellament" /></li><li><small>Emmagatzemar en &quot;arrays&quot; dades llegides seqüencialment és com una cadena d&#039;embotellament</small></li>
</ul></div>

</p>

<p>
Si bé els exemples se centraran en l’ús del teclat, ja que és el sistema d’entrada que per ara sabeu utilitzar, heu de tenir en compte que aquests esquemes seran aplicables a qualsevol altre mecanisme d’entrada (per exemple, un fitxer). L’única condició és que les dades estiguin en forma de seqüència, de manera que es puguin anar llegint una per una, ordenadament.
</p>

<p>
Un cop exposats aquests esquemes, en la resta d’exemples de l’apartat s’obviarà el codi relatiu a l’entrada de dades pel teclat.
</p>

</div>

<h3><a id="entrada_de_sequeencies_de_valors_per_teclat" >Entrada de seqüències de valors per teclat</a></h3>
<div class="level3">

<p>
Els <em>arrays</em> tenen sentit quan el programa ha de processar moltes dades, especialment provinents de l’entrada del programa (com el teclat). Abans de continuar, val la pena veure com es poden llegir seqüències de dades entrades des del teclat en una sola línia de text, de manera que sigui senzill emmagatzemar-les dins d’un <em>array</em>. Si bé ja sabeu com llegir dades individualment des del teclat, fer-ho així pot ser una mica avorrit i molest amb vista a l’execució dels programes en què s’introdueixen moltes dades, preguntant cada valor un per un i havent de pitjar la tecla de retorn cada vegada.
</p>

<p>
En realitat, quan s’usa una instrucció <code>lector.next…</code> i el programa s’atura esperant que l’usuari introdueixi dades pel teclat, res no impedeix que, en lloc d’una única dada, aquest n’escrigui més d’una abans de pitjar la tecla de retorn. O sigui, una seqüència de valors. L’única condició és que cada valor individual estigui separat de la resta per almenys un espai, de manera que siguin fàcilment identificables. Quan això succeeix, tots els valors de la seqüència queden latents, pendents de lectura. Successives invocacions a noves instruccions de lectura automàticament aniran consumint aquests valors pendents, en lloc de causar una nova espera d’una entrada de l’usuari. Mentre quedin valors a la seqüència pendents de llegir, les instruccions de lectura mai no causaran una espera d’entrada de dades. Un cop la seqüència ha estat consumida totalment, llavors sí que la propera instrucció de lectura causarà que el programa es torni a aturar esperant una nova entrada de l’usuari. I així el cicle de lectura torna a començar.
</p>

<p>
Dins d’aquest procés hi ha una crida amb un comportament especial: <code>lector.nextLine();</code>. Quan aquesta crida s’invoca, automàticament es descarten tots els valors pendents de llegir de la seqüència actual. La propera crida a una instrucció de lectura sempre causarà que el programa s’aturi de nou i esperi una entrada de l’usuari.
</p>

<p>
La <span class="tabref"><a href="#Table1"><span>taula</span></a></span> mostra un exemple d’aquest mecanisme de lectura, en què es llegeixen valors de tipus enter.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table1"><span>Taula: </span></a>Exemple de lectura d’una seqüència de valors enters</div>
<div class="table"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Acció del programa   </th><th class="col1 leftalign"> Resultat obtingut                           </th><th class="col2 leftalign"> Dades pendents de lectura    </th>
	</tr>
	<tr class="row1">
		<td class="col0"> (Inici del programa) </td><td class="col1 leftalign"> El programa s’inicia                        </td><td class="col2 leftalign"> { } (no n’hi ha cap)         </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> Llegir valor         </td><td class="col1 leftalign"> El programa espera entrada de l’usuari      </td><td class="col2 leftalign"> { } (no n’hi ha cap)         </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign">                      </td><td class="col1" colspan="2"> <em> L’usuari entra els valors “1 2 4 8 16 32” i pitja la tecla de retorn</em> </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign">                      </td><td class="col1 leftalign"> La lectura avalua <code>1</code>                     </td><td class="col2 leftalign"> { 2, 4, 8, 16, 32 }          </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> Llegir valor         </td><td class="col1 leftalign"> La lectura avalua <code>2</code>                     </td><td class="col2 leftalign"> { 4, 8, 16, 32 }             </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> Llegir valor         </td><td class="col1 leftalign"> La lectura avalua <code>4</code>                     </td><td class="col2 leftalign"> { 8, 16, 32 }                </td>
	</tr>
	<tr class="row7">
		<td class="col0 leftalign"> Llegir valor         </td><td class="col1 leftalign"> Es buida la seqüència de dades pendents     </td><td class="col2 leftalign"> { }                          </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign"> Llegir valor         </td><td class="col1 leftalign"> El programa espera entrada de l’usuari      </td><td class="col2 leftalign"> { }                          </td>
	</tr>
	<tr class="row9">
		<td class="col0 leftalign" colspan="3"> Es torna a començar el cicle de lectura d’una nova seqüència de valors…                       </td>
	</tr>
</table></div>
</div>
<p>
Un fet important quan es llegeixen seqüències de diversos valors escrites des del teclat és que res no impedeix que hi pugui haver valors de diferents tipus de dades barrejats. Això tant pot ser per error de l’usuari en entrar les dades, com perquè el programa realment espera una seqüència amb valors de diferents tipus intercalats. En qualsevol cas, és important que abans de fer cap lectura d’una dada es comprovi si el tipus és el que correspon usant les instruccions <code>lector.hasNext…</code>.
</p>

<p>
Per llegir múltiples valors el més senzill és fer-ho mitjançant una estructura de repetició que vagi invocant successivament les instruccions de lectura de dades. En usar aquest mecanisme cal tenir present un fet ben important. S’ha de saber exactament quan heu obtingut ja totes les dades necessàries i cal deixar llegir. Normalment hi ha dues aproximacions depenent de si es coneix la quantitat de dades exactes que cal llegir o no.
</p>

</div>

<h4><a id="quantitat_de_dades_coneguda" >Quantitat de dades coneguda</a></h4>
<div class="level4">

<p>
Si el nombre de valors que es vol llegir és conegut per endavant, per tractar la lectura de la seqüència de valors hi ha prou d’usar una estructura de repetició basada en un comptador. Aquest comptador controlarà el nombre de valors llegits i les iteracions finalitzaran en assolir el nombre de lectures que vulguem. 
</p>

<p>
Compileu i executeu l’exemple següent, en què es mostra com cal fer la lectura d’un seguit de valors enters. Si se n’escriuen més dels esperats, la resta es descarten. Fixeu-vos que no és necessari escriure tots els valors en una sola línia de text. Si la línia introduïda, abans de pitjar la tecla de retorn, no disposa de suficients valors, el programa s’atura esperant la resta. A més a més, aquest codi controla mitjançant una estructura de selecció si el valor que és a punt de ser llegit serà realment un enter o no.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">//Un programa que llegeix un nombre conegut de valors enters.</div></li><li class="li1"><div class="de1">public class LectorValorsConeguts {</div></li><li class="li1"><div class="de1">  //Es llegiran 10 valors.</div></li><li class="li1"><div class="de1">  public static final int NUM_VALORS = 10;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Escriu &quot; + NUM_VALORS + &quot; enters. Es pot fer en diferents línies.&quot;);</div></li><li class="li1"><div class="de1">    //Es llegeixen exactament NUM_VALORS valors.</div></li><li class="li1"><div class="de1">    int numValorsLlegits = 0;</div></li><li class="li1"><div class="de1">    while (numValorsLlegits &lt; NUM_VALORS) {</div></li><li class="li1"><div class="de1">      //Abans de llegir, comprovem si realment hi ha un enter.</div></li><li class="li1"><div class="de1">      if (lector.hasNextInt()) {</div></li><li class="li1"><div class="de1">        int valor = lector.nextInt();</div></li><li class="li1"><div class="de1">        System.out.println(&quot;Valor &quot; + numValorsLlegits + &quot; llegit: &quot; + valor);</div></li><li class="li1"><div class="de1">        numValorsLlegits++;</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        //Si el valor no és enter, es llegeix però s'ignora.</div></li><li class="li1"><div class="de1">        //No s'avança tampoc el comptador.</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Els valors que sobrin a la darrera línia escrita es descarten.</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Ja s'han llegit &quot; + NUM_VALORS + &quot; valors.&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h4><a id="quantitat_de_dades_desconeguda" >Quantitat de dades desconeguda</a></h4>
<div class="level4">

<p>
Un cas més complex és quan el nombre de valors no és conegut <em>a priori</em>, ja que pot variar en diferents execucions del programa. Quan això succeeix, una solució simple seria preguntar simplement, abans de llegir cap valor, quantes dades s’introduiran, o bé fer que el primer valor dins de la seqüència n’indiqui la longitud.
</p>

<p>
Si això no és possible, o es considera que no s’ha de fer, una altra opció és establir un valor especial que no forma part de les dades per tractar dins el programa, sinó que es considerarà com a <strong>marca de final de seqüència</strong>. Tan bon punt es llegeixi aquest valor, la lectura s’ha de donar per finalitzada. La condició per poder usar aquesta estratègia és que la marca no sigui un valor que pugui aparèixer mai entre els valors introduïts. Ha de ser únic. Per exemple, dins una llista de notes, qualsevol valor negatiu o major que 10 serviria. La resta de valors no es poden usar, ja que poden correspondre a una nota real que cal tractar.
</p>

<p>
Si tots els valors possibles són acceptables dins de la seqüència una opció és usar un valor d’un tipus de dada diferent. Per exemple, un programa que processa valors reals arbitraris per fer càlculs matemàtics podria usar un caràcter com a marca de fi.
</p>

<p>
En aquest cas, l’estratègia per utilitzar és usar una estructura de repetició basada en semàfor. Aquest us indica si ja s’ha llegit la marca de fi i cal deixar d’iterar o no.
</p>

<p>
El codi següent d’exemple llegeix una seqüència de valors enters de llargària arbitrària. La lectura finalitza tan bon punt es llegeix el valor <code>-1</code>. Compareu aquest codi amb l’exemple del cas anterior.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class LectorValorsDesconeguts {</div></li><li class="li1"><div class="de1">  public static final int MARCA_FI = -1;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    System.out.print(&quot;Escriu diferents valors enters.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Després del darrer valor escriu un &quot; + MARCA_FI);</div></li><li class="li1"><div class="de1">    //Es llegeixen exactament NUM_VALORS valors.</div></li><li class="li1"><div class="de1">    boolean marcaTrobada = false;</div></li><li class="li1"><div class="de1">    while (!marcaTrobada) {</div></li><li class="li1"><div class="de1">      //Abans de llegir, comprovem si realment hi ha un enter.</div></li><li class="li1"><div class="de1">      if (lector.hasNextInt()) {</div></li><li class="li1"><div class="de1">        int valor = lector.nextInt();</div></li><li class="li1"><div class="de1">        //És la marca de fi?</div></li><li class="li1"><div class="de1">        if (valor == MARCA_FI) {</div></li><li class="li1"><div class="de1">          //Sí que ho és.</div></li><li class="li1"><div class="de1">          marcaTrobada = true;</div></li><li class="li1"><div class="de1">        } else {</div></li><li class="li1"><div class="de1">          //No. És un valor que ha de ser tractat.</div></li><li class="li1"><div class="de1">          System.out.println(&quot;Valor llegit: &quot; + valor);</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        //Si el valor no és enter, es llegeix però s'ignora.</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Els valors que sobrin a la darrera línia escrita es descarten.</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Ja s'han llegit tots els valors.&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h3><a id="arrays_completament_ocupats" >&quot;Arrays&quot; completament ocupats</a></h3>
<div class="level3">

<p>
L’esquema més simple d’emmagatzematge de dades des d’una entrada a les posicions d’un <em>array</em> és el cas en què la quantitat de dades que es llegirà és coneix prèviament. Això es deu a la important restricció que, per inicialitzar un <em>array</em>, prèviament se n’ha d’establir la mida. Aquest és un requisit indispensable, ja que en cas contrari qualsevol intent de desar-hi dades resultarà en un error d’execució. En aquest cas, n’hi ha prou d’inicialitzar l’<em>array</em> amb les seves posicions amb valor per defecte i una mida igual al nombre de dades que es llegiran. Un cop fet, només cal llegir de l’entrada un nombre de dades esperat i anar assignant els valors d’aquestes dades a cadascuna de les posicions de l’<em>array</em>, consecutivament.
</p>

<p>
Un fet que heu de tenir amb compte és que pot ser que s’indiqui que el nombre de dades per entrar és un valor, però després, per error, se’n proporcionin més. En qualsevol cas, mai no es poden llegir més dades que la capacitat real de l’<em>array</em>, per la qual cosa totes aquestes dades sobrants s’ignoraran. Un cop l’<em>array</em> està al màxim de la seva capacitat, s’ha d’acabar el procés de lectura o us exposeu a un error d’execució en sobrepassar la mida de l’<em>array</em>.
</p>

<p>

</p>

<p>
La <span class="figref"><a href="#Figure5"><span>figura</span></a></span> mostra un esquema de la lectura d’una seqüència de valors per ocupar totalment un <em>array</em>.
</p>
<div class="iocfigure"><a name="Figure5"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Esquema d’entrada de dades per crear un “array” totalment ocupat

</figcaption><img src="../media/ic10mu3_07.png" alt="" /></figure>
</div>
<p>
Com a exemple, suposeu un programa per tractar les notes d’avaluació d’un conjunt d’estudiants. Per obtenir les diferents notes, aquest llegeix una seqüència, de llargària coneguda, composta de nombres reals. Amb els valors llegits s’omple completament un <em>array</em>. Compileu i executeu el codi següent per dur a terme aquesta operació. Fixeu-vos que, en aquest cas, es comproven un seguit d’errors possibles a l’entrada de les dades abans d’emmagatzemar el valor final a l’<em>array</em>: si els valors introduïts són realment de tipus real i si estan dins del rang vàlid per a una nota (entre 0 i 10).
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">//Programa que llegeix una seqüència de valors reals, de longitud coneguda.</div></li><li class="li1"><div class="de1">public class LectorSequencia {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    //Llegeix la longitud de la seqüència. Comprova tots els errors.</div></li><li class="li1"><div class="de1">    int nombreValors = 0;</div></li><li class="li1"><div class="de1">    while (nombreValors &lt;= 0) {</div></li><li class="li1"><div class="de1">      System.out.print(&quot;Quantes notes vols introduir? &quot;);</div></li><li class="li1"><div class="de1">      if (lector.hasNextInt()) {</div></li><li class="li1"><div class="de1">        nombreValors = lector.nextInt();</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        //Si no és enter, es llegeix i s'ignora.</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Si s'han entrat més valors, s'ignoren. Només se'n necessita un.</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Es llegiran &quot; + nombreValors + &quot; valors reals.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;En pots escriure diversos en una sola línia, separats per espais.&quot;);</div></li><li class="li1"><div class="de1">    //Els desarem en un array. Ja en coneixem la mida.</div></li><li class="li1"><div class="de1">    float[] arrayNotes = new float[nombreValors];</div></li><li class="li1"><div class="de1">    //Cal llegir tants reals com la mida de l'array.</div></li><li class="li1"><div class="de1">    //Estructura de repetició amb comptador.</div></li><li class="li1"><div class="de1">    int index = 0;</div></li><li class="li1"><div class="de1">    while (index &lt; arrayNotes.length) {</div></li><li class="li1"><div class="de1">      if (lector.hasNextFloat()) {</div></li><li class="li1"><div class="de1">        //S'ha llegit una nota, però és vàlida (entre 0 i 10)?</div></li><li class="li1"><div class="de1">        float nota = lector.nextFloat();</div></li><li class="li1"><div class="de1">        if ((nota &gt;= 0)&amp;&amp;(nota &lt;= 10)) {</div></li><li class="li1"><div class="de1">          arrayNotes[index] = nota;</div></li><li class="li1"><div class="de1">          index++;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">        //Si no és vàlida, la ignorem. No s'assigna enlloc.</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        //Si no era un real, simplement llegim el valor com una cadena de text</div></li><li class="li1"><div class="de1">        //però no en fem res. Es perd.</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Ignorem els valors sobrants de la darrera línia.</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La seqüència llegida és:&quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; arrayNotes.length;i++) {</div></li><li class="li1"><div class="de1">      System.out.println(arrayNotes[i]);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h3><a id="arrays_parcialment_ocupats" >&quot;Arrays&quot; parcialment ocupats</a></h3>
<div class="level3">

<p>
Malauradament, hi ha circumstàncies sota les quals no és possible inicialitzar un <em>array</em> de manera que la seva mida s’ajusti exactament a la llargària de la seqüència de valors d’entrada. Hi ha dos motius que poden dur a aquesta situació. D’una banda, si simplement no es coneix <em>a priori</em> el nombre de dades que s’entraran, ja que en lloc del programa es pregunta prèviament, i per tant l’entrada de dades és d’una llargària desconeguda. D’altra banda, això també succeeix en llenguatges de programació en què a l’hora de declarar un <em>array</em> i inicialitzar-lo no és possible usar una variable per especificar-ne la mida, i només es pot usar un literal.
</p>

<p>
En un cas com aquest, us haureu de conformar a triar un valor concret prefixat per a la mida de l’<em>array</em> i donar per fet que el nombre de dades d’entrada que el programa pot tractar és limitat. Si per algun motiu, en llegir les dades d’entrada, se supera aquest límit, com que no és possible emmagatzemar els valors excedents, els haureu d’ignorar. Per tant, caldrà triar aquesta mida arribant a un compromís entre un valor que sigui prou gran per no trobar-vos gaire sovint amb aquesta situació, però tampoc massa exagerat, per no malbaratar memòria. Per exemple, si ja sabeu que el nombre d’estudiants en una classe pot oscil·lar, però mai no es permetrà que n’hi hagi més de 80 (en aquest cas, s’obriria una nova aula), es pot triar aquest valor com a mida de l’<em>array</em>. Cal estudiar cada cas concret.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Cada posició d’un <em>array</em> ocupa tanta memòria com el tipus primitiu que pot emmagatzemar.
</p>
</div></div><div class="iocfigure"><a name="Figure6"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Esquema d’entrada de dades que genera un “array” parcialment ocupat

</figcaption><img src="../media/ic10mu3_08.png" alt="" /></figure>
</div>
<p>
En un cas com aquest, en què es disposa d’un <em>array</em> amb una mida que mai no serà exactament igual al nombre de dades llegides des de l’entrada (de fet, normalment, serà inferior), només hi ha un rang de posicions en què hi ha dades llegides de l’entrada. La resta de posicions tenen valors per defecte que no tenen res a veure amb l’entrada, i per tant, no han de ser previstes a l’hora de fer cap tasca. La <span class="figref"><a href="#Figure6"><span>figura</span></a></span> esquematitza aquest fet partint de la seqüència d’entrada <code>2.0, 5.5, 9.0, 10</code>.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Col·loquialment, una posició en què no hi ha cap valor vàlid assignat es diu que està “buida”.
</p>
</div></div>
<p>
Un altre aspecte important és que l’atribut <code>length</code> ara no és suficient per saber el rang de les dades vàlides. Només indica la capacitat de l’<em>array</em>. Per tant, serà necessari disposar d’una variable auxiliar addicional, de tipus enter, en què s’emmagatzemi el nombre de dades que realment hi ha dins de l’<em>array</em>. Qualsevol accés a l’<em>array</em> només obtindrà dades correctes si l’índex emprat es troba entre 0 i aquest valor auxiliar − 1.
</p>

<p>
El codi següent és l’equivalent d’entrada de notes però per al cas d’una entrada de dades de llargària desconeguda. Com que no se sap quantes dades cal llegir, és necessari indicar d’alguna manera quan s’ha acabat d’entrar dades, amb una marca de final. En aquest cas, es tracta del valor <code>-1</code>. El límit de dades que és capaç d’emmagatzemar s’ha establert en 80, definit com la constant <code>MAX_VALORS</code>. 
</p>

<p>
Proveu-lo al vostre entorn de treball i estudieu-ne el funcionament.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">//Llegeix un conjunt de dades sense saber quantes són.</div></li><li class="li1"><div class="de1">public class LectorSequenciaDimDesconeguda {</div></li><li class="li1"><div class="de1">  public static final int MAX_VALORS = 80;</div></li><li class="li1"><div class="de1">  public static final int MARCA_FI = -1;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    //No se sap quantes n'entraran. Cal fitar un valor màxim. Posem 80.</div></li><li class="li1"><div class="de1">    float[] arrayNotes = new float[MAX_VALORS];</div></li><li class="li1"><div class="de1">    //Cal un comptador de posicions actuals en què hi ha valors.</div></li><li class="li1"><div class="de1">    int elements = 0;</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    System.out.print(&quot;Escriure fins a &quot; + MAX_VALORS + &quot; valors.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;En pots escriure diversos en una sola línia, separats per espais.&quot;);</div></li><li class="li1"><div class="de1">    //Caldrà alguna manera de saber que s'ha acabat d'escriure.</div></li><li class="li1"><div class="de1">    System.out.println(&quot;(Per acabar, escriu un&quot; + MARCA_FI + &quot;)&quot;);</div></li><li class="li1"><div class="de1">    //Anar llegint fins a trobar la marca de fi. Però el màxim és la mida de l'array.</div></li><li class="li1"><div class="de1">    //Si s'entren més valors, els ignorem, ja que no queda lloc on emmagatzemar-los.</div></li><li class="li1"><div class="de1">    //Estructura de repetició amb semàfor.</div></li><li class="li1"><div class="de1">    while (elements &lt; arrayNotes.length) {</div></li><li class="li1"><div class="de1">      //Hi ha un real?</div></li><li class="li1"><div class="de1">      if (lector.hasNextFloat()) {</div></li><li class="li1"><div class="de1">        //Cal veure si és un valor vàlid o final de seqüència.</div></li><li class="li1"><div class="de1">        float nota = lector.nextFloat();</div></li><li class="li1"><div class="de1">        if ((nota &gt;= 0)&amp;&amp;(nota &lt;= 10)) {</div></li><li class="li1"><div class="de1">          //Tot correcte. Ara hi ha un element més a l'array.</div></li><li class="li1"><div class="de1">          arrayNotes[elements] = nota;</div></li><li class="li1"><div class="de1">          elements++;</div></li><li class="li1"><div class="de1">        } else if (nota == MARCA_FI) {</div></li><li class="li1"><div class="de1">          //Marca de final, sortim del bucle.</div></li><li class="li1"><div class="de1">          break;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">        //Si no és ni una cosa ni l'altra, l'ignorem.</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        //Si no era un real, l'ignorem.</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Ignorem els valors sobrants de la darrera línia.</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La seqüència llegida és:&quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; elements;i++) {</div></li><li class="li1"><div class="de1">      System.out.println(arrayNotes[i]);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
A un <em>array</em> parcialment ocupat se li poden afegir noves dades posteriorment, sempre que no se superi la seva mida. Per fer-ho, aquestes s’haurien d’assignar a partir de la posició en què es troba el darrer element vàlid.
</p>

</div>

<h2><a id="esquemes_fonamentals_en_la_utilitzacio_d_arrays" >Esquemes fonamentals en la utilització d&#039;&quot;arrays&quot;</a></h2>
<div class="level2">

<p>
El potencial dels <em>arrays</em> va molt més enllà de la mera capacitat de gestionar conjunts de dades de grandària arbitrària tan sols declarant una única variable. Aquests també són una eina extremadament versàtil per processar totes les dades que contenen amb poques línies de codi de manera entenedora i eficient. El motiu principal és que les seves posicions són accessibles a partir d’índexs numèrics. Això en fa ideal el tractament usant estructures de repetició, que mitjançant un comptador accedeixin una per una a totes les posicions. 
</p>

<p>
De fet, aquesta circumstància ja ha quedat patent en l’exemple de lectura d’una seqüència de dades des del teclat i l’emmagatzemament en un <em>array</em>. Reflexioneu sobre com seria el codi sense usar una estructura de repetició o <em>arrays</em>.
</p>

<p>
Tot seguit veureu un seguit d’estratègies basades en aquesta circumstància que val la pena que tingueu presents a l’hora de treballar amb les dades contingudes dins d’un <em>array</em>. Gairebé tots els programes basats en <em>arrays</em> n’usen alguna. Per simplificar el codi dels exemples utilitzats, en lloc de partir d’una entrada per teclat es treballarà sobre un <em>array</em> inicialitzat amb valors concrets. Els algorismes no varien en absolut respecte dels <em>arrays</em> producte d’una entrada per teclat.
</p>

</div>

<h3><a id="inicialitzacio_procedural" >Inicialització procedural</a></h3>
<div class="level3">

<p>
Hi ha situacions en les quals els valors inicials dins d’alguna o totes les posicions de l’<em>array</em> no necessàriament han de dependre d’una entrada, però usar el sistema d’inicialització amb valors concrets pot ser una mica incòmode. Per exemple, suposeu que us cal disposar dels valors de les 20 primeres potències de 2. En tractar-se de bastants valors, usar un <em>array</em> és ideal. Ara bé, tot i que aquests valors es poden expressar directament com a literals, primer els hauríeu de calcular pel vostre compte i, tot seguit, inicialitzar l’<em>array</em>. A més, el resultat final és una línia força llarga dins del codi, i n’afecta la llegibilitat.
</p>

<p>
Posats a haver de calcular prèviament per la vostra banda els valors amb els quals cal inicialitzar l’<em>array</em>, surt més a compte que sigui el programa mateix qui faci aquest càlcul i inicialitzi les posicions a mesura que trobi els resultats.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
S’anomena <strong>generació procedural</strong> el fet de generar contingut algorísmicament, en lloc de fer-ho manualment partint de valors preestablerts. És un terme especialment usat dins del disseny de videojocs.
</p>
</div></div>
<p>

</p>

<p>
Com que quan es fa una inicialització d’aquest tipus el nombre de valors és conegut, es pot assignar una mida a l’<em>array</em> de manera que estigui totalment ocupat. Compileu i executeu el codi següent, que inicialitza proceduralment un <em>array</em> de manera que el valor a cada posició sigui el doble de l’anterior, partint d’una primera posició amb valor 1.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">//Un programa que inicialitza proceduralment un array amb valors relacionats entre si.</div></li><li class="li1"><div class="de1">public class InicialitzacióProcedural {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    //Caldrà emmagatzemar 20 enters.</div></li><li class="li1"><div class="de1">    int[] arrayValorsDobles = new int[20];</div></li><li class="li1"><div class="de1">    //La primera posició la posem directament.</div></li><li class="li1"><div class="de1">    arrayValorsDobles[0] = 1;</div></li><li class="li1"><div class="de1">    //La resta es va omplint seqüencialment, a força de càlculs.</div></li><li class="li1"><div class="de1">    for(int i = 1; i &lt; arrayValorsDobles.length; i++) {</div></li><li class="li1"><div class="de1">      arrayValorsDobles[i] = 2 * arrayValorsDobles[i - 1];</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">   System.out.print(&quot;S'ha generat l'array: [ &quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; arrayValorsDobles.length; i++) {</div></li><li class="li1"><div class="de1">      System.out.print(arrayValorsDobles[i] + &quot; &quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.print(&quot;]&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Per estudiar el funcionament del programa de manera més detallada, resulta útil usar una taula que indiqui l’evolució de les variables a cada iteració, tal com fa la <span class="tabref"><a href="#Table2"><span>taula</span></a></span>.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table2"><span>Taula: </span></a>Evolució del bucle per inicialitzar un “array” amb potències de 2</div>
<div class="table"><table class="inline">
	<tr class="row0">
		<th class="col0">Iteració </th><th class="col1" colspan="2">Inici del bucle </th><th class="col3" colspan="2">Fi del bucle </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign">  </td><td class="col1"> <strong>‘i’ val</strong> </td><td class="col2"> <strong>Condició val</strong></td><td class="col3"> <strong>Posició modificada</strong></td><td class="col4"> <strong>Valor assignat</strong></td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> 1 </td><td class="col2"> (1 &lt; 20), <code>true</code></td><td class="col3"> arrayValorsDobles[1] </td><td class="col4"> 2*arrayValorsDobles[0], 2 * 1 = 2 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> 2 </td><td class="col2"> (2 &lt; 20), <code>true</code></td><td class="col3"> arrayValorsDobles[2] </td><td class="col4"> 2*arrayValorsDobles[1], 2 * 2 = 4 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> 3 </td><td class="col2"> (3 &lt; 20), <code>true</code></td><td class="col3"> arrayValorsDobles[3] </td><td class="col4"> 2*arrayValorsDobles[2], 2 * 4 = 8 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> 4 </td><td class="col2"> (4 &lt; 20), <code>true</code></td><td class="col3"> arrayValorsDobles[4] </td><td class="col4"> 2*arrayValorsDobles[3], 2 * 8 = 16 </td>
	</tr>
	<tr class="row6">
		<td class="col0" colspan="5">…</td>
	</tr>
	<tr class="row7">
		<td class="col0"> 18 </td><td class="col1"> 19 </td><td class="col2"> (19 &lt; 20), <code>true</code></td><td class="col3"> arrayValorsDobles[19] </td><td class="col4"> 2*arrayValorsDobles[18], 2*262144 = 524288 </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 19 </td><td class="col1"> 20 </td><td class="col2"> (20 &lt; 20), <code>false</code></td><td class="col3" colspan="2"> Ja hem sortit del bucle </td>
	</tr>
</table></div>
</div>
<p>
<strong>Repte 1:</strong> feu un programa que inicialitzi proceduralment un <em>array</em> amb els 100 primers nombres parells (Nota: el 0 és parell).
</p>

</div>

<h3><a id="recorregut" >Recorregut</a></h3>
<div class="level3">

<p>
Quan treballeu amb <em>arrays</em>, molt sovint haureu de fer càlculs en què estan implicats tots els valors emmagatzemats o, si més no, una bona part. En aquest cas, cal fer-ne un recorregut seqüencial de les posicions i anar-les processant per obtenir un resultat final. Un exemple d’una situació com aquesta pot ser calcular la mitjana aritmètica d’un seguit de notes, que requereix sumar els valors de totes i cadascuna i dividir el resultat entre el seu nombre. 
</p>

<p>
El cas d’un <em>array</em> totalment ocupat és el més senzill, ja que és suficient recórrer l’<em>array</em> en tota la seva extensió fins arribar al final de l’extensió, donada per la mida.
</p>
<div class="ioctext"><div class="ioccontent"><p class="ioctitle">Recorregut</p>
<p>
Parlem de recorregut quan cal tractar <strong>tots</strong> els valors de l’<em>array</em>.
</p>
</div></div>
<p>
Com a exemple, executeu el codi següent, que calcula la mitjana aritmètica d’un seguit de notes, expressades com a valors reals, contingudes dins d’un <em>array</em>.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">//Un programa que fa un recorregut d'un array: càlcul de la mitjana aritmètica.</div></li><li class="li1"><div class="de1">public class RecorregutTotalmentOcupat {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    //Es parteix d'un array que conté tots els valors.</div></li><li class="li1"><div class="de1">    float[] arrayNotes =  {2f, 5.5f, 9f, 10f, 4.9f, 8f, 8.5f, 7f, 6.6f, 5f, 9f, 7f};</div></li><li class="li1"><div class="de1">    //Acumulador de la suma de valors.</div></li><li class="li1"><div class="de1">    float acumulat = 0;</div></li><li class="li1"><div class="de1">    //Cal recórrer tot l'array d'extrem a extrem.</div></li><li class="li1"><div class="de1">    for(int i = 0; i &lt; arrayNotes.length; i++) {</div></li><li class="li1"><div class="de1">      acumulat = acumulat + arrayNotes[i];</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    float resultat = acumulat / arrayNotes.length;</div></li><li class="li1"><div class="de1">    System.out.println(&quot;El resultat és &quot; + resultat);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
A la <span class="tabref"><a href="#Table3"><span>taula</span></a></span>, mitjançant l’estudi de l’evolució del bucle, es pot veure com es van recorrent una per una totes les posicions de l’<em>array</em>.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table3"><span>Taula: </span></a>Evolució del bucle per recórrer l’array i calcular la suma de tots els valors</div>
<div class="table"><table class="inline">
	<tr class="row0">
		<th class="col0"> Iteració </th><th class="col1 leftalign" colspan="2"> Inici del bucle                   </th><th class="col3 leftalign" colspan="2"> Fi del bucle                             </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign">          </td><td class="col1"> <strong>‘i’ val</strong> </td><td class="col2 leftalign"> <strong>Condició val</strong>     </td><td class="col3"> <strong>Posició accedida</strong> </td><td class="col4"> <strong>‘acumulat’ val</strong> </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> 1        </td><td class="col1 leftalign"> 0           </td><td class="col2 leftalign"> (0 &lt; 12), <code>true</code>   </td><td class="col3 leftalign"> arrayNotes[0], 2.0   </td><td class="col4 leftalign"> 0 + 2.0 = 2.0      </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> 2        </td><td class="col1 leftalign"> 1           </td><td class="col2 leftalign"> (3 &lt; 12), <code>true</code>   </td><td class="col3 leftalign"> arrayNotes[1], 5.5   </td><td class="col4 leftalign"> 2.0 + 5.5 = 7.5    </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> 3        </td><td class="col1 leftalign"> 2           </td><td class="col2 leftalign"> (4 &lt; 12), <code>true</code>   </td><td class="col3 leftalign"> arrayNotes[2], 9.0   </td><td class="col4 leftalign"> 7.5 + 9.0 = 16.5   </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign" colspan="5"> …                                                                                   </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> 12       </td><td class="col1 leftalign"> 11          </td><td class="col2 leftalign"> (11 &lt; 12), <code>true</code>  </td><td class="col3 leftalign"> arrayNotes[11], 7.0  </td><td class="col4 leftalign"> 75.5 + 7.0 = 82.5  </td>
	</tr>
	<tr class="row7">
		<td class="col0 leftalign"> 13       </td><td class="col1 leftalign"> 12          </td><td class="col2"> (12 &lt; 12), <code>false</code> </td><td class="col3 leftalign" colspan="2"> Ja hem sortit del bucle                  </td>
	</tr>
</table></div>
</div>
<p>
En el cas d’un <em>array</em> parcialment ocupat cal anar amb compte, ja que el recorregut no necessàriament ha de ser fins a la darrera posició, sinó fins a la darrera posició ocupada. L’algorisme de recorregut a escala general serà el mateix, però la condició de sortida del bucle canviarà. Per exemple, si el nombre de valors en l’<em>array</em> es troba en la variable <code>darreraPosicio</code>, el codi seria: 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">//Només es tracten els valors realment vàlids.</div></li><li class="li1"><div class="de1">for(int i = 0; i &lt; darreraPosicio; i++) {</div></li><li class="li1"><div class="de1">...</div></li></ol></pre>

<p>
<strong>Repte 2:</strong> modifiqueu el codi del recorregut perquè, en lloc de la mitjana, calculi quina és la nota màxima.
</p>

</div>

<h3><a id="cerca" >Cerca</a></h3>
<div class="level3">

<p>
Una altra tasca que sovint es fa en treballar amb <em>arrays</em> és cercar valors concrets dins seu. Per això, cal anar mirant totes les posicions fins a trobar-lo. Per exemple, veure si entre un seguit de notes algú ha estat capaç de treure un 10. 
</p>
<div class="ioctext"><div class="ioccontent"><p class="ioctitle">Cerca</p>
<p>
Parlem de cerca quan només cal tractar els valors de l’<em>array</em> <strong>fins a trobar</strong> l’objectiu.
</p>
</div></div>
<p>
Fins a cert punt, es pot considerar que una cerca no és més que un tipus especial de recorregut. En aquest cas, l’èmfasi es fa en la circumstància que no sempre cal recórrer tots els elements de l’<em>array</em>, només fins a trobar el valor que busquem. De fet, arribar al final de l’<em>array</em> és el que indica que no s’ha trobat el valor cercat.
</p>

<p>
Executeu el codi següent, que fa la cerca d’algun valor igual a 10 entre un seguit de notes. Fixeu-vos que en aquest codi se surt del bucle tan bon punt es troba el valor que busquem. Ja no cal seguir iterant. Tal com es presenta aquest codi, el 10 es troba a la quarta iteració. Podeu veure què passa si no se’n troba cap si abans de compilar modifiqueu manualment quest valor per un altre en la inicialització de l’<em>array</em>.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">//Un programa per veure si algú ha tret un 10.</div></li><li class="li1"><div class="de1">public class Cerca {</div></li><li class="li1"><div class="de1">  public static void main(String args[]) {</div></li><li class="li1"><div class="de1">    //Es parteix d'un array que conté tots els seus valors.</div></li><li class="li1"><div class="de1">    float[] arrayNotes =  {2f, 5.5f, 9f, 10f, 4.9f, 8f, 8.5f, 7f, 6.6f, 5f, 9f, 7f};</div></li><li class="li1"><div class="de1">    //Semàfor. S'ha trobat?</div></li><li class="li1"><div class="de1">    boolean trobat = false;</div></li><li class="li1"><div class="de1">    //Comptador de posicions.</div></li><li class="li1"><div class="de1">    int i = 0;</div></li><li class="li1"><div class="de1">    //Es va mirant cada posició, mentre no s'arriba al final i no es trobi un 10.</div></li><li class="li1"><div class="de1">    while ((i &lt; arrayNotes.length)&amp;&amp;(!trobat)) {</div></li><li class="li1"><div class="de1">      if (arrayNotes[i] == 10) {</div></li><li class="li1"><div class="de1">        trobat = true;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      i = i + 1;</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //S'ha trobat?</div></li><li class="li1"><div class="de1">    if (trobat) {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Algú ha tret un 10.&quot;);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Ningú no ha tret un 10&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Un cop més, una taula per veure l’evolució del bucle us pot ajudar a veure com, tan bon punt es troba el valor cercat, les iteracions acaben immediatament. Com es pot veure a la <span class="tabref"><a href="#Table4"><span>taula</span></a></span>, no cal recórrer tot l’<em>array</em>. A la darrera iteració se subratlla la part de l’expressió que causa que avaluï a <code>false</code>.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table4"><span>Taula: </span></a>Evolució del bucle per recórrer l’array i calcular la suma de tots els valors</div>
<div class="table"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign" colspan="2"> Iteració       </th><th class="col2 leftalign" colspan="2"> Inici del bucle                                    </th><th class="col4 leftalign" colspan="2"> Fi del bucle                           </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign">   </td><td class="col1"> <strong>‘i’ val</strong> </td><td class="col2"> <strong>‘trobat’ val</strong> </td><td class="col3 leftalign"> <strong>Condició val</strong>                 </td><td class="col4"> <strong>Posició accedida</strong> </td><td class="col5"> <strong>‘trobat’ val</strong> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1 leftalign"> 0           </td><td class="col2 leftalign"> <code>false</code>        </td><td class="col3 leftalign"> (0 &lt; 12)&amp;&amp;(!false), <code>true</code>     </td><td class="col4 leftalign"> arrayNotes[0], 2.0   </td><td class="col5 leftalign"> <code>false</code>        </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1 leftalign"> 1           </td><td class="col2 leftalign"> <code>false</code>        </td><td class="col3 leftalign"> (1 &lt; 12)&amp;&amp;(!false), <code>true</code>     </td><td class="col4 leftalign"> arrayNotes[1], 5.5   </td><td class="col5 leftalign"> <code>false</code>        </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1 leftalign"> 2           </td><td class="col2 leftalign"> <code>false</code>        </td><td class="col3 leftalign"> (2 &lt; 12)&amp;&amp;(!false), <code>true</code>     </td><td class="col4 leftalign"> arrayNotes[2], 9.0   </td><td class="col5 leftalign"> <code>false</code>        </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1 leftalign"> 3           </td><td class="col2 leftalign"> <code>false</code>        </td><td class="col3 leftalign"> (3 &lt; 12)&amp;&amp;(!false), <code>true</code>     </td><td class="col4 leftalign"> arrayNotes[3], 10.0  </td><td class="col5 leftalign"> <code>true</code>         </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 5 </td><td class="col1 leftalign"> 4           </td><td class="col2 leftalign"> <code>true</code>         </td><td class="col3"> (4 &lt; 12)&amp;&amp;<em class="u">(!true)</em>, <code>false</code> </td><td class="col4 leftalign" colspan="2"> Ja hem sortit del bucle                </td>
	</tr>
</table></div>
</div>
<p>
<strong>Repte 3:</strong> modifiqueu el codi de l’exemple per poder veure si hi ha algú que ha suspès l’assignatura o no. Feu-ho usant la sentència <code>break</code>.
</p>

<p>
Si bé fins al moment els esquemes d’ús d’<em>arrays</em> s’han centrat en valors numèrics, també són aplicables a altres tipus primitius com els caràcters. Saber aplicar-los sobre conjunts de caràcters és especialment interessant per entendre les estratègies per tractar text. A títol il·lustratiu, tot seguit es mostra un exemple  d’<em>array</em> basat en la cerca d’un caràcter concret. Observeu com el codi relatiu a la cerca, a grans trets, és idèntic al relatiu a valors numèrics. Només varia en els petits detalls relatius al tipus de dada que conté l’<em>array</em>.
</p>

<p>

</p>
<pre class="code java"><ol><li class="li1"><div class="de1">//Cerca si hi ha la lletra 'w' entre un seguit de caràcters.</div></li><li class="li1"><div class="de1">public class CercaCaracter {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    //Es parteix d'un array que conté un seguit de caràcters.</div></li><li class="li1"><div class="de1">    char[] arrayNotes =  {'a', 'z', 'g', 'd', 'w', 'o', 'h', 'e', 'x', 's'};</div></li><li class="li1"><div class="de1">    //Semàfor. S'ha trobat?</div></li><li class="li1"><div class="de1">    boolean trobat = false;</div></li><li class="li1"><div class="de1">    //Comptador de posicions.</div></li><li class="li1"><div class="de1">    int i = 0;</div></li><li class="li1"><div class="de1">    //Es va mirant cada posició, mentre no s'arriba al final i no es trobi una &quot;w&quot;.</div></li><li class="li1"><div class="de1">    while ((i &lt; arrayNotes.length)&amp;&amp;(!trobat)) {</div></li><li class="li1"><div class="de1">      if (arrayNotes[i] == 'w') {</div></li><li class="li1"><div class="de1">        trobat = true;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      i = i + 1;</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //S'ha trobat?</div></li><li class="li1"><div class="de1">    if (trobat) {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;La lletra 'w' és a la llista.&quot;);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;La lletra 'w' no és a la llista.&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h3><a id="us_d_arrays_auxiliars" >Ús d&#039;&quot;arrays&quot; auxiliars</a></h3>
<div class="level3">

<p>
La utilització d’un <em>array</em> dins del codi d’un programa pot anar més enllà d’emmagatzemar seqüències de dades de longitud arbitrària obtingudes des d’una entrada. També són útils com a manera senzilla de gestionar molts valors diferents amb un únic identificador, en lloc d’haver de declarar diverses variables. Aquesta via és especialment útil per a casos en què cal gestionar dades que tenen un cert vincle entre elles. Una altra utilitat dels <em>arrays</em> es pot extreure de la seva capacitat d’accedir a les seves posicions usant un índex per simplificar el codi.
</p>

<p>
Per exemple, suposeu que voleu fer un programa que, a partir de les notes dels estudiants d’una aula, generi un gràfic de barres (o histograma) en què s’indiqui el nombre d’estudiants que han tret suspès, aprovat, notable o excel·lent. Per poder dur a terme aquesta tasca, us caldrà disposar d’un seguit de comptadors, un per a cada categoria de nota, i fer un recorregut de totes les notes. Segons el rang al qual pertanyi cada nota, s’incrementarà un comptador o un altre.
</p>

<p>
Tot seguit teniu el codi del programa que fa aquesta tasca usant un <em>array</em>, en lloc de quatre variables diferents. Compileu i proveu que funciona. En aquest cas, l’<em>array</em> de notes ja està donat directament, però podríeu adaptar el codi de manera que llegís els valors pel teclat.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class Histograma {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    float[] arrayNotes =  {2f, 5f, 9f, 6.5f, 10f, 4.5f, 8.5f, 7f, 6f, 7.5f, 9f, 7f};</div></li><li class="li1"><div class="de1">    //Inicialització dels 10 comptadors, per a cada barra del gràfic.</div></li><li class="li1"><div class="de1">    int[] barres = new int[4];</div></li><li class="li1"><div class="de1">    //Càlcul dels comptadors. Es fa un recorregut de les notes.</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; arrayNotes.length; i++) {</div></li><li class="li1"><div class="de1">      //A quin rang pertany?</div></li><li class="li1"><div class="de1">      if ((arrayNotes[i] &gt;=0 )&amp;&amp;(arrayNotes[i] &lt; 5)) {</div></li><li class="li1"><div class="de1">        barres[0]++;</div></li><li class="li1"><div class="de1">      } else if (arrayNotes[i] &lt; 6.5) {</div></li><li class="li1"><div class="de1">        barres[1]++;</div></li><li class="li1"><div class="de1">      } else if (arrayNotes[i] &lt; 9) {</div></li><li class="li1"><div class="de1">        barres[2]++;</div></li><li class="li1"><div class="de1">      } else if (arrayNotes[i] &lt;= 10) {</div></li><li class="li1"><div class="de1">        barres[3]++;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Si no pertany a cap rang, nota incorrecta. La ignorem.</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Gràfic de barres de les notes&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;-----------------------------&quot;);</div></li><li class="li1"><div class="de1">    //S'imprimeix el gràfic.</div></li><li class="li1"><div class="de1">    //Anem recorrent els comptadors i imprimim el valor en estrelles.</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; barres.length; i++) {</div></li><li class="li1"><div class="de1">      //Aprofitem l'índex per saber quin títol cal escriure a la barra actual.</div></li><li class="li1"><div class="de1">      switch(i) {</div></li><li class="li1"><div class="de1">        case 0:</div></li><li class="li1"><div class="de1">          System.out.print(&quot;Suspès:     &quot;);</div></li><li class="li1"><div class="de1">          break;</div></li><li class="li1"><div class="de1">        case 1:</div></li><li class="li1"><div class="de1">          System.out.print(&quot;Aprovat:    &quot;);</div></li><li class="li1"><div class="de1">          break;</div></li><li class="li1"><div class="de1">        case 2:</div></li><li class="li1"><div class="de1">          System.out.print(&quot;Notable:    &quot;);</div></li><li class="li1"><div class="de1">          break;</div></li><li class="li1"><div class="de1">        case 3:</div></li><li class="li1"><div class="de1">          System.out.print(&quot;Excel·lent: &quot;);</div></li><li class="li1"><div class="de1">          break;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Imprimim tantes estrelles com el valor del comptador.</div></li><li class="li1"><div class="de1">      for (int j = 0; j &lt; barres[i]; j++) {</div></li><li class="li1"><div class="de1">        System.out.print(&quot;*&quot;);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      System.out.println();</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
En aquest cas, la granularitat del gràfic és baixa, i per això es podria fer amb quatre variables diferents sense problemes. Ara bé, hi ha una part del programa en què disposar d’un accés als quatre valors per índex resulta de gran utilitat per simplificar el codi: en escriure el gràfic per pantalla. Si s’usessin quatre variables, el codi per imprimir el gràfic seria:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">    ...</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Gràfic de barres de les notes&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;-----------------------------&quot;);</div></li><li class="li1"><div class="de1">    //S'imprimeix el gràfic.</div></li><li class="li1"><div class="de1">    //Primer els suspesos.</div></li><li class="li1"><div class="de1">    System.out.print(&quot;Suspès:     &quot;);</div></li><li class="li1"><div class="de1">    for (int j = 0; j &lt; comptadorSuspes; j++) {</div></li><li class="li1"><div class="de1">      System.out.print(&quot;*&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println();</div></li><li class="li1"><div class="de1">    //Ara els aprovats.</div></li><li class="li1"><div class="de1">    System.out.print(&quot;Aprovat:    &quot;);</div></li><li class="li1"><div class="de1">    for (int j = 0; j &lt; comptadorAprovats; j++) {</div></li><li class="li1"><div class="de1">      System.out.print(&quot;*&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println();</div></li><li class="li1"><div class="de1">    //Ara els notables.</div></li><li class="li1"><div class="de1">    System.out.print(&quot;Notable:    &quot;);</div></li><li class="li1"><div class="de1">    for (int j = 0; j &lt; comptadorNotable; j++) {</div></li><li class="li1"><div class="de1">      System.out.print(&quot;*&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println();</div></li><li class="li1"><div class="de1">    //Ara els excel·lents.</div></li><li class="li1"><div class="de1">    System.out.print(&quot;Excel·lent: &quot;);</div></li><li class="li1"><div class="de1">    for (int j = 0; j &lt; comptadorExcellent; j++) {</div></li><li class="li1"><div class="de1">      System.out.print(&quot;*&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println();</div></li><li class="li1"><div class="de1">    ...</div></li></ol></pre>

<p>
Per escriure el resultat final en forma de gràfic cal escriure tantes estrelles com val cada comptador individual. Si s’usen quatre variables separades, caldria repetir el mateix codi per a cada variable. Usant un <em>array</em>, n’hi ha prou d’usar una estructura de repetició i fer un recorregut. A més a més, el valor de l’índex al qual s’està accedint també serveix per saber quin comptador s’està tractant i, per tant, quin títol cal escriure per a cada iteració. Ara imagineu que es vol modificar el programa per comptar la gent que ha tret notes dins de rangs amb més granularitat (0-1, 1-2, …, 9-10).
</p>

<p>
Per tant, aquest és un exemple de cas en què usar <em>arrays</em> auxiliars pot ser de gran utilitat per no haver de repetir el codi.
</p>

</div>

<h3><a id="copia" >Còpia</a></h3>
<div class="level3">

<p>
Com s’ha dit, el tipus de dada <em>array</em>, al contrari que els tipus de dades primitius, no té cap operació disponible. Només es pot operar en les posicions individuals. El que sí que està permès és fer assignacions usant directament les identificadors de les variables de tipus <em>array</em>. Ara bé, un fet certament curiós és que l’assignació no crea una còpia de les dades de l’<em>array</em> original, sinó que el que fa és configurar l’identificador de destinació perquè, a partir de llavors, per mitjà d’aquest s’accedeixi a <strong>les mateixes dades</strong> en memòria que l’identificador origen.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
La no-creació d’una còpia real en dur a terme una assignació, sinó dues vies d’accés a una mateixa dada, és un tret comú a tots els tipus de dades compostos.
</p>
</div></div>
<p>
La millor manera de veure la diferència de comportament entre una assignació entre tipus de dades primitius i els <em>arrays</em> és amb un exemple de codi. 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">  //Assignació amb tipus primitius:</div></li><li class="li1"><div class="de1">  int i = 0;</div></li><li class="li1"><div class="de1">  int j = 5;</div></li><li class="li1"><div class="de1">  //A la variable &quot;i&quot; se li assigna el valor de &quot;j&quot;.</div></li><li class="li1"><div class="de1">  i = j;</div></li><li class="li1"><div class="de1">  //Es modifica el valor de &quot;j&quot;.</div></li><li class="li1"><div class="de1">  j = 10;</div></li><li class="li1"><div class="de1">  //&quot;i&quot; conserva el valor copiat des de &quot;j&quot;, 5.</div></li><li class="li1"><div class="de1">  System.out.println(i);</div></li><li class="li1"><div class="de1">  ...</div></li></ol></pre>
<pre class="code java"><ol><li class="li1"><div class="de1">  ...</div></li><li class="li1"><div class="de1">  //Assignació amb arrays:</div></li><li class="li1"><div class="de1">  int[] arrayA = {10, 20, 30, 40, 50};</div></li><li class="li1"><div class="de1">  int[] arrayB = {60, 70, 80, 90, 100};</div></li><li class="li1"><div class="de1">  //A la variable &quot;arrayA&quot; se li assigna el valor d'&quot;arrayB&quot;.</div></li><li class="li1"><div class="de1">  arrayA = arrayB;</div></li><li class="li1"><div class="de1">  //Es modifica el valor de l'índex 2 només d'&quot;arrayB&quot;.</div></li><li class="li1"><div class="de1">  arrayB[2] = 60;</div></li><li class="li1"><div class="de1">  //&quot;arrayA&quot; també ha vist modificat el seu valor a l'índex 2!</div></li><li class="li1"><div class="de1">  System.out.println(arrayA[2]);</div></li><li class="li1"><div class="de1">  //Es modifica el valor de l'índex 4 només d'&quot;arrayA&quot;.</div></li><li class="li1"><div class="de1">  arrayA[4] = 70;</div></li><li class="li1"><div class="de1">  //&quot;arrayB&quot; també ha vist modificat el seu valor a l'índex 4!</div></li><li class="li1"><div class="de1">  System.out.println(arrayB[4]);</div></li><li class="li1"><div class="de1">  //De fet, &quot;a&quot; i &quot;b&quot; accedeixen exactament a les mateixes dades.</div></li><li class="li1"><div class="de1">  ...</div></li></ol></pre>

<p>
Una pregunta que pot sorgir ara és: què ha passat amb les dades que hi havia inicialment a la variable “arrayB”? La resposta és que s’han perdut. Ja no hi ha manera d’accedir-hi. En el cas del Java, això no és cap inconvenient, ja que quan unes dades deixen d’estar accessibles, s’esborren de la memòria i el seu espai passa a estar disponible per a altres aplicacions. En altres llenguatges, les implicacions poden ser diferents, o fins i tot es considera un error greu de programació.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
En fer assignacions entre variables de tipus <em>array</em>, l’origen i destinació ni tan sols han de tenir la mateixa mida.
</p>
</div></div>
<p>
Tenint en compte el comportament de l’assignació, per generar una còpia independent d’un <em>array</em> cal tractar les posicions com a elements individuals, com passava amb la resta d’operacions.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">//Un programa que crea una còpia idèntica, i independent, d'un altre array.</div></li><li class="li1"><div class="de1">public class Copia {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    float[] llistaNotes = {2f, 5.5f, 9f, 10f, 4.9f, 8f, 8.5f, 7f, 6.6f, 5f, 9f, 7f};</div></li><li class="li1"><div class="de1">    //La còpia ha de tenir la mateixa mida que l'original.</div></li><li class="li1"><div class="de1">    float[] copiaLlistaNotes = new float[llistaNotes.length];</div></li><li class="li1"><div class="de1">    //Anem copiant posició per posició.</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaNotes.length; i++) {</div></li><li class="li1"><div class="de1">      copiaLlistaNotes[i] = llistaNotes[i];</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Mostrem la còpia per pantalla.</div></li><li class="li1"><div class="de1">    System.out.print(&quot;L'array copiat és: [ &quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaNotes.length;i++) {</div></li><li class="li1"><div class="de1">      System.out.print(copiaLlistaNotes[i] + &quot; &quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println(&quot;]&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h3><a id="canvi_de_mida" >Canvi de mida</a></h3>
<div class="level3">

<p>
Un cop us heu decidit per un valor concret per a la mida d’un <em>array</em>, ja no hi ha volta enrere. No es pot canviar. Això té certs inconvenients, ja que pot passar que, en determinades condicions, us quedeu sense espai per poder emmagatzemar dades. Però si bé no és possible canviar la mida d’un <em>array</em>, aquest problema no és irresoluble. Només cal seguir les passes següents:
</p>
<ol>
<li class="level1"><div class="li"> Generar un nou <em>array</em> en una variable diferent, amb una mida superior a l’original.</div>
</li>
<li class="level1"><div class="li"> Copiar-hi les dades de l’<em>array</em> original en el mateix ordre. En fer-ho, el nou <em>array</em> quedarà amb posicions “buides”.</div>
</li>
<li class="level1"><div class="li"> Aprofitant les propietats de l’assignació entre <em>arrays</em>, s’assigna el nou <em>array</em> a l’<em>array</em> original.</div>
</li>
<li class="level1"><div class="li"> Finalment, afegir al nou <em>array</em> els valors extra que ja no cabien en l’original.</div>
</li>
</ol>

<p>
Arribats a aquest punt, és com si a efectes pràctics s’hagués fet més gran l’<em>array</em> original. El codi següent mostra un exemple d’aquest esquema.
</p>

<p>
Un exemple de bocí de codi que fa aquestes accions seria el que es mostra a continuació. En aquest, la mida de l’<em>array</em> original s’incrementa de manera que s’hi afegeixen <code>MAX_VALORS</code>, noves posicions.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">float[] arrayNotes = new float[...];</div></li><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">//PAS 1</div></li><li class="li1"><div class="de1">float[] arrayNou = new float[arrayNotes.length + MAX_VALORS];</div></li><li class="li1"><div class="de1">//PAS 2</div></li><li class="li1"><div class="de1">for (int i = 0; i &lt; arrayNotes.length; i++) {</div></li><li class="li1"><div class="de1"> arrayNou[i] = arrayNotes[i];</div></li><li class="li1"><div class="de1">}</div></li><li class="li1"><div class="de1">//PAS 3</div></li><li class="li1"><div class="de1">arrayNotes = arrayNou;</div></li><li class="li1"><div class="de1">//Ara ja es poden desar MAX_VALORS nous valors extra dins d'''arrayNotes''</div></li><li class="li1"><div class="de1">...</div></li></ol></pre>

<p>
El codi següent adapta la lectura per teclat d’una seqüència de llargària desconeguda de manera que, si se supera la capacitat de l’<em>array</em> en què s’emmagatzemen els valors, la seva mida s’incrementa per poder encabir-ne de nous. Compileu-lo i executeu-lo per veure com funciona.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">public class CanviMida {</div></li><li class="li1"><div class="de1">  public static final int MAX_VALORS = 5;</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    //D'entrada, la mida serà 5.</div></li><li class="li1"><div class="de1">    //S'escull un valor molt baix perquè de seguida es forci el canvi de mida.</div></li><li class="li1"><div class="de1">    float[] arrayNotes = new float[MAX_VALORS];</div></li><li class="li1"><div class="de1">    //Cal un comptador de posicions en què hi ha valors vàlids.</div></li><li class="li1"><div class="de1">    int elements = 0;</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    System.out.print(&quot;Vés escrivint notes (valors reals entre 0 i 10).&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;En pots escriure diversos en una sola línia, separats per espais.&quot;);</div></li><li class="li1"><div class="de1">    //Caldrà alguna manera de saber que s'ha acabat d'escriure.</div></li><li class="li1"><div class="de1">    System.out.println(&quot;(Per acabar, escriu un -1)&quot;);</div></li><li class="li1"><div class="de1">    //Anar llegint fins a trobar la marca de fi. Però el màxim és la mida de l'array.</div></li><li class="li1"><div class="de1">    //Si s'entren més valors, canviem la mida de l'array i continuem llegint.</div></li><li class="li1"><div class="de1">    //Estructura de repetició amb semàfor.</div></li><li class="li1"><div class="de1">    boolean marcaFi = false;</div></li><li class="li1"><div class="de1">    while (!marcaFi) {</div></li><li class="li1"><div class="de1">      //Hi ha un real?</div></li><li class="li1"><div class="de1">      if (lector.hasNextFloat()) {</div></li><li class="li1"><div class="de1">        //Cal veure si és un valor vàlid o final de seqüència.</div></li><li class="li1"><div class="de1">        float nota = lector.nextFloat();</div></li><li class="li1"><div class="de1">        if ((nota &gt;= 0)&amp;&amp;(nota &lt;= 10)) {</div></li><li class="li1"><div class="de1">          //Tot correcte. Però hi ha lloc a l'array?</div></li><li class="li1"><div class="de1">          if (elements == arrayNotes.length) {</div></li><li class="li1"><div class="de1">            //Cal canviar la mida de l'array. Es fa 5 posicions més llarg.</div></li><li class="li1"><div class="de1">            //Per veure quan succeeix, avisem per pantalla.</div></li><li class="li1"><div class="de1">            System.out.println(&quot;Capacitat superada. Afegim &quot; + MAX_VALORS + &quot; posicions...&quot;);</div></li><li class="li1"><div class="de1">            float[] arrayNou = new float[arrayNotes.length + MAX_VALORS];</div></li><li class="li1"><div class="de1">            for (int i = 0; i &lt; arrayNotes.length; i++) {</div></li><li class="li1"><div class="de1">              arrayNou[i] = arrayNotes[i];</div></li><li class="li1"><div class="de1">            }</div></li><li class="li1"><div class="de1">            arrayNotes = arrayNou;</div></li><li class="li1"><div class="de1">          }</div></li><li class="li1"><div class="de1">          //Afegim el nou valor. Segur que hi ha lloc.</div></li><li class="li1"><div class="de1">          arrayNotes[elements] = nota;</div></li><li class="li1"><div class="de1">          elements++;</div></li><li class="li1"><div class="de1">        } else if (nota == -1) {</div></li><li class="li1"><div class="de1">          //Marca de final, sortim del bucle.</div></li><li class="li1"><div class="de1">          break;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">        //Si no és ni una cosa ni l'altra, ho ignorem.</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        //Si no era un real, l'ignorem.</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Ignorem els valors sobrants de la darrera línia.</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">    System.out.println(&quot;A l'array hi ha emmagatzemats &quot; + elements + &quot; elements: &quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; elements;i++) {</div></li><li class="li1"><div class="de1">      System.out.println(arrayNotes[i]);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Cal dir que fer aquest tipus de tasca és especialment ineficient i té un impacte sobre el rendiment del programa. És millor només usar aquest esquema si realment no hi ha més remei. Si es fa, normalment, a l’hora de triar la mida del nou <em>array</em> és millor no ajustar massa i deixar espai de sobres per omplir noves posicions si és necessari sense haver-vos de veure forçats a repetir aquest procés constantment.
</p>

</div>

<h3><a id="ordenacio" >Ordenació</a></h3>
<div class="level3">

<p>
Hi ha vegades en què resulta molt útil reorganitzar els valors que hi ha dins l’<em>array</em> de manera que estiguin ordenats de manera ascendent o descendent. En molts casos, mostrar les dades de manera ordenada és simplement un requisit de l’aplicació, de manera que l’usuari les pugui visualitzar i extreure’n conclusions de manera més còmoda. Però hi ha casos en què disposar de les dades ordenades facilita la codificació del programa i l’eficiència. 
</p>

<p>
Per exemple, en aquest mateix apartat heu vist com cercar, a partir d’un seguit de notes, si algun estudiant ha tret un 10. Per fer aquesta tasca, calia una estructura de repetició i anar mirant un per un tots els valors dins l’<em>array</em>. Però si les dades estan ordenades en ordre ascendent, llavors podem usar una estratègia més eficaç. Si algú té un 10, aquesta nota estarà per força a la darrera posició. Per tant, tota la cerca queda reduïda directament al codi:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">if (arrayNotes[arrayNotes.length - 1] == 10) {</div></li><li class="li1"><div class="de1">  System.out.println(&quot;Algú ha tret un 10.&quot;);</div></li><li class="li1"><div class="de1">} else {</div></li><li class="li1"><div class="de1">  System.out.println(&quot;Ningú no ha tret un 10&quot;);</div></li><li class="li1"><div class="de1">}</div></li><li class="li1"><div class="de1">...</div></li></ol></pre>

<p>
De cop i volta el codi es fa més ràpid i curt, ja que no cal l’estructura de repetició. En general, les dades ordenades resulten d’utilitat a l’hora de fer cerques o recorreguts en què les dades per tractar tenen un rang o un valor concret, ja que permeten establir estratègies que minimitzin els nombre d’iteracions dels bucles.
</p>

<p>
Per ordenar una seqüència de valors hi ha diversos algorismes. Els més eficients són força complexos i es troben més enllà dels objectius d’aquest mòdul. N’hi ha prou de veure’n un de més senzill.
</p>
<div class="iocnote"><div class="ioccontent">
<p>
L’algorisme d’ordenació més ràpid i eficient que hi ha és el <a href="http://ca.wikipedia.org/wiki/Quicksort" class="urlextern" title="http://ca.wikipedia.org/wiki/Quicksort"  rel="nofollow">QuickSort</a>.
</p>
</div></div><div class="iocimportant"><div class="ioccontent">
<p>
L’<strong>algorisme de la bombolla</strong> (<em>BubbleSort</em>) serveix per ordenar elements mitjançant recorreguts successius al llarg de la seqüència, en què es van comparant parelles de valors. Cada cop que es troben dues parelles en ordre incorrecte, s’intercanvia la seva posició.
</p>
</div></div>
<p>
Bàsicament, el que es fa és cercar el valor més baix, recorrent tot l’<em>array</em>, i posar-lo a la primera posició. Amb això ja tenim la garantia d’haver resolt quin valor ha d’acabar a la primera posició. Llavors se cerca el segon valor més baix, recorrent la seqüència des de la segona posició fins al final, i es posa a la segona posició. I l’operació es va repetint fins a arribar a la darrera posició. Per fer aquesta tasca s’opera directament sobre els valors emmagatzemats a l’<em>array</em>, intercanviant-los cada cop que trobem un valor més baix que el que hi ha a la posició que s’està tractant.
</p>

<p>
El codi seria el següent. Analitzeu-lo per entendre què està fent i proveu que funciona correctament:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">//Un programa per ordenar valors usant l'algorisme de la bombolla.</div></li><li class="li1"><div class="de1">public class Ordenar {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    float[] llistaNotes = {5.5f, 9f, 2f, 10f, 4.9f};</div></li><li class="li1"><div class="de1">    //Bucle extern.</div></li><li class="li1"><div class="de1">    //S'anirà posant a cada posició tractada, començant per la 0, </div></li><li class="li1"><div class="de1">    //el valor més baix que es trobi. </div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaNotes.length - 1; i++) {</div></li><li class="li1"><div class="de1">      //Bucle intern.</div></li><li class="li1"><div class="de1">      //Se cerca entre la resta de posicions quin és el valor més baix.</div></li><li class="li1"><div class="de1">      for(int j = i + 1; j &lt; llistaNotes.length; j++) {</div></li><li class="li1"><div class="de1">        //La posició tractada té un valor més alt que el de la cerca. Els intercanviem.</div></li><li class="li1"><div class="de1">        if (llistaNotes[i] &gt; llistaNotes[j]) {</div></li><li class="li1"><div class="de1">          //Per intercanviar valors cal una variable auxiliar.</div></li><li class="li1"><div class="de1">          float canvi = llistaNotes[i];</div></li><li class="li1"><div class="de1">          llistaNotes[i] = llistaNotes[j];</div></li><li class="li1"><div class="de1">          llistaNotes[j] = canvi;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">      }   </div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //El mostrem per pantalla.</div></li><li class="li1"><div class="de1">    System.out.print(&quot;L'array ordenat és: [&quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaNotes.length;i++) {</div></li><li class="li1"><div class="de1">      System.out.print(llistaNotes[i] + &quot; &quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println(&quot;]&quot;);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
Com que aquest algorisme d’ordenació es basa en dos bucles imbricats, val la pena fer una ullada més detallada al seu funcionament. La <span class="tabref"><a href="#Table5"><span>taula</span></a></span> mostra un seguit d’iteracions fins a tenir en les dues primeres posicions els valors més baixos. Fixeu-vos com el valor de la variable comptador <code>j</code> sempre és superior a <code>i</code>. A les cel·les en què s’indica l’estat de l’<em>array</em> després de cada iteració, se subratllen les posicions que s’han intercanviat, si és el cas.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table5"><span>Taula: </span></a>Evolució de l’algorisme de la bombolla</div>
<div class="table"><table class="inline">
	<tr class="row0">
		<th class="col0 leftalign" colspan="4"> Inici del bucle                                                                      </th><th class="col4 leftalign"> Fi del bucle                 </th>
	</tr>
	<tr class="row1">
		<td class="col0"> <strong>‘i’ val</strong> </td><td class="col1"> <strong>‘j’ val</strong> </td><td class="col2"> <strong>‘llistaNotes’ val</strong> </td><td class="col3"> <strong>llistaNotes[i] &gt; llistaNotes[j]</strong> </td><td class="col4 leftalign"> <strong>‘llistaNotes’ val</strong>        </td>
	</tr>
	<tr class="row2">
		<td class="col0 centeralign" colspan="5">          Inici primera iteració bucle extern. Se cerca el valor més petit per posar-lo a la posició 0.             </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> 0           </td><td class="col1 leftalign"> 1           </td><td class="col2 leftalign"> {5.5, 9, 2, 10, 4.9}  </td><td class="col3 rightalign">                  5.5 &gt; 9, <code>false</code> </td><td class="col4 leftalign"> {5.5, 9, 2, 10, 4.9}         </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> 0           </td><td class="col1 leftalign"> 2           </td><td class="col2 leftalign"> {5.5, 9, 2, 10, 4.9}  </td><td class="col3 centeralign">          5.5 &gt; 2, <code>true</code>          </td><td class="col4"> {<em class="u">2</em>, 9, <em class="u">5.5</em>, 10, 4.9} </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> 0           </td><td class="col1 leftalign"> 3           </td><td class="col2 leftalign"> {2, 9, 5.5, 10, 4.9}  </td><td class="col3 centeralign">          2 &gt; 10, <code>false</code>          </td><td class="col4 leftalign"> {2, 9, 5.5, 10, 4.9}         </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> 0           </td><td class="col1 leftalign"> 4           </td><td class="col2 leftalign"> {2, 9, 5.5, 10, 4.9}  </td><td class="col3 rightalign">                  2 &gt; 4.9, <code>false</code> </td><td class="col4 leftalign"> {2, 9, 5.5, 10, 4.9}         </td>
	</tr>
	<tr class="row7">
		<td class="col0 centeralign" colspan="5">                  Fi primera iteració bucle extern. A <code>llistaNotes[0]</code> hi ha el valor més petit.                  </td>
	</tr>
	<tr class="row8">
		<td class="col0 centeralign" colspan="5">         Inici segona iteració bucle extern. Se cerca el segon valor més petit per posar-lo a la posició 1.         </td>
	</tr>
	<tr class="row9">
		<td class="col0 leftalign"> 1           </td><td class="col1 leftalign"> 2           </td><td class="col2 leftalign"> {2, 9, 5.5, 10, 4.9}  </td><td class="col3 centeralign">          9 &gt; 5.5, <code>true</code>          </td><td class="col4"> {2, <em class="u">5.5</em>, <em class="u">9</em>, 10, 4.9} </td>
	</tr>
	<tr class="row10">
		<td class="col0 leftalign"> 1           </td><td class="col1 leftalign"> 3           </td><td class="col2 leftalign"> {2, 5.5, 9, 10, 4.9}  </td><td class="col3 rightalign">                 5.5 &gt; 10, <code>false</code> </td><td class="col4 leftalign"> {2, 5.5, 9, 10, 4.9}         </td>
	</tr>
	<tr class="row11">
		<td class="col0 leftalign"> 1           </td><td class="col1 leftalign"> 4           </td><td class="col2 leftalign"> {2, 5.5, 9, 10, 4.9}  </td><td class="col3 rightalign">                 5.5 &gt; 4.9, <code>true</code> </td><td class="col4"> {2, <em class="u">4.9</em>, 9, 10, <em class="u">5.5</em>} </td>
	</tr>
	<tr class="row12">
		<td class="col0 centeralign" colspan="5">               Fi segona iteració bucle extern. A <code>llistaNotes[1]</code> hi ha el segon valor més petit.                </td>
	</tr>
	<tr class="row13">
		<td class="col0 centeralign" colspan="5">        Inici tercera iteració bucle extern. Se cerca el tercer valor més petit per posar-lo a la posició 2.        </td>
	</tr>
	<tr class="row14">
		<td class="col0 leftalign"> 2           </td><td class="col1 leftalign"> 3           </td><td class="col2 leftalign"> {2, 4.9, 9, 10, 5.5}  </td><td class="col3 rightalign">                   9 &gt; 10, <code>false</code> </td><td class="col4 leftalign"> {2, 4.9, 9 , 10, 5.5}        </td>
	</tr>
	<tr class="row15">
		<td class="col0 leftalign"> 2           </td><td class="col1 leftalign"> 4           </td><td class="col2 leftalign"> {2, 4.9, 9, 10, 5.5}  </td><td class="col3 rightalign">                   9 &gt; 5.5, <code>true</code> </td><td class="col4"> {2, 4.9, <em class="u">5.5</em>, 10, <em class="u">9</em>} </td>
	</tr>
	<tr class="row16">
		<td class="col0 centeralign" colspan="5">              Fi tercera iteració bucle extern. A <code>llistaNotes[2]</code> hi ha el tercer valor més petit.               </td>
	</tr>
	<tr class="row17">
		<td class="col0 centeralign" colspan="5">         Inici quarta iteració bucle extern. Se cerca el quart valor més petit per posar-lo a la posició 3.         </td>
	</tr>
	<tr class="row18">
		<td class="col0 leftalign"> 3           </td><td class="col1 leftalign"> 4           </td><td class="col2 leftalign"> {2, 4.9, 5.5, 10, 9}  </td><td class="col3 rightalign">                    10 &gt; 9, <code>true</code> </td><td class="col4"> {2, 4.9, 5.5, <em class="u">9</em>, <em class="u">10</em>} </td>
	</tr>
	<tr class="row19">
		<td class="col0 centeralign" colspan="5">               Fi tercera iteració bucle extern. A <code>llistaNotes[3]</code> hi ha el quart valor més petit.               </td>
	</tr>
	<tr class="row20">
		<td class="col0 centeralign" colspan="5">                                 Per força, a la posició 4 hi ha el valor més alt.                                  </td>
	</tr>
	<tr class="row21">
		<td class="col0 leftalign"> 4           </td><td class="col1 leftalign"> 4           </td><td class="col2 leftalign" colspan="3"> Hem sortit del bucle extern (4 &gt; llistaNotes.length - 1)                                 </td>
	</tr>
</table></div>
</div>
<p>
<strong>Repte 4:</strong> modifiqueu l’exemple d’ordenació de manera que, un cop ordenat l’<em>array</em>, es calculi la mitjana aritmètica <em class="u">només</em> dels estudiants que <em class="u">han suspès</em>. El bucle del recorregut ha de fer exactament tantes iteracions com estudiants suspesos hi hagi, i no pas com tota la mida de l’<em>array</em>. Reflexioneu atentament sobre com el fet que l’<em>array</em> estigui ordenat és determinant per assolir aquesta darrera condició.
</p>

</div>

<h2><a id="arrays_multidimensionals" >&quot;Arrays&quot; multidimensionals</a></h2>
<div class="level2">

<p>
Quan es declara un <em>array</em>, hi ha una propietat especial, a part del seu identificador de tipus i mida, que fins al moment s’ha obviat. Es tracta de la seva <strong>dimensió</strong>, el nombre d’índexs que cal usar per establir la posició que es vol tractar. Tots els <em>arrays</em> amb els quals heu treballat fins ara eren <strong>unidimensionals</strong>. N’hi havia prou amb un sol valor d’índex per indicar la posició que es volia accedir. Ara bé, res no impedeix que el nombre d’índexs sigui més gran que 1.
</p>
<div class="iocimportant"><div class="ioccontent">
<p>
Un <strong>array multidimensional</strong> és aquell en què per accedir a una posició concreta, en lloc d’usar un sol valor com a índex, s’usa una seqüència de diversos valors. Cada índex serveix com a coordenada per a una dimensió diferent.
</p>
</div></div><div class="iocnote"><div class="ioccontent">
<p>
L’ordre dels índexs és important.
</p>
</div></div>
<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10mu3_09.png" class="imgB" title="Un &quot;array&quot; de dimensió 2: una taula/-20" alt="Un &quot;array&quot; de dimensió 2: una taula/-20" /></li><li><small>Un &quot;array&quot; de dimensió 2: una taula</small></li>
</ul></div>

</p>

<p>
Entre els <em>arrays</em> multidimensionals, el cas més usat és el dels <em>arrays</em> bidimensionals, de dues dimensions. Aquest és un dels més fàcils de visualitzar i és, per tant, un bon punt de partida. Com que es tracta d’un tipus d’<em>array</em> en què calen dos índexs per establir una posició, es pot considerar que el seu comportament és com el d’una matriu, taula o full de càlcul. El primer índex indicaria la fila, mentre que el segon indicaria la columna on es troba la posició que es vol accedir.
</p>

<p>
Per exemple, suposeu que el programa per tractar notes d’estudiants ara ha de gestionar les notes individuals de cada estudiant per a un seguit d’exercicis, de manera que es poden fer càlculs addicionals: calcular la nota final segons els resultats individuals, veure l’evolució de cada estudiant al llarg del curs, etc. En aquest cas, tota aquesta informació es pot resumir de manera eficient en una taula o full de càlcul, en què els estudiants es poden organitzar per files, on cada columna correspon al valor d’una prova, i en què la darrera columna pot ser la nota final.
</p>

</div>

<h3><a id="declaracio_d_arrays_bidimensionals" >Declaració d&#039;&quot;arrays&quot; bidimensionals</a></h3>
<div class="level3">

<p>
La sintaxi per declarar i inicialitzar un <em>array</em> de dues dimensions és semblant a la dels unidimensionals, si bé ara cal especificar que hi ha un índex addicional. Això es fa usant un parell de claus extra, <code>[]</code>, sempre que calgui especificar un nou índex. 
</p>

<p>
Per declarar-ne un d’inicialitzat amb totes les posicions dels seus valors per defecte, caldria usar la sintaxi:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">paraulaClauTipus[] identificadorVariable = new paraulaClauTipus[nombreFiles][nombreColumnes];</div></li></ol></pre>

<p>
Com passava amb els <em>arrays</em> unidireccionals, el valor dels índexs, files i columnes, no ha de ser necessàriament un literal. Pot ser definit d’acord amb el contingut d’una variable, diferent per a cada execució del programa. El valor del nombre de files i columnes tampoc no ha de ser necessàriament el mateix.
</p>

<p>
La inicialització mitjançant valors concrets implica indicar tants valors com el nombre de files per columnes. Per fer-ho, primer s’enumeren els valors individuals que hi ha a cada fila de la mateixa manera que s’inicialitza un <em>array</em> unidimensional: una seqüència de valors separats per comes i envoltats per claudàtors, <code>{…}</code>. Un cop enumerades les files d’aquesta manera, aquestes s’enumeren al seu torn separades per comes i envoltades per claudàtors. Conceptualment, és com declarar un <em>array</em> de files, en què cada posició té un altre <em>array</em> de valors. Això es veu més clar amb la sintaxi, que és la següent:
</p>
<pre class="code C/l"><ol><li class="li1"><div class="de1">paraulaClauTipus[][] identificadorVariable = { </div></li><li class="li1"><div class="de1">                                             {Fila0valor1, Fila0valor2, ... , Fila0valorN},</div></li><li class="li1"><div class="de1">                                             {Fila1valor1, Fila1valor2, ... , Fila1valorN},</div></li><li class="li1"><div class="de1">                                             ..., </div></li><li class="li1"><div class="de1">                                             {FilaNvalor1, FilaNvalor2, ... , FilaNvalorN} </div></li><li class="li1"><div class="de1">                                             };</div></li></ol></pre>

<p>
Fixeu-vos com a l’inici i al final hi ha els claudàtors extra que tanquen la seqüència de files i després de cada fila hi ha una coma, per separar-les entre si. Per fer més clara la lectura, s’han usat diferents línies de text per indicar els valors emmagatzemats a cada fila, però res no impedeix escriure-ho tot en una sola línia molt llarga. De tota manera, és recomanable usar aquest format i intentar deixar espais on pertoqui de manera que els valors quedin alineats verticalment, ja que això facilita la comprensió del codi font.
</p>

<p>
Per exemple, per declarar i inicialitzar amb valors concrets un <em>array</em> bidimensional de tres files per cinc columnes de valors de tipus enter es faria:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">int[][] arrayBidi = { </div></li><li class="li1"><div class="de1">                    {1 ,2 ,3 ,4 ,5 },</div></li><li class="li1"><div class="de1">                    {6 ,7 ,8 ,9 ,10},</div></li><li class="li1"><div class="de1">                    {11,12,13,14,15} </div></li><li class="li1"><div class="de1">                    };</div></li></ol></pre>

<p>
Des del punt de vista d’una taula o matriu, La primera fila seria {1, 2, 3, 4, 5}, la segona {6 ,7 ,8 ,9 ,10} i la tercera {11,12,13,14,15}, tal com mostra la <span class="tabref"><a href="#Table6"><span>taula</span></a></span>.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table6"><span>Taula: </span></a>Resultat d’inicialitzar amb valors concrets un array bidimensional de tres files per cinc columnes</div>
<div class="table"><table class="inline">
	<tr class="row0">
		<td class="col0 leftalign"> 1  </td><td class="col1 leftalign"> 2  </td><td class="col2 leftalign"> 3  </td><td class="col3 leftalign"> 4  </td><td class="col4 leftalign"> 5  </td>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign"> 6  </td><td class="col1 leftalign"> 7  </td><td class="col2 leftalign"> 8  </td><td class="col3 leftalign"> 9  </td><td class="col4"> 10 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 11 </td><td class="col1"> 12 </td><td class="col2"> 13 </td><td class="col3"> 14 </td><td class="col4"> 15 </td>
	</tr>
</table></div>
</div>
<p>
En usar aquest tipus d’inicialització cal assegurar-se que les mides de totes les files siguin exactament igual (que tinguin el mateix nombre de valors separats entre comes), ja que cal garantir que totes les files tenen el mateix nombre de columnes.
</p>

</div>

<h3><a id="esquemes_d_us_d_arrays_bidimensionals" >Esquemes d&#039;ús d&#039;&quot;arrays&quot; bidimensionals</a></h3>
<div class="level3">

<p>
L’accés a les posicions d’un <em>array</em> bidimensional és pràcticament idèntic a l’unidireccional, però tenint en compte que ara hi ha dos índexs per preveure referents a les dues coordenades. 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">identificadorVariable[índexFila][índexColumna]</div></li></ol></pre>

<p>
La <span class="tabref"><a href="#Table7"><span>taula</span></a></span> fa un resum de com s’accediria a les diferents posicions d’un <em>array</em> de 4 * 5 posicions. En qualsevol cas, en accedir-hi, sempre cal mantenir present que cada índex mai no pot ser igual o superior al nombre de files o columnes, segons correspongui. En cas contrari, es produeix un error.
</p>
<div class="ioctable ">
<div class="titletable"><a name="Table7"><span>Taula: </span></a>Aquesta taula mateixa és un array bidimensional de 4 * 5 posicions</div>
<div class="table"><table class="inline">
	<tr class="row0">
		<td class="col0"> a[0][0] </td><td class="col1"> a[0][1] </td><td class="col2 rightalign">  a[0][2] </td><td class="col3 rightalign">  a[0][3] </td><td class="col4 rightalign">  a[0][4] </td>
	</tr>
	<tr class="row1">
		<td class="col0"> a[1][0] </td><td class="col1"> a[1][1] </td><td class="col2 rightalign">  a[1][2] </td><td class="col3 rightalign">  a[1][3] </td><td class="col4 rightalign">  a[1][4] </td>
	</tr>
	<tr class="row2">
		<td class="col0"> a[2][0] </td><td class="col1"> a[2][1] </td><td class="col2 rightalign">  a[2][2] </td><td class="col3 rightalign">  a[2][3] </td><td class="col4 rightalign">  a[2][4] </td>
	</tr>
	<tr class="row3">
		<td class="col0"> a[3][0] </td><td class="col1"> a[3][1] </td><td class="col2 rightalign">  a[3][2] </td><td class="col3 rightalign">  a[3][3] </td><td class="col4 rightalign">  a[3][4] </td>
	</tr>
</table></div>
</div>
<p>
Com que ara hi ha dos índexs, tots els esquemes fonamentals per treballar amb <em>arrays</em> bidimensionals es basen en dues estructures de repetició imbricades, una per tractar cada fila i l’altra per tractar cada valor individual dins de la fila. 
</p>
<div class="iocnote"><div class="ioccontent">
<p>
Assegureu-vos d’usar variables diferents per indicar cada índex.
</p>
</div></div>
<p>
En el cas d’<em>arrays</em> bidimensionals, l’atribut <code>length</code> té un comportament una mica especial, ja que ara hi ha dos índexs. Per entendre’l, cal recordar que per inicialitzar l’<em>array</em> el que es fa és enumerar una llista de files, dins de les quals hi ha els valors emmagatzemats realment. Per tant, el que us diu l’atribut és el nombre de files que hi ha.
</p>

<p>
Per saber el nombre de valors d’una fila heu de fer:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">identificadorVariable[índexFila].length</div></li></ol></pre>

<p>
Per exemple, si la <span class="tabref"><a href="#Table7"><span>taula</span></a></span> correspon a una variable anomenada <code>arrayBidi</code>, <code>arrayBidi.length</code> avalua a 4 (hi ha quatre files) i <code>arrayBidi[0].length</code>, <code>arrayBidi[1].length</code>, etc. tots avaluen a 5 (hi ha 5 columnes).
</p>

</div>

<h4><a id="inicialitzacio_procedural1" >Inicialització procedural</a></h4>
<div class="level4">

<p>
Novament, es pot donar el cas en què vulgueu assignar a cada posició valors que cal calcular prèviament i que, per tant, calgui anar assignant un per un a totes les posicions de l’<em>array</em> bidimensional. 
</p>

<p>
A mode d’exemple, compileu i executeu el codi font següent, que emmagatzema a cada posició la suma dels índexs d’un <em>array</em> bidimensional de dimensions arbitràries i després visualitza el resultat per pantalla, ordenat per files.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">import java.util.Scanner;</div></li><li class="li1"><div class="de1">//Un programa que inicialitza un array bidimensional.</div></li><li class="li1"><div class="de1">public class InicialitzacioBidi {</div></li><li class="li1"><div class="de1">  public static void main (String[]  args) {</div></li><li class="li1"><div class="de1">    Scanner lector = new Scanner(System.in);</div></li><li class="li1"><div class="de1">    //Llegeix les files.</div></li><li class="li1"><div class="de1">    int nombreFiles = 0;</div></li><li class="li1"><div class="de1">    while (nombreFiles &lt;= 0) {</div></li><li class="li1"><div class="de1">      System.out.print(&quot;Quantes files tindrà la taula? &quot;);</div></li><li class="li1"><div class="de1">      if (lector.hasNextInt()) {</div></li><li class="li1"><div class="de1">        nombreFiles = lector.nextInt();</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Aquest valor no és correcte. &quot;);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">    //Llegeix les columnes.</div></li><li class="li1"><div class="de1">    int nombreColumnes = 0;</div></li><li class="li1"><div class="de1">    while (nombreColumnes &lt;= 0) {</div></li><li class="li1"><div class="de1">      System.out.print(&quot;Quantes files tindrà la taula? &quot;);</div></li><li class="li1"><div class="de1">      if (lector.hasNextInt()) {</div></li><li class="li1"><div class="de1">        nombreColumnes = lector.nextInt();</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        lector.next();</div></li><li class="li1"><div class="de1">        System.out.print(&quot;Aquest valor no és correcte. &quot;);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    lector.nextLine();</div></li><li class="li1"><div class="de1">    //Inicialització amb valors per defecte.</div></li><li class="li1"><div class="de1">    int[][] arrayBidi = new int[nombreFiles][nombreColumnes];</div></li><li class="li1"><div class="de1">    //Observeu l'ús de l'atribut &quot;length&quot;.</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Hi ha &quot; + arrayBidi.length + &quot; files.&quot;);</div></li><li class="li1"><div class="de1">    System.out.println(&quot;Hi ha &quot; + arrayBidi[0].length + &quot;columnes.&quot;);</div></li><li class="li1"><div class="de1">    //Bucle per recórrer cada fila.</div></li><li class="li1"><div class="de1">    //&quot;i&quot; indica el número de fila.</div></li><li class="li1"><div class="de1">    for(int i = 0; i &lt; nombreFiles; i++) {</div></li><li class="li1"><div class="de1">      //Bucle per recórrer cada posició dins de la fila (columnes de la fila).</div></li><li class="li1"><div class="de1">      //&quot;j&quot; indica el número de fila.</div></li><li class="li1"><div class="de1">      for (int j = 0; j &lt; nombreColumnes; j++)  {</div></li><li class="li1"><div class="de1">        //Valor assignat a la posició: suma dels índex de fila i columna.</div></li><li class="li1"><div class="de1">        arrayBidi[i][j] = i + j;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Es visualitza el resultat, també calen dos bucles.</div></li><li class="li1"><div class="de1">    for(int i = 0; i &lt; nombreFiles; i++) {</div></li><li class="li1"><div class="de1">      //Inici de fila, obrim claudàtors.</div></li><li class="li1"><div class="de1">      System.out.print(&quot;Fila &quot; + i + &quot; { &quot;);</div></li><li class="li1"><div class="de1">      for (int j = 0; j &lt; nombreColumnes; j++)  {</div></li><li class="li1"><div class="de1">        System.out.print(arrayBidi[i][j] + &quot; &quot;);</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Al final de cada fila es tanquen claudàtors i es fa un salt de línia.</div></li><li class="li1"><div class="de1">      System.out.println(&quot;}&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h4><a id="recorregut1" >Recorregut</a></h4>
<div class="level4">

<p>
En el cas d’<em>arrays</em> bidimensionals, també pot passar que sigui necessari fer càlculs fent un recorregut per tots els valors continguts. Novament, cal anar fila per fila, mirant totes les posicions de cadascuna.
</p>

<p>
Per exemple, suposeu un programa en què es desa a cada fila el valor de les notes dels estudiants d’un curs. Es demana calcular la nota final de cada estudiant i emmagatzemar-la a la darrera columna, i també saber la mitjana de totes les notes finals. El codi es mostra tot seguit; analitzeu-lo i proveu que funciona. En aquest cas, per facilitar-ne l’execució, els valors de les notes estan inicialitzats per a valors concrets. En el cas de la nota final de cada estudiant, inicialment es deixa a 0 i serà el programa el qui la calculi.
</p>

<p>
Ara sí: observeu atentament l’ús de l’atribut <code>length</code> per controlar els índexs en recórrer l’<em>array</em> i saber quin és el nombre de valors en una fila o el nombre de files.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">//Un programa que calcula notes mitjanes en un array bidimensional.</div></li><li class="li1"><div class="de1">public class RecorregutBidi {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    //Dades de les notes.</div></li><li class="li1"><div class="de1">    float[][] arrayBidiNotes = {</div></li><li class="li1"><div class="de1">                                 { 4.5f, 6f  , 5f  , 8f  , 0f  },</div></li><li class="li1"><div class="de1">                                 { 10f , 8f  , 7.5f, 9.5f, 0f  },</div></li><li class="li1"><div class="de1">                                 { 3f  , 2.5f, 4.5f, 6f  , 0f  },</div></li><li class="li1"><div class="de1">                                 { 6f  , 8.5f, 6f  , 4f  , 0f  },</div></li><li class="li1"><div class="de1">                                 { 9f  , 7.5f, 7f  , 8f  , 0f  }</div></li><li class="li1"><div class="de1">                                 };</div></li><li class="li1"><div class="de1">    //Mitjana aritmètica del curs per a tots els estudiants.</div></li><li class="li1"><div class="de1">    float sumaFinals = 0f;</div></li><li class="li1"><div class="de1">    //Es fa tractant fila per fila, indicada per &quot;i&quot;. Cada fila és un estudiant.</div></li><li class="li1"><div class="de1">    //&quot;arrayBidiNotes.length&quot; avalua al nombre de files.</div></li><li class="li1"><div class="de1">    for(int i = 0; i &lt; arrayBidiNotes.length; i++) {</div></li><li class="li1"><div class="de1">      //Aquí s'acumulen les notes de l'estudiant tractat.</div></li><li class="li1"><div class="de1">      float sumaNotes = 0f;</div></li><li class="li1"><div class="de1">      //Tractem cada fila (cada estudiant). Cada nota la indexa &quot;j&quot;.</div></li><li class="li1"><div class="de1">      //&quot;arrayBidiNotes[i].length&quot; avalua al nombre de posicions de la fila.</div></li><li class="li1"><div class="de1">      for(int j = 0; j &lt; arrayBidiNotes[i].length; j++) {</div></li><li class="li1"><div class="de1">          //Estem a la darrera posició de la fila?</div></li><li class="li1"><div class="de1">        if(j != (arrayBidiNotes[i].length - 1)) {</div></li><li class="li1"><div class="de1">          //Si no és la darrera posició, anem acumulant valors.</div></li><li class="li1"><div class="de1">          sumaNotes = sumaNotes + arrayBidiNotes[i][j];</div></li><li class="li1"><div class="de1">        } else {</div></li><li class="li1"><div class="de1">          //Si ho és, cal escriure la mitjana.</div></li><li class="li1"><div class="de1">          //Hi ha tantes notes com la mida d'una fila − 1.</div></li><li class="li1"><div class="de1">          float notaFinal =  sumaNotes/(arrayBidiNotes[i].length - 1);</div></li><li class="li1"><div class="de1">          arrayBidiNotes[i][j] = notaFinal;</div></li><li class="li1"><div class="de1">          System.out.println(&quot;L'estudiant &quot; + i + &quot; ha tret &quot; + notaFinal + &quot;.&quot;);</div></li><li class="li1"><div class="de1">          //S'actualitza la suma de mitjanes de tots els estudiants.</div></li><li class="li1"><div class="de1">          sumaFinals = sumaFinals + notaFinal;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Fi del tractament d'una fila.</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Fi del tractament de totes les files.</div></li><li class="li1"><div class="de1">    //Es calcula la mitjana: suma de notes finals dividit entre nombre d'estudiants.</div></li><li class="li1"><div class="de1">    float mitjanaFinal = sumaFinals / arrayBidiNotes.length;</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La nota mitjana del curs és &quot; + mitjanaFinal);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

<h4><a id="cerca1" >Cerca</a></h4>
<div class="level4">

<p>
En <em>arrays</em> bidimensionals la cerca també implica haver de gestionar dos índexs per anar avançant per files i columnes. Ara bé, aquest cas és especialment interessant, ja que en assolir l’objectiu cal sortir de les dues estructures de repetició imbricades. Per tant, no es pot usar simplement una sentència <code>break</code>, ja que només serveix per sortir d’un únic bucle. Cal tenir un semàfor que s’avaluï en tots dos bucles.
</p>

<p>
Per exemple, suposeu que el programa de gestió de notes vol cercar si algun estudiant ha tret un 0 en algun dels exercicis al llarg del curs. Caldrà anar mirant fila per fila totes les notes de cada estudiant, i quan es trobi un 0, acabar immediatament la cerca. El codi per fer-ho, basant-se exclusivament en un semàfor que diu si ja s’ha trobat el valor, seria el següent. Proveu-lo al vostre entorn de treball.
</p>

<p>
En un cas com aquest, cal anar amb molt de compte a inicialitzar i incrementar correctament l’índex per recórrer la posició de cada fila (és a dir, que mira cada columna), ja que en usar una sentència <code>while</code> en lloc de <code>for</code> no es fa automàticament. Si us despisteu i no ho feu, el valor serà incorrecte per a successives iteracions del bucle que recorre les files i el programa no actuarà correctament.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">//Un programa que cerca un 0 entre els valors d'un array bidimensional.</div></li><li class="li1"><div class="de1">public class CercaBidi {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    //Dades de les notes.</div></li><li class="li1"><div class="de1">    float[][] arrayBidiNotes = {</div></li><li class="li1"><div class="de1">                               { 4.5f, 6f  , 5f  , 8f  },</div></li><li class="li1"><div class="de1">                               { 10f , 8f  , 7.5f, 9.5f},</div></li><li class="li1"><div class="de1">                               { 3f  , 2.5f, 0f  , 6f  },</div></li><li class="li1"><div class="de1">                               { 6f  , 8.5f, 6f  , 4f  },</div></li><li class="li1"><div class="de1">                               { 9f  , 7.5f, 7f  , 8f  }</div></li><li class="li1"><div class="de1">                               };</div></li><li class="li1"><div class="de1">    //Mirarem quin estudiant ha tret el 0.</div></li><li class="li1"><div class="de1">    //Inicialitzem a un valor invàlid (de moment, cap estudiant té un 0)</div></li><li class="li1"><div class="de1">    //Aquest valor fa de semàfor. Si pren un valor diferent, cal acabar la cerca.</div></li><li class="li1"><div class="de1">    int estudiant = -1;</div></li><li class="li1"><div class="de1">    //&quot;i indica la fila.</div></li><li class="li1"><div class="de1">    int i =0;</div></li><li class="li1"><div class="de1">    //Es va fila per fila.</div></li><li class="li1"><div class="de1">    //S'acaba si s'ha trobat un 0 o si ja s'ha cercat a totes les files.</div></li><li class="li1"><div class="de1">    while ((estudiant == -1)&amp;&amp;(i &lt; arrayBidiNotes.length)){</div></li><li class="li1"><div class="de1">      //&quot;j indica la &quot;columna&quot;.</div></li><li class="li1"><div class="de1">      int j =0;</div></li><li class="li1"><div class="de1">      //Se cerca en una fila.</div></li><li class="li1"><div class="de1">      //S'acaba si s'ha trobat un 0 o si ja s'ha cercat a totes les posicions.</div></li><li class="li1"><div class="de1">      while ((estudiant == -1)&amp;&amp;(j &lt; arrayBidiNotes[i].length)){</div></li><li class="li1"><div class="de1">        //Aquesta nota és un 0?</div></li><li class="li1"><div class="de1">        if  (arrayBidiNotes[i][j] == 0f) {</div></li><li class="li1"><div class="de1">          //L'índex que diu l'estudiant és el de la fila.</div></li><li class="li1"><div class="de1">          estudiant = i;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">        //S'avança a la posició següent dins de la fila.</div></li><li class="li1"><div class="de1">        j++;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      //Fi del tractament d'una fila.</div></li><li class="li1"><div class="de1">      //S'avança a la fila següent.</div></li><li class="li1"><div class="de1">      i++;</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //Fi del tractament de totes les files.</div></li><li class="li1"><div class="de1">    if (estudiant == -1) {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Cap estudiant no té un 0.&quot;);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;L'estudiant &quot; + estudiant + &quot; té un 0.&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 5:</strong> modifiqueu el programa de manera que se cerqui si algú ha tret un 0, però només en el segon exercici (posició 1 de cada fila). Reflexioneu atentament sobre si ara realment cal usar dues estructures de repetició o no.
</p>

</div>

<h3><a id="arrays_de_mes_de_dues_dimensions" >&quot;Arrays&quot; de més de dues dimensions</a></h3>
<div class="level3">

<p>
El cas dels <em>arrays</em> bidimensionals és el més comú, però res no impedeix que el nombre d’índexs necessaris per situar una posició sigui també més gran de dos, d’un valor arbitrari. Un <em>array</em> de tres dimensions encara es pot visualitzar com una estructura tridimensional en forma de cub, però dimensions superiors ja requereixen més grau d’abstracció, i per això només es presentaran, sense entrar en més detall. 
</p>

<p>
<div class="iocfigurec">
<ul>
<li>
<img src="../media/ic10mu3_10.png" class="imgB" title=" Un &quot;array&quot; amb tres dimensions: el cub de Rubik. Imatge de Wikimedia Commons/-21" alt=" Un &quot;array&quot; amb tres dimensions: el cub de Rubik. Imatge de Wikimedia Commons/-21" /></li><li><small> Un &quot;array&quot; amb tres dimensions: el cub de Rubik. Imatge de Wikimedia Commons</small></li>
</ul></div>

</p>

<p>
Conceptualment, es pot considerar que defineixen una estructura d’<em>arrays</em> imbricats a diferents nivells com el que es mostra a la <span class="figref"><a href="#Figure7"><span>figura</span></a></span>. Cada nivell correspon a una dimensió diferent.
</p>
<div class="iocfigure"><a name="Figure7"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Un “array” multidimensional: “arrays” dins d’“arrays” dins d’“arrays”…

</figcaption><img src="../media/ic10mu3_11.png" alt="" /></figure>
</div>
<p>
Cada índex individual identifica una casella de l’<em>array</em> triat d’una dimensió determinada, de manera que el conjunt d’índexs serveix com a coordenada per establir el valor final (que ja no serà un altre <em>array</em>) al qual es vol accedir. La <span class="figref"><a href="#Figure8"><span>figura</span></a></span> en mostra un exemple de quatre dimensions.
</p>
<div class="iocfigure"><a name="Figure8"></a><figure>
<figcaption><span class="figuretitle">Figura</span>

Accés a un “array” de quatre dimensions (calen 4 índexs)

</figcaption><img src="../media/ic10mu3_12.png" alt="" /></figure>
</div>
<p>
Tot i que aquesta estructura sembla força complexa, no és gaire diferent d’una estructura de carpetes i fitxers, en què les carpetes prenen el paper dels <em>arrays</em> i els fitxers el de les dades que es volen desar. Podeu tenir una única carpeta per emmagatzemar totes les fotos, que seria el cas d’un únic nivell d’<em>array</em> (o sigui, els <em>arrays</em> tal com s’han vist fins ara). Però també les podríeu organitzar amb una carpeta que al seu torn conté altres carpetes, dins de les quals es desen diferents fotos. Això seria equivalent a disposar de dos nivells d’<em>arrays</em>. I així podríeu anar creant una estructura de carpetes amb tants nivells com volguéssiu. Per triar un fitxer n’hi ha prou a saber en quin ordre cal anar obrint les carpetes fins a arribar a la carpeta final, on ja només us cal l’ordre del fitxer.
</p>

<p>
Estenent les restriccions que compleixen els <em>arrays</em> bidireccionals al cas dels <em>arrays</em> multidimensionals:
</p>
<ul>
<li class="level1"><div class="li"> En una mateixa dimensió, tots els <em>arrays</em> tindran <em class="u">exactament</em> la mateixa mida.</div>
</li>
<li class="level1"><div class="li"> El tipus de dada que es desa a les posicions de la darrera dimensió serà el mateix per a tots. Per exemple, no es poden tenir reals i enters barrejats.</div>
</li>
</ul>

<p>
En llenguatge Java, per afegir noves dimensions per sobre de la segona, cal anar afegint claus <code>[]</code> addicionals a la declaració, una per a cada dimensió. 
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">paraulaClauTipus[]...[] identificadorVariable = new paraulaClauTipus[midaDim1]...[midaDimN];</div></li></ol></pre>

<p>
Per exemple, per declarar amb valors per defecte un <em>array</em> de quatre dimensions, la primera de mida 5, la segona de 10, la tercera de 4 i la quarta de 20, caldria la instrucció:
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">int[][][][] arrayQuatreDimensions = new int[5][10][4][20]; </div></li><li class="li1"><div class="de1">...</div></li></ol></pre>

<p>
L’accés seria anàleg als <em>arrays</em> bidimensionals, però usant quatre índexs envoltats per parells de claus.
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">...</div></li><li class="li1"><div class="de1">int valor = arrayQuatreDimensions[2][0][1][20]; </div></li><li class="li1"><div class="de1">...</div></li></ol></pre>

<p>
En qualsevol cas, es tracta d’estructures complexes que no se solen usar excepte en casos molt específics.
</p>

<p>

</p>

</div>

<h2><a id="solucions_dels_reptes_proposats" >Solucions dels reptes proposats</a></h2>
<div class="level2">

<p>
<strong>Repte 1:</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class InicialitzaParells {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    //Caldrà emmagatzemar 100 enters.</div></li><li class="li1"><div class="de1">    int[] arrayParells = new int[100];</div></li><li class="li1"><div class="de1">    //Anem omplint cada posició.</div></li><li class="li1"><div class="de1">    for(int  i = 0; i &lt; arrayParells.length; i++) {</div></li><li class="li1"><div class="de1">      arrayParells[i] = 2*i;</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 2:</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class RecorregutMaxima {</div></li><li class="li1"><div class="de1">  public static void main(String[] args) {</div></li><li class="li1"><div class="de1">    //Es parteix d'un array que conté tots els seus valors.</div></li><li class="li1"><div class="de1">    float[] arrayNotes =  {2f, 5.5f, 9f, 10f, 4.9f, 8f, 8.5f, 7f, 6.6f, 5f, 9f, 7f};</div></li><li class="li1"><div class="de1">    //Valor màxim fins al moment.</div></li><li class="li1"><div class="de1">    float notaMaxima = 0;</div></li><li class="li1"><div class="de1">    //Cal recòrrer tot l'array d'extrem a extrem i desar el valor més gran.</div></li><li class="li1"><div class="de1">    for(int i = 0; i &lt; arrayNotes.length; i++) {</div></li><li class="li1"><div class="de1">      if (notaMaxima &lt; arrayNotes[i]) {</div></li><li class="li1"><div class="de1">        notaMaxima = arrayNotes[i];</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La nota màxima és &quot; + notaMaxima);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>
<strong>Repte 3:</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class CercaSuspes {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    //Es parteix d'un array que conté tots els seus valors.</div></li><li class="li1"><div class="de1">    float[] arrayNotes =  {2f, 5.5f, 9f, 10f, 4.9f, 8f, 8.5f, 7f, 6.6f, 5f, 9f, 7f};</div></li><li class="li1"><div class="de1">    int i = 0;</div></li><li class="li1"><div class="de1">    //Es va mirant cada posició, mentre no s'arriba al final i no es trobi un suspès.</div></li><li class="li1"><div class="de1">    //Es pot usar tant &quot;break&quot; com &quot;for&quot;.</div></li><li class="li1"><div class="de1">    //En trobar un suspès, directament sortim del bucle.</div></li><li class="li1"><div class="de1">    while (i &lt; arrayNotes.length) {</div></li><li class="li1"><div class="de1">      if (arrayNotes[i] &lt; 5) {</div></li><li class="li1"><div class="de1">        break;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">      i++;</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    if (i == arrayNotes.length) {</div></li><li class="li1"><div class="de1">      //Si s'ha superat la mida de l'array, és que no s'ha trobat cap suspès.</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Ningú no ha suspès.&quot;);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      //Si s'ha sortit abans d'acabar l'array, és que hi havia un suspès.</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Algú ha suspès.&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>

</p>

<p>
<strong>Repte 4:</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class MitjanaSuspesosOrdenats {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    float[] llistaNotes = {5.5f, 9f, 2f, 10f, 4.9f};</div></li><li class="li1"><div class="de1">    //Bucle extern.</div></li><li class="li1"><div class="de1">    //S'anirà posant a cada posició tractada, començant per la 0,</div></li><li class="li1"><div class="de1">    //el valor més baix que es trobi.</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaNotes.length - 1; i++) {</div></li><li class="li1"><div class="de1">      //Bucle intern.</div></li><li class="li1"><div class="de1">      //Se cerca entre la resta de posicions quin és el valor més baix.</div></li><li class="li1"><div class="de1">      for(int j = i + 1; j &lt; llistaNotes.length; j++) {</div></li><li class="li1"><div class="de1">        //La posició tractada té un valor més gran que el de la cerca; els intercanviem.</div></li><li class="li1"><div class="de1">        if (llistaNotes[i] &gt; llistaNotes[j]) {</div></li><li class="li1"><div class="de1">          //Per intercanviar valors cal una variable auxiliar.</div></li><li class="li1"><div class="de1">          float canvi = llistaNotes[i];</div></li><li class="li1"><div class="de1">          llistaNotes[i] = llistaNotes[j];</div></li><li class="li1"><div class="de1">          llistaNotes[j] = canvi;</div></li><li class="li1"><div class="de1">        }</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    //El mostrem per pantalla.</div></li><li class="li1"><div class="de1">    System.out.print(&quot;L'array ordenat és: [&quot;);</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaNotes.length;i++) {</div></li><li class="li1"><div class="de1">      System.out.print(llistaNotes[i] + &quot; &quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    System.out.println(&quot;]&quot;);</div></li><li class="li1"><div class="de1">    //Inici de les modificacions.</div></li><li class="li1"><div class="de1">    //Valor acumulat per fer la mitjana.</div></li><li class="li1"><div class="de1">    float acumulat = 0;</div></li><li class="li1"><div class="de1">    //Nombre de suspesos.</div></li><li class="li1"><div class="de1">    int numSuspes = 0;</div></li><li class="li1"><div class="de1">    //Inici de la nova part.</div></li><li class="li1"><div class="de1">    //Com l'array està ordenat, només cal fer un recorregut fins trobar un aprovat,</div></li><li class="li1"><div class="de1">    //no cal arribar al final. Un cop es troba el primer aprovat, la resta de</div></li><li class="li1"><div class="de1">    //posicions segur que també són aprovats, ja que l'array està ordenat.</div></li><li class="li1"><div class="de1">    for (int i = 0; i &lt; llistaNotes.length; i++) {</div></li><li class="li1"><div class="de1">      //És la nota d'un aprovat?</div></li><li class="li1"><div class="de1">      if (llistaNotes[i] &gt;= 5) {</div></li><li class="li1"><div class="de1">        //S'ha trobat el primer aprovat, sortim del bucle!</div></li><li class="li1"><div class="de1">        break;</div></li><li class="li1"><div class="de1">      } else {</div></li><li class="li1"><div class="de1">        //És un suspès, anem calculant.</div></li><li class="li1"><div class="de1">        acumulat = acumulat + llistaNotes[i];</div></li><li class="li1"><div class="de1">        //S'incrementa el nombre de suspesos.</div></li><li class="li1"><div class="de1">        numSuspes++;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    float resultat = acumulat/numSuspes;</div></li><li class="li1"><div class="de1">    System.out.println(&quot;La nota mitjana dels suspesos és &quot; + resultat);</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

<p>

</p>

<p>
<strong>Repte 5:</strong>
</p>
<pre class="code java"><ol><li class="li1"><div class="de1">public class CercaBidiZero {</div></li><li class="li1"><div class="de1">  public static void main (String[] args) {</div></li><li class="li1"><div class="de1">    //Dades de les notes.</div></li><li class="li1"><div class="de1">    float[][] arrayBidiNotes = {</div></li><li class="li1"><div class="de1">                               { 4.5f, 6f  , 5f  , 8f  },</div></li><li class="li1"><div class="de1">                               { 10f , 8f  , 7.5f, 9.5f},</div></li><li class="li1"><div class="de1">                               { 3f  , 2.5f, 0f  , 6f  },</div></li><li class="li1"><div class="de1">                               { 6f  , 8.5f, 6f  , 4f  },</div></li><li class="li1"><div class="de1">                               { 9f  , 7.5f, 7f  , 8f  }</div></li><li class="li1"><div class="de1">                               };</div></li><li class="li1"><div class="de1">    //Calen dues estructures de repetició si els dos índexs han d'anar</div></li><li class="li1"><div class="de1">    //variant per recórrer totes les posicions. En aquest cas, un valor és</div></li><li class="li1"><div class="de1">    //sempre el mateix (posició 1 de cada fila); només varia el número de fila.</div></li><li class="li1"><div class="de1">    //Per tant, amb una única estructura n'hi ha prou.</div></li><li class="li1"><div class="de1">    //Mirarem quin estudiant ha tret el 0.</div></li><li class="li1"><div class="de1">    int estudiant = -1;</div></li><li class="li1"><div class="de1">    for (int numFila = 0; numFila &lt; arrayBidiNotes.length; numFila++) {</div></li><li class="li1"><div class="de1">      if (arrayBidiNotes[numFila][1] == 0) {</div></li><li class="li1"><div class="de1">        //Aquest estudiant té un 0.</div></li><li class="li1"><div class="de1">        estudiant = numFila;</div></li><li class="li1"><div class="de1">        //Ja podem sortir del bucle.</div></li><li class="li1"><div class="de1">        //Ho podem fer, ja que només hi ha una única estructura de repetició.</div></li><li class="li1"><div class="de1">        break;</div></li><li class="li1"><div class="de1">      }</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">    if (estudiant == -1) {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;Cap estudiant no té un 0.&quot;);</div></li><li class="li1"><div class="de1">    } else {</div></li><li class="li1"><div class="de1">      System.out.println(&quot;L'estudiant &quot; + estudiant + &quot; té un 0 en el segon exercici.&quot;);</div></li><li class="li1"><div class="de1">    }</div></li><li class="li1"><div class="de1">  }</div></li><li class="li1"><div class="de1">}</div></li></ol></pre>

</div>

	 </article>
     <div class="pnpage">
      <div class="left-corner"></div>
      <div id="prevpage">Anar a la p&agrave;gina anterior:<br /><a href="../../../WebContent/u3/referencies.html">Referències</a></div>
      <div id="nextpage">Anar a la p&agrave;gina seg&uuml;ent:<br /><a href="../../../WebContent/u3/a1/activitats.html">Activitats</a></div>
      <div class="right-corner"></div>
     </div>
    </div>
    <footer class="footer">
      <div><small>Aquest document està subjecte a una llicència oberta de Creative Commons, es reserva el dret de reconeixement de l'autoria, d'exigir que no se'n faci cap mena d'ús comercial. Si altereu o transformeu aquesta obra, o en genereu obres derivades, només podeu distribuir l'obra generada amb una llicència idèntica a aquesta.</small></div>
    </footer>
 </div>
 <div id="back_preview" class="hidden"></div>
 <div id="preview" class="hidden">
  <div class="prevcontent"></div>
 </div>
 <div id="help-tooltips">
  <div id="help-toc" class="hidden tooltip"><span>Taula de continguts:</span> Ofereix una vista general de l&#39;estructura del m&ograve;dul, que us facilitar&agrave; la navegaci&oacute; a trav&eacute;s dels seus continguts.<span class="arrow-left"></span></div> 
  <div id="help-settings" class="hidden tooltip"><span>Opcions de format:</span> Permet configurar el format de lectura a partir de les vostres prefer&egrave;ncies, modificant la mida de la lletra, el color del fons, l&#39;amplada de la p&agrave;gina o l&#39;ocultaci&oacute; dels continguts complementaris, entre d&#39;altres.<span class="arrow-left"></span></div>
  <div id="help-printer" class="hidden tooltip"><span>Imprimir:</span>  Envia el contingut seleccionat a la impressora.<span class="arrow-left"></span></div>
  <div id="help-favorites" class="hidden tooltip"><span>Prefereits:</span> Permet desar aquelles parts del contingut a les que us interessi accedir en un moment posterior; us permetr&agrave; anar creant un repositori personalitzat de les seccions que considereu m&eacute;s rellevants. Un cop l&#39;hageu començat a fer servir se us mostrar&agrave; a sota un comptador que us informar&agrave; del nombre de preferits que s&#39;hagin emmagatzemat fins al moment.<span class="arrow-left"></span></div>
  <div id="help-favcounter" class="hidden tooltip"><span>Comptador i llistat de preferits:</span> Indica el nombre de preferits que s&#39;han desat fins el moment; clicant damunt seu accedireu al llistat de preferits, i a trav&eacute;s d&#39;aquest podreu accedir directament als continguts que hageu emmagatzemat.<span class="arrow-left"></span></div>
  <div id="help-help_icon" class="hidden tooltip"><span>Ajuda:</span> Aquesta opci&oacute; activa la informaci&oacute; de les funcionalitats del web tot situant el punter del ratol&iacute; al damunt dels diferents &iacute;tems.<span class="arrow-left"></span></div>
  <div id="help-sidebar-hide" class="hidden tooltip"><span>Mostrar/Ocultar barra lateral:</span>  Deshabilita la barra d&#39;opcions, permetent la seva recuperaci&oacute; quan es desitgi.<span class="arrow-left"></span></div>
  <div id="help-search" class="hidden tooltip"><span>Cerca:</span>  Introdu&iuml;u les paraules clau sobre aquells conceptes que desitgeu localitzar en els continguts del m&ograve;dul. Tamb&eacute; podeu excloure un terme de la cerca tot afegint-hi el signe &#8220;-&#8221; al davant.<span class="arrow-top"></span></div>
  <div id="help-header" class="hidden tooltip"><span>Cap&ccedil;alera:</span>  Indica l&#39;apartat o secci&oacute; que es mostra en pantalla. Tingueu present que les capçaleres de segon, tercer i quart nivell tamb&eacute; es poden desar com a marcadors.<span class="arrow-left"></span></div>
</div> 
</body>
</html>
